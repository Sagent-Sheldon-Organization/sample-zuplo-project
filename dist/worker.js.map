{
  "version": 3,
  "sources": ["../../../../../../../app/packages/debug/src/colors.ts", "../../../../../../../app/packages/debug/src/format.ts", "../../../../../../../app/packages/debug/src/worker/inspect.ts", "../../../../../../../app/packages/debug/src/worker/format.ts", "../../../../../../../app/packages/debug/src/worker/debug.ts", "../../../../../../../app/packages/runtime/src/errors.ts", "../../../../../../../app/packages/runtime/src/compatibility-flags.generated.ts", "../../../../../../../app/packages/runtime/src/mocks/environment.ts", "../../../../../../../app/packages/runtime/src/utils/environment.ts", "../../../../../../../app/packages/runtime/src/external-services.ts", "../../../../../../../app/packages/runtime/src/fetch-redefinition.ts", "../../../../../../../app/packages/runtime/src/internals.ts", "../../../../../../../app/packages/runtime/src/security.ts", "../../../../../../../app/packages/runtime/src/caches/memory-cache.ts", "../../../../../../../app/packages/runtime/src/caches/zone-cache.ts", "../../../../../../../app/packages/runtime/src/caches/memory-zone-readthrough-cache.ts", "../../../../../../../app/packages/runtime/src/constants.ts", "../../../../../../../app/node_modules/@opentelemetry/api/src/platform/browser/globalThis.ts", "../../../../../../../app/node_modules/@opentelemetry/api/src/platform/browser/index.ts", "../../../../../../../app/node_modules/@opentelemetry/api/src/version.ts", "../../../../../../../app/node_modules/@opentelemetry/api/src/internal/semver.ts", "../../../../../../../app/node_modules/@opentelemetry/api/src/internal/global-utils.ts", "../../../../../../../app/node_modules/@opentelemetry/api/src/diag/ComponentLogger.ts", "../../../../../../../app/node_modules/@opentelemetry/api/src/diag/types.ts", "../../../../../../../app/node_modules/@opentelemetry/api/src/diag/internal/logLevelLogger.ts", "../../../../../../../app/node_modules/@opentelemetry/api/src/api/diag.ts", "../../../../../../../app/node_modules/@opentelemetry/api/src/context/context.ts", "../../../../../../../app/node_modules/@opentelemetry/api/src/context/NoopContextManager.ts", "../../../../../../../app/node_modules/@opentelemetry/api/src/api/context.ts", "../../../../../../../app/node_modules/@opentelemetry/api/src/trace/trace_flags.ts", "../../../../../../../app/node_modules/@opentelemetry/api/src/trace/invalid-span-constants.ts", "../../../../../../../app/node_modules/@opentelemetry/api/src/trace/NonRecordingSpan.ts", "../../../../../../../app/node_modules/@opentelemetry/api/src/trace/context-utils.ts", "../../../../../../../app/node_modules/@opentelemetry/api/src/trace/spancontext-utils.ts", "../../../../../../../app/node_modules/@opentelemetry/api/src/trace/NoopTracer.ts", "../../../../../../../app/node_modules/@opentelemetry/api/src/trace/ProxyTracer.ts", "../../../../../../../app/node_modules/@opentelemetry/api/src/trace/NoopTracerProvider.ts", "../../../../../../../app/node_modules/@opentelemetry/api/src/trace/ProxyTracerProvider.ts", "../../../../../../../app/node_modules/@opentelemetry/api/src/trace/status.ts", "../../../../../../../app/node_modules/@opentelemetry/api/src/api/trace.ts", "../../../../../../../app/node_modules/@opentelemetry/api/src/trace-api.ts", "../../../../../../../app/node_modules/@opentelemetry/api/src/index.ts", "../../../../../../../app/packages/runtime/src/diagnostics/telemetry.ts", "../../../../../../../app/packages/runtime/src/plugins/plugins.ts", "../../../../../../../app/packages/runtime/src/problem-responses/problem-response-formatter.ts", "../../../../../../../app/packages/runtime/src/utils/freeze.ts", "../../../../../../../app/packages/runtime/src/request.ts", "../../../../../../../app/packages/runtime/src/extensions.ts", "../../../../../../../app/packages/runtime/src/serializer.ts", "../../../../../../../app/packages/runtime/src/utils/system-routes.ts", "../../../../../../../app/packages/runtime/src/pipeline.ts", "../../../../../../../app/packages/runtime/src/metrics/v1/metrics-plugin.ts", "../../../../../../../app/packages/runtime/src/system-log-map.ts", "../../../../../../../app/packages/runtime/src/utils/batch-dispatch.ts", "../../../../../../../app/packages/runtime/src/metrics/v1/transports/ellie-metrics.ts", "../../../../../../../app/packages/runtime/src/router/system-route-configuration.ts", "../../../../../../../app/packages/runtime/src/processors/metrics-processor.ts", "../../../../../../../app/packages/runtime/src/router/interfaces.custom.ts", "../../../../../../../app/packages/runtime/dist/router/interfaces.generated.js", "../../../../../../../app/packages/runtime/src/router/interfaces.ts", "../../../../../../../app/packages/runtime/src/built-in-routes/build-route.ts", "../../../../../../../app/packages/runtime/src/http-status.ts", "../../../../../../../app/packages/runtime/src/statuses.ts", "../../../../../../../app/packages/runtime/src/problem-responses/http-problems.ts", "../../../../../../../app/packages/runtime/src/utils/types.ts", "../../../../../../../app/packages/runtime/src/utils/options-parsing.ts", "../../../../../../../app/packages/runtime/src/utils/cors.ts", "../../../../../../../app/packages/runtime/src/built-in-routes/cors-route.ts", "../../../../../../../app/packages/runtime/src/built-in-routes/no-routes.ts", "../../../../../../../app/packages/runtime/src/built-in-routes/not-found-route.ts", "../../../../../../../app/packages/runtime/src/processors/cors-processor.ts", "../../../../../../../app/packages/runtime/src/built-in-routes/ping-route.ts", "../../../../../../../app/packages/runtime/src/diagnostics/attributes.ts", "../../../../../../../app/packages/runtime/src/policies.ts", "../../../../../../../app/packages/runtime/src/processors/policy-processor.ts", "../../../../../../../app/packages/runtime/src/utils/cookie.ts", "../../../../../../../app/packages/runtime/src/utils/dev-portal.ts", "../../../../../../../app/packages/runtime/src/dev-portal/routes-v3.ts", "../../../../../../../app/packages/runtime/src/logging/v1/core-logger.ts", "../../../../../../../app/packages/runtime/src/logging/v1/log-plugin.ts", "../../../../../../../app/packages/runtime/src/logging/v1/logging-context.ts", "../../../../../../../app/packages/runtime/src/logging/v1/request-logger.ts", "../../../../../../../app/packages/runtime/src/utils/serialize-error.ts", "../../../../../../../app/packages/runtime/src/utils/stringify-object.ts", "../../../../../../../app/packages/runtime/src/logging/v1/log-serializer-utils.ts", "../../../../../../../app/node_modules/jose/dist/browser/runtime/webcrypto.js", "../../../../../../../app/node_modules/jose/dist/browser/runtime/digest.js", "../../../../../../../app/node_modules/jose/dist/browser/lib/buffer_utils.js", "../../../../../../../app/node_modules/jose/dist/browser/runtime/base64url.js", "../../../../../../../app/node_modules/jose/dist/browser/util/errors.js", "../../../../../../../app/node_modules/jose/dist/browser/runtime/random.js", "../../../../../../../app/node_modules/jose/dist/browser/lib/iv.js", "../../../../../../../app/node_modules/jose/dist/browser/lib/check_iv_length.js", "../../../../../../../app/node_modules/jose/dist/browser/runtime/check_cek_length.js", "../../../../../../../app/node_modules/jose/dist/browser/runtime/timing_safe_equal.js", "../../../../../../../app/node_modules/jose/dist/browser/lib/crypto_key.js", "../../../../../../../app/node_modules/jose/dist/browser/lib/invalid_key_input.js", "../../../../../../../app/node_modules/jose/dist/browser/runtime/is_key_like.js", "../../../../../../../app/node_modules/jose/dist/browser/runtime/decrypt.js", "../../../../../../../app/node_modules/jose/dist/browser/runtime/zlib.js", "../../../../../../../app/node_modules/jose/dist/browser/lib/is_disjoint.js", "../../../../../../../app/node_modules/jose/dist/browser/lib/is_object.js", "../../../../../../../app/node_modules/jose/dist/browser/runtime/bogus.js", "../../../../../../../app/node_modules/jose/dist/browser/runtime/aeskw.js", "../../../../../../../app/node_modules/jose/dist/browser/runtime/ecdhes.js", "../../../../../../../app/node_modules/jose/dist/browser/lib/check_p2s.js", "../../../../../../../app/node_modules/jose/dist/browser/runtime/pbes2kw.js", "../../../../../../../app/node_modules/jose/dist/browser/runtime/subtle_rsaes.js", "../../../../../../../app/node_modules/jose/dist/browser/runtime/check_key_length.js", "../../../../../../../app/node_modules/jose/dist/browser/runtime/rsaes.js", "../../../../../../../app/node_modules/jose/dist/browser/lib/cek.js", "../../../../../../../app/node_modules/jose/dist/browser/lib/format_pem.js", "../../../../../../../app/node_modules/jose/dist/browser/runtime/asn1.js", "../../../../../../../app/node_modules/jose/dist/browser/runtime/jwk_to_key.js", "../../../../../../../app/node_modules/jose/dist/browser/key/import.js", "../../../../../../../app/node_modules/jose/dist/browser/lib/check_key_type.js", "../../../../../../../app/node_modules/jose/dist/browser/runtime/encrypt.js", "../../../../../../../app/node_modules/jose/dist/browser/lib/aesgcmkw.js", "../../../../../../../app/node_modules/jose/dist/browser/lib/decrypt_key_management.js", "../../../../../../../app/node_modules/jose/dist/browser/lib/validate_crit.js", "../../../../../../../app/node_modules/jose/dist/browser/lib/validate_algorithms.js", "../../../../../../../app/node_modules/jose/dist/browser/jwe/flattened/decrypt.js", "../../../../../../../app/node_modules/jose/dist/browser/jwe/compact/decrypt.js", "../../../../../../../app/node_modules/jose/dist/browser/jwe/general/decrypt.js", "../../../../../../../app/node_modules/jose/dist/browser/runtime/key_to_jwk.js", "../../../../../../../app/node_modules/jose/dist/browser/key/export.js", "../../../../../../../app/node_modules/jose/dist/browser/lib/encrypt_key_management.js", "../../../../../../../app/node_modules/jose/dist/browser/jwe/flattened/encrypt.js", "../../../../../../../app/node_modules/jose/dist/browser/jwe/general/encrypt.js", "../../../../../../../app/node_modules/jose/dist/browser/runtime/subtle_dsa.js", "../../../../../../../app/node_modules/jose/dist/browser/runtime/get_sign_verify_key.js", "../../../../../../../app/node_modules/jose/dist/browser/runtime/verify.js", "../../../../../../../app/node_modules/jose/dist/browser/jws/flattened/verify.js", "../../../../../../../app/node_modules/jose/dist/browser/jws/compact/verify.js", "../../../../../../../app/node_modules/jose/dist/browser/jws/general/verify.js", "../../../../../../../app/node_modules/jose/dist/browser/lib/epoch.js", "../../../../../../../app/node_modules/jose/dist/browser/lib/secs.js", "../../../../../../../app/node_modules/jose/dist/browser/lib/jwt_claims_set.js", "../../../../../../../app/node_modules/jose/dist/browser/jwt/verify.js", "../../../../../../../app/node_modules/jose/dist/browser/jwt/decrypt.js", "../../../../../../../app/node_modules/jose/dist/browser/jwe/compact/encrypt.js", "../../../../../../../app/node_modules/jose/dist/browser/runtime/sign.js", "../../../../../../../app/node_modules/jose/dist/browser/jws/flattened/sign.js", "../../../../../../../app/node_modules/jose/dist/browser/jws/compact/sign.js", "../../../../../../../app/node_modules/jose/dist/browser/jws/general/sign.js", "../../../../../../../app/node_modules/jose/dist/browser/jwt/produce.js", "../../../../../../../app/node_modules/jose/dist/browser/jwt/sign.js", "../../../../../../../app/node_modules/jose/dist/browser/jwt/encrypt.js", "../../../../../../../app/node_modules/jose/dist/browser/jwk/thumbprint.js", "../../../../../../../app/node_modules/jose/dist/browser/jwk/embedded.js", "../../../../../../../app/node_modules/jose/dist/browser/jwks/local.js", "../../../../../../../app/node_modules/jose/dist/browser/runtime/fetch_jwks.js", "../../../../../../../app/node_modules/jose/dist/browser/jwks/remote.js", "../../../../../../../app/node_modules/jose/dist/browser/jwt/unsecured.js", "../../../../../../../app/node_modules/jose/dist/browser/util/base64url.js", "../../../../../../../app/node_modules/jose/dist/browser/util/decode_protected_header.js", "../../../../../../../app/node_modules/jose/dist/browser/util/decode_jwt.js", "../../../../../../../app/node_modules/jose/dist/browser/runtime/generate.js", "../../../../../../../app/node_modules/jose/dist/browser/key/generate_key_pair.js", "../../../../../../../app/node_modules/jose/dist/browser/key/generate_secret.js", "../../../../../../../app/node_modules/jose/dist/browser/index.js", "../../../../../../../app/packages/runtime/src/utils/retry.ts", "../../../../../../../app/packages/runtime/src/utils/gcp.ts", "../../../../../../../app/packages/runtime/src/logging/v1/transports/google-transport.ts", "../../../../../../../app/packages/runtime/src/logging/v1/gcp-log-format.ts", "../../../../../../../app/packages/runtime/src/logging/v1/transports/console-transport.ts", "../../../../../../../app/packages/runtime/src/logging/v1/transports/data-dog-transport.ts", "../../../../../../../app/packages/runtime/src/logging/v1/transports/process-transport.ts", "../../../../../../../app/packages/runtime/src/logging/v1/transports/remote-log-transport.ts", "../../../../../../../app/packages/runtime/src/logging/v1/unified-logging/formatter.ts", "../../../../../../../app/packages/runtime/src/logging/v1/unified-logging/transport.ts", "../../../../../../../app/packages/runtime/src/logging/v1/log-initializer.ts", "../../../../../../../app/packages/runtime/src/router/user-route-configuration.ts", "../../../../../../../app/packages/runtime/src/router/router.ts", "../../../../../../../app/packages/runtime/src/utils/global-zuplo-event-context.ts", "../../../../../../../app/packages/runtime/src/utils/normalize-headers.ts", "../../../../../../../app/packages/runtime/src/gateway.ts", "../../../../../../../app/packages/runtime/src/invoke-policy.ts", "../../../../../../../app/packages/runtime/src/context.ts", "../../../../../../../app/packages/runtime/src/context-data.ts", "../../../../../../../app/packages/runtime/src/environment.ts", "../../../../../../../app/packages/core/polyfills/async_hooks.js", "../../../../../../../app/packages/runtime/src/stores.ts", "../../../../../../../app/packages/runtime/src/handler.ts", "../../../../../../../app/node_modules/path-to-regexp/src/index.ts", "../../../../../../../app/packages/runtime/src/utils/aws.ts", "../../../../../../../app/packages/runtime/src/utils/base64.ts", "../../../../../../../app/packages/runtime/src/utils/clf-date.ts", "../../../../../../../app/packages/runtime/src/handlers/aws-lambda.ts", "../../../../../../../app/packages/runtime/src/handlers/util.ts", "../../../../../../../app/packages/runtime/src/handlers/open-api.ts", "../../../../../../../app/packages/runtime/src/handlers/redirect.ts", "../../../../../../../app/packages/runtime/src/handlers/url-forward.ts", "../../../../../../../app/packages/runtime/src/handlers/url-rewrite.ts", "../../../../../../../app/packages/runtime/src/handlers/websocket-handler.ts", "../../../../../../../app/packages/runtime/src/handlers/websocket-policy-processor.ts", "../../../../../../../app/packages/runtime/src/handlers/websocket-pipeline-handler.ts", "../../../../../../../app/packages/runtime/src/logging/v1/transports/dynatrace-transport.ts", "../../../../../../../app/packages/runtime/src/logging/v1/transports/loki-transport.ts", "../../../../../../../app/packages/runtime/src/logging/v1/transports/sumologic-transport.ts", "../../../../../../../app/packages/runtime/src/logging/v1/transports/vmware-log-insight-transport.ts", "../../../../../../../app/packages/runtime/src/logging/v1/transports/aws-transport.ts", "../../../../../../../app/packages/runtime/src/logging/v1/transports/plugins.ts", "../../../../../../../app/packages/runtime/src/metrics/v1/transports/data-dog-metrics.ts", "../../../../../../../app/packages/runtime/src/metrics/v1/transports/dynatrace-metrics.ts", "../../../../../../../app/packages/runtime/src/metrics/v1/transports/plugins.ts", "../../../../../../../app/packages/runtime/src/plugins/audit-log-output-providers/audit-log-datastax-provider.ts", "../../../../../../../app/packages/runtime/src/plugins/audit-log-plugin.ts", "../../../../../../../app/packages/runtime/src/utils/stripe/error.ts", "../../../../../../../app/packages/runtime/src/utils/stripe/webhook.ts", "../../../../../../../app/packages/runtime/src/utils/validator.ts", "../../../../../../../app/packages/runtime/src/policies/stripe-webhook-verification-inbound/policy.ts", "../../../../../../../app/packages/runtime/src/utils/stripe/types.ts", "../../../../../../../app/packages/runtime/src/utils/stripe/api.ts", "../../../../../../../app/packages/runtime/src/plugins/stripe-event-handlers/apikey-mgmt-service-operations.ts", "../../../../../../../app/packages/runtime/src/plugins/stripe-event-handlers/metering-service-operations.ts", "../../../../../../../app/packages/runtime/src/plugins/stripe-event-handlers/utils.ts", "../../../../../../../app/packages/runtime/src/plugins/stripe-event-handlers/customer-subscription-created-handler.ts", "../../../../../../../app/packages/runtime/src/plugins/stripe-event-handlers/customer-subscription-deleted-handler.ts", "../../../../../../../app/packages/runtime/src/plugins/stripe-event-handlers/customer-subscription-updated-handler.ts", "../../../../../../../app/packages/runtime/src/plugins/stripe-monetization-plugin.ts", "../../../../../../../app/packages/runtime/src/policies/amberflo-metering-inbound/policy.ts", "../../../../../../../app/packages/runtime/src/utils/crypto.ts", "../../../../../../../app/packages/runtime/src/caches/keys.ts", "../../../../../../../app/packages/runtime/src/policies/api-key-inbound/policy.ts", "../../../../../../../app/packages/runtime/src/policies/api-key-auth-inbound/policy.ts", "../../../../../../../app/packages/runtime/src/policies/open-id-jwt-auth-inbound/jwks.ts", "../../../../../../../app/packages/runtime/src/policies/open-id-jwt-auth-inbound/policy.ts", "../../../../../../../app/packages/runtime/src/policies/auth0-jwt-auth-inbound/policy.ts", "../../../../../../../app/packages/runtime/src/policies/basic-auth-inbound/policy.ts", "../../../../../../../app/packages/runtime/src/policies/caching-inbound/policy.ts", "../../../../../../../app/packages/runtime/src/policies/change-method-inbound/policy.ts", "../../../../../../../app/packages/runtime/src/policies/clear-headers-inbound/policy.ts", "../../../../../../../app/packages/runtime/src/policies/clear-headers-outbound/policy.ts", "../../../../../../../app/packages/runtime/src/policies/clerk-jwt-auth-inbound/policy.ts", "../../../../../../../app/packages/runtime/src/policies/cognito-jwt-auth-inbound/policy.ts", "../../../../../../../app/packages/runtime/src/policies/composite-inbound/policy.ts", "../../../../../../../app/packages/runtime/src/policies/curity-phantom-token-inbound/policy.ts", "../../../../../../../app/packages/runtime/src/policies/firebase-jwt-inbound/policy.ts", "../../../../../../../app/packages/runtime/src/policies/formdata-to-json-inbound/policy.ts", "../../../../../../../app/packages/runtime/src/policies/geo-filter-inbound/policy.ts", "../../../../../../../app/packages/runtime/src/policies/jwt-scopes-inbound/policy.ts", "../../../../../../../app/packages/runtime/src/policies/mock-api-inbound/policy.ts", "../../../../../../../app/packages/runtime/src/policies/moesif-inbound/policy.ts", "../../../../../../../app/packages/runtime/src/policies/monetization-inbound/metering-utils.ts", "../../../../../../../app/packages/runtime/src/policies/monetization-inbound/validation-utils.ts", "../../../../../../../app/packages/runtime/src/policies/monetization-inbound/policy.ts", "../../../../../../../app/packages/runtime/src/policies/okta-jwt-auth-inbound/policy.ts", "../../../../../../../app/packages/runtime/src/policies/propel-auth-jwt-inbound/policy.ts", "../../../../../../../app/packages/runtime/src/utils/errors.ts", "../../../../../../../app/packages/runtime/src/utils/redis-rest-client.ts", "../../../../../../../app/packages/runtime/src/policies/rate-limit-inbound/common.ts", "../../../../../../../app/packages/runtime/src/policies/rate-limit-inbound/async.ts", "../../../../../../../app/packages/runtime/src/policies/rate-limit-inbound/policy.ts", "../../../../../../../app/packages/runtime/src/policies/readme-metrics-inbound/policy.ts", "../../../../../../../app/packages/runtime/src/policies/remove-headers-inbound/policy.ts", "../../../../../../../app/packages/runtime/src/policies/remove-headers-outbound/policy.ts", "../../../../../../../app/packages/runtime/src/policies/remove-query-params-inbound/policy.ts", "../../../../../../../app/packages/runtime/src/policies/replace-string-outbound/policy.ts", "../../../../../../../app/packages/runtime/src/policies/request-size-limit-inbound/policy.ts", "../../../../../../../app/packages/runtime/src/utils/open-api-utils.ts", "../../../../../../../app/packages/runtime/src/utils/request-validation/common.ts", "../../../../../../../app/packages/runtime/src/utils/request-validation/body.ts", "../../../../../../../app/packages/runtime/src/utils/request-validation/headers.ts", "../../../../../../../app/packages/runtime/src/utils/request-validation/path-parameters.ts", "../../../../../../../app/packages/runtime/src/utils/request-validation/query-parameters.ts", "../../../../../../../app/packages/runtime/src/policies/request-validation-inbound/policy.ts", "../../../../../../../app/packages/runtime/src/policies/require-origin-inbound/policy.ts", "../../../../../../../app/packages/runtime/src/policies/set-body-inbound/policy.ts", "../../../../../../../app/packages/runtime/src/policies/set-headers-inbound/policy.ts", "../../../../../../../app/packages/runtime/src/policies/set-headers-outbound/policy.ts", "../../../../../../../app/packages/runtime/src/policies/set-query-params-inbound/policy.ts", "../../../../../../../app/packages/runtime/src/policies/set-status-outbound/policy.ts", "../../../../../../../app/packages/runtime/src/policies/sleep-inbound/policy.ts", "../../../../../../../app/packages/runtime/src/policies/supabase-jwt-auth-inbound/policy.ts", "../../../../../../../app/packages/runtime/src/policies/upstream-azure-ad-service-auth-inbound/policy.ts", "../../../../../../../app/packages/runtime/src/policies/upstream-firebase-admin-auth-inbound/policy.ts", "../../../../../../../app/packages/runtime/src/policies/upstream-firebase-user-auth-inbound/policy.ts", "../../../../../../../app/packages/runtime/src/policies/upstream-gcp-jwt-inbound/policy.ts", "../../../../../../../app/packages/runtime/src/policies/upstream-gcp-service-auth-inbound/policy.ts", "../../../../../../../app/packages/runtime/src/policies/validate-json-schema-inbound/policy.ts", "../../../../../../../app/packages/runtime/src/third-party/fast-xml-parser/index.js", "../../../../../../../app/packages/runtime/src/policies/xml-to-json-outbound/policy.ts", "../../../../../../../app/packages/runtime/src/service-provider.ts", "../../../../../../../app/packages/runtime/src/utils/background-dispatcher.ts", "../../../../../../../app/packages/runtime/src/utils/background-loader.ts", "../../../../../../../app/packages/runtime/src/index.ts", "../../../../../../../app/packages/runtime/src/crypto-beta.ts", "../../../../../../../app/packages/runtime/src/platforms/worker/crypto-beta.ts", "../../../../../../../app/packages/runtime/src/key-value-store.ts", "../../../../../../../app/packages/runtime/src/platforms/worker/key-value-store.ts", "../../../../../../../app/packages/runtime/src/index.worker.ts", "schema-validation:./ajv-schema.json", "dev-portal-json:/usr/dev/projects/34b31b7e6a57d29ac5a7ed89e1241794a9531eb1/sapphire_fluffy_amphibian/sagentzuplo/config/dev-portal.json", "../.zuplo/worker.ts", "open-api-routes-json:/usr/dev/projects/34b31b7e6a57d29ac5a7ed89e1241794a9531eb1/sapphire_fluffy_amphibian/sagentzuplo/config/routes.json", "raw-route:./raw.json", "runtime-config-plugin:/usr/dev/projects/34b31b7e6a57d29ac5a7ed89e1241794a9531eb1/sapphire_fluffy_amphibian/sagentzuplo/modules/zuplo.runtime.ts", "../.zuplo/build.json"],
  "sourcesContent": ["// Copyright 2018-2020 the Deno authors. All rights reserved. MIT license.\n/** A module to print ANSI terminal colors. Inspired by chalk, kleur, and colors\n * on npm.\n *\n * ```\n * import { bgBlue, red, bold } from \"https://deno.land/std/fmt/colors.ts\";\n * console.log(bgBlue(red(bold(\"Hello world!\"))));\n * ```\n *\n * This module supports `NO_COLOR` environmental variable disabling any coloring\n * if `NO_COLOR` is set.\n *\n * This module is browser compatible. */\n\nconst noColor = true;\n\ninterface Code {\n  open: string;\n  close: string;\n  regexp: RegExp;\n}\n\n/** RGB 8-bits per channel. Each in range `0->255` or `0x00->0xff` */\ninterface Rgb {\n  r: number;\n  g: number;\n  b: number;\n}\n\nlet enabled = !noColor;\n\nexport function setColorEnabled(value: boolean): void {\n  if (noColor) {\n    return;\n  }\n\n  enabled = value;\n}\n\nexport function getColorEnabled(): boolean {\n  return enabled;\n}\n\nfunction code(open: number[], close: number): Code {\n  return {\n    open: `\\x1b[${open.join(\";\")}m`,\n    close: `\\x1b[${close}m`,\n    regexp: new RegExp(`\\\\x1b\\\\[${close}m`, \"g\"),\n  };\n}\n\nfunction run(str: string, code: Code): string {\n  return enabled\n    ? `${code.open}${str.replace(code.regexp, code.open)}${code.close}`\n    : str;\n}\n\nexport function reset(str: string): string {\n  return run(str, code([0], 0));\n}\n\nexport function bold(str: string): string {\n  return run(str, code([1], 22));\n}\n\nexport function dim(str: string): string {\n  return run(str, code([2], 22));\n}\n\nexport function italic(str: string): string {\n  return run(str, code([3], 23));\n}\n\nexport function underline(str: string): string {\n  return run(str, code([4], 24));\n}\n\nexport function inverse(str: string): string {\n  return run(str, code([7], 27));\n}\n\nexport function hidden(str: string): string {\n  return run(str, code([8], 28));\n}\n\nexport function strikethrough(str: string): string {\n  return run(str, code([9], 29));\n}\n\nexport function black(str: string): string {\n  return run(str, code([30], 39));\n}\n\nexport function red(str: string): string {\n  return run(str, code([31], 39));\n}\n\nexport function green(str: string): string {\n  return run(str, code([32], 39));\n}\n\nexport function yellow(str: string): string {\n  return run(str, code([33], 39));\n}\n\nexport function blue(str: string): string {\n  return run(str, code([34], 39));\n}\n\nexport function magenta(str: string): string {\n  return run(str, code([35], 39));\n}\n\nexport function cyan(str: string): string {\n  return run(str, code([36], 39));\n}\n\nexport function white(str: string): string {\n  return run(str, code([37], 39));\n}\n\nexport function gray(str: string): string {\n  return brightBlack(str);\n}\n\nexport function brightBlack(str: string): string {\n  return run(str, code([90], 39));\n}\n\nexport function brightRed(str: string): string {\n  return run(str, code([91], 39));\n}\n\nexport function brightGreen(str: string): string {\n  return run(str, code([92], 39));\n}\n\nexport function brightYellow(str: string): string {\n  return run(str, code([93], 39));\n}\n\nexport function brightBlue(str: string): string {\n  return run(str, code([94], 39));\n}\n\nexport function brightMagenta(str: string): string {\n  return run(str, code([95], 39));\n}\n\nexport function brightCyan(str: string): string {\n  return run(str, code([96], 39));\n}\n\nexport function brightWhite(str: string): string {\n  return run(str, code([97], 39));\n}\n\nexport function bgBlack(str: string): string {\n  return run(str, code([40], 49));\n}\n\nexport function bgRed(str: string): string {\n  return run(str, code([41], 49));\n}\n\nexport function bgGreen(str: string): string {\n  return run(str, code([42], 49));\n}\n\nexport function bgYellow(str: string): string {\n  return run(str, code([43], 49));\n}\n\nexport function bgBlue(str: string): string {\n  return run(str, code([44], 49));\n}\n\nexport function bgMagenta(str: string): string {\n  return run(str, code([45], 49));\n}\n\nexport function bgCyan(str: string): string {\n  return run(str, code([46], 49));\n}\n\nexport function bgWhite(str: string): string {\n  return run(str, code([47], 49));\n}\n\nexport function bgBrightBlack(str: string): string {\n  return run(str, code([100], 49));\n}\n\nexport function bgBrightRed(str: string): string {\n  return run(str, code([101], 49));\n}\n\nexport function bgBrightGreen(str: string): string {\n  return run(str, code([102], 49));\n}\n\nexport function bgBrightYellow(str: string): string {\n  return run(str, code([103], 49));\n}\n\nexport function bgBrightBlue(str: string): string {\n  return run(str, code([104], 49));\n}\n\nexport function bgBrightMagenta(str: string): string {\n  return run(str, code([105], 49));\n}\n\nexport function bgBrightCyan(str: string): string {\n  return run(str, code([106], 49));\n}\n\nexport function bgBrightWhite(str: string): string {\n  return run(str, code([107], 49));\n}\n\n/* Special Color Sequences */\n\nfunction clampAndTruncate(n: number, max = 255, min = 0): number {\n  return Math.trunc(Math.max(Math.min(n, max), min));\n}\n\n/** Set text color using paletted 8bit colors.\n * https://en.wikipedia.org/wiki/ANSI_escape_code#8-bit */\nexport function rgb8(str: string, color: number): string {\n  return run(str, code([38, 5, clampAndTruncate(color)], 39));\n}\n\n/** Set background color using paletted 8bit colors.\n * https://en.wikipedia.org/wiki/ANSI_escape_code#8-bit */\nexport function bgRgb8(str: string, color: number): string {\n  return run(str, code([48, 5, clampAndTruncate(color)], 49));\n}\n\n/** Set text color using 24bit rgb.\n * `color` can be a number in range `0x000000` to `0xffffff` or\n * an `Rgb`.\n *\n * To produce the color magenta:\n *\n *      rgba24(\"foo\", 0xff00ff);\n *      rgba24(\"foo\", {r: 255, g: 0, b: 255});\n */\nexport function rgb24(str: string, color: number | Rgb): string {\n  if (typeof color === \"number\") {\n    return run(\n      str,\n      code([38, 2, (color >> 16) & 0xff, (color >> 8) & 0xff, color & 0xff], 39)\n    );\n  }\n  return run(\n    str,\n    code(\n      [\n        38,\n        2,\n        clampAndTruncate(color.r),\n        clampAndTruncate(color.g),\n        clampAndTruncate(color.b),\n      ],\n      39\n    )\n  );\n}\n\n/** Set background color using 24bit rgb.\n * `color` can be a number in range `0x000000` to `0xffffff` or\n * an `Rgb`.\n *\n * To produce the color magenta:\n *\n *      bgRgba24(\"foo\", 0xff00ff);\n *      bgRgba24(\"foo\", {r: 255, g: 0, b: 255});\n */\nexport function bgRgb24(str: string, color: number | Rgb): string {\n  if (typeof color === \"number\") {\n    return run(\n      str,\n      code([48, 2, (color >> 16) & 0xff, (color >> 8) & 0xff, color & 0xff], 49)\n    );\n  }\n  return run(\n    str,\n    code(\n      [\n        48,\n        2,\n        clampAndTruncate(color.r),\n        clampAndTruncate(color.g),\n        clampAndTruncate(color.b),\n      ],\n      49\n    )\n  );\n}\n\n// https://github.com/chalk/ansi-regex/blob/2b56fb0c7a07108e5b54241e8faec160d393aedb/index.js\nconst ANSI_PATTERN = new RegExp(\n  [\n    \"[\\\\u001B\\\\u009B][[\\\\]()#;?]*(?:(?:(?:[a-zA-Z\\\\d]*(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]*)*)?\\\\u0007)\",\n    \"(?:(?:\\\\d{1,4}(?:;\\\\d{0,4})*)?[\\\\dA-PR-TZcf-ntqry=><~]))\",\n  ].join(\"|\"),\n  \"g\"\n);\n\nexport function stripColor(string: string): string {\n  return string.replace(ANSI_PATTERN, \"\");\n}\n\nexport type ColorFunction = (message: string) => string;\nexport const colorFunctions: ColorFunction[] = [\n  red,\n  green,\n  yellow,\n  blue,\n  magenta,\n  cyan,\n];\n\nfunction hashCode(s: string): number {\n  let h = 0;\n  const l = s.length;\n  let i = 0;\n  if (l > 0) while (i < l) h = ((h << 5) - h + s.charCodeAt(i++)) | 0;\n  return h;\n}\n\nexport function generateColor(message: string): ColorFunction {\n  const hash = Math.abs(hashCode(message));\n  return colorFunctions[hash % colorFunctions.length];\n}\n", "export type InspectFunction = (\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  object: any,\n  showHidden?: boolean | undefined,\n  depth?: number | null | undefined,\n  color?: boolean | undefined\n) => string;\n\nexport function format(\n  inspect: InspectFunction,\n  f: string,\n  ...args: unknown[]\n) {\n  let i = 0;\n  const len = args.length;\n  let str = String(f).replace(/%[sdjoO%]/g, (x: string): string => {\n    if (x === \"%%\") return \"%\";\n    if (i >= len) return x;\n    switch (x) {\n      case \"%s\":\n        return String(args[i++]);\n      case \"%d\":\n        return Number(args[i++]).toString();\n      case \"%o\":\n        return inspect(args[i++])\n          .split(\"\\n\")\n          .map((_) => _.trim())\n          .join(\" \");\n      case \"%O\":\n        return inspect(args[i++]);\n      case \"%j\":\n        try {\n          return JSON.stringify(args[i++]);\n        } catch {\n          return \"[Circular]\";\n        }\n      default:\n        return x;\n    }\n  });\n  for (const x of args.splice(i)) {\n    if (x === null || !(typeof x === \"object\" && x !== null)) {\n      str += \" \" + x;\n    } else {\n      str += \" \" + inspect(x);\n    }\n  }\n  return str;\n}\n", "/* eslint-disable @typescript-eslint/no-unused-vars */\n/* eslint-disable @typescript-eslint/ban-ts-comment */\n/* eslint-disable @typescript-eslint/no-explicit-any */\n// MIT \u2013 Copyright (c) 2010-2014 Joyent, Inc.\n// Source: https://github.com/deecewan/browser-util-inspect\n\n/**\n * Echos the value of a value. Trys to print the value out\n * in the best way possible given the different types.\n *\n * @param {Object} obj The object to print out.\n * @param {boolean} showHidden\n * @param {number} depth\n * @param {boolean} colors\n * @license MIT (\u00A9 Joyent)\n */\nexport function inspect(\n  obj: any,\n  showHidden?: boolean | undefined,\n  depth?: number | null | undefined,\n  color?: boolean | undefined\n): string {\n  // default options\n  const ctx: any = {\n    seen: [],\n    stylize: stylizeNoColor,\n    showHidden: showHidden ?? false,\n    depth: depth ?? 2,\n    colors: color ?? false,\n    customInspect: true,\n  };\n\n  if (ctx.colors) ctx.stylize = stylizeWithColor;\n  return formatValue(ctx, obj, ctx.depth);\n}\n\n// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\ninspect.colors = {\n  bold: [1, 22],\n  italic: [3, 23],\n  underline: [4, 24],\n  inverse: [7, 27],\n  white: [37, 39],\n  grey: [90, 39],\n  black: [30, 39],\n  blue: [34, 39],\n  cyan: [36, 39],\n  green: [32, 39],\n  magenta: [35, 39],\n  red: [31, 39],\n  yellow: [33, 39],\n};\n\n// Don't use 'blue' not visible on cmd.exe\ninspect.styles = {\n  special: \"cyan\",\n  number: \"yellow\",\n  boolean: \"yellow\",\n  undefined: \"grey\",\n  null: \"bold\",\n  string: \"green\",\n  date: \"magenta\",\n  // \"name\": intentionally not styling\n  regexp: \"red\",\n};\n\nfunction stylizeNoColor(str: any, styleType: any) {\n  return str;\n}\n\nfunction isBoolean(arg: any) {\n  return typeof arg === \"boolean\";\n}\n\nfunction isUndefined(arg: any) {\n  return arg === void 0;\n}\n\nfunction stylizeWithColor(str: string, styleType: any) {\n  // @ts-expect-error\n  const style = inspect.styles[styleType];\n\n  if (style) {\n    return (\n      \"\\u001b[\" +\n      // @ts-expect-error\n      inspect.colors[style][0] +\n      \"m\" +\n      str +\n      \"\\u001b[\" +\n      // @ts-expect-error\n      inspect.colors[style][1] +\n      \"m\"\n    );\n  } else {\n    return str;\n  }\n}\n\nfunction isFunction(arg: any) {\n  return typeof arg === \"function\";\n}\n\nfunction isString(arg: any) {\n  return typeof arg === \"string\";\n}\n\nfunction isNumber(arg: any) {\n  return typeof arg === \"number\";\n}\n\nfunction isNull(arg: any) {\n  return arg === null;\n}\n\nfunction hasOwn(obj: any, prop: any) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nfunction isRegExp(re: any) {\n  return isObject(re) && objectToString(re) === \"[object RegExp]\";\n}\n\nfunction isObject(arg: any) {\n  return typeof arg === \"object\" && arg !== null;\n}\n\nfunction isError(e: any) {\n  return (\n    isObject(e) &&\n    (objectToString(e) === \"[object Error]\" || e instanceof Error)\n  );\n}\n\nfunction isDate(d: any) {\n  return isObject(d) && objectToString(d) === \"[object Date]\";\n}\n\nfunction objectToString(o: any) {\n  return Object.prototype.toString.call(o);\n}\n\nfunction arrayToHash(array: any) {\n  const hash = {};\n\n  array.forEach(function (val: any, idx: any) {\n    // @ts-expect-error\n    hash[val] = true;\n  });\n\n  return hash;\n}\n\nfunction formatArray(\n  ctx: any,\n  value: any,\n  recurseTimes: any,\n  visibleKeys: any,\n  keys: any\n): any {\n  const output = [];\n  for (let i = 0, l = value.length; i < l; ++i) {\n    if (hasOwn(value, String(i))) {\n      output.push(\n        formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true)\n      );\n    } else {\n      output.push(\"\");\n    }\n  }\n  keys.forEach(function (key: any) {\n    if (!key.match(/^\\d+$/)) {\n      output.push(\n        formatProperty(ctx, value, recurseTimes, visibleKeys, key, true)\n      );\n    }\n  });\n  return output;\n}\n\nfunction formatError(value: any) {\n  return \"[\" + Error.prototype.toString.call(value) + \"]\";\n}\n\nfunction formatValue(ctx: any, value: any, recurseTimes: any): any {\n  // Provide a hook for user-specified inspect functions.\n  // Check that value is an object with an inspect function on it\n  if (\n    ctx.customInspect &&\n    value &&\n    isFunction(value.inspect) &&\n    // Filter out the util module, it's inspect function is special\n    value.inspect !== inspect &&\n    // Also filter out any prototype objects using the circular check.\n    !(value.constructor && value.constructor.prototype === value)\n  ) {\n    let ret = value.inspect(recurseTimes, ctx);\n    if (!isString(ret)) {\n      ret = formatValue(ctx, ret, recurseTimes);\n    }\n    return ret;\n  }\n\n  // Primitive types cannot have properties\n  const primitive = formatPrimitive(ctx, value);\n  if (primitive) {\n    return primitive;\n  }\n\n  // Look up the keys of the object.\n  let keys = Object.keys(value);\n  const visibleKeys = arrayToHash(keys);\n\n  try {\n    if (ctx.showHidden && Object.getOwnPropertyNames) {\n      keys = Object.getOwnPropertyNames(value);\n    }\n  } catch (e) {\n    // ignore\n  }\n\n  // IE doesn't make error fields non-enumerable\n  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx\n  if (\n    isError(value) &&\n    (keys.indexOf(\"message\") >= 0 || keys.indexOf(\"description\") >= 0)\n  ) {\n    return formatError(value);\n  }\n\n  // Some type of object without properties can be shortcutted.\n  if (keys.length === 0) {\n    if (isFunction(value)) {\n      const name = value.name ? \": \" + value.name : \"\";\n      return ctx.stylize(\"[Function\" + name + \"]\", \"special\");\n    }\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), \"regexp\");\n    }\n    if (isDate(value)) {\n      return ctx.stylize(Date.prototype.toString.call(value), \"date\");\n    }\n    if (isError(value)) {\n      return formatError(value);\n    }\n  }\n\n  let base = \"\",\n    array = false,\n    braces = [\"{\", \"}\"];\n\n  // Make Array say that they are Array\n  if (Array.isArray(value)) {\n    array = true;\n    braces = [\"[\", \"]\"];\n  }\n\n  // Make functions say that they are functions\n  if (isFunction(value)) {\n    const n = value.name ? \": \" + value.name : \"\";\n    base = \" [Function\" + n + \"]\";\n  }\n\n  // Make RegExps say that they are RegExps\n  if (isRegExp(value)) {\n    base = \" \" + RegExp.prototype.toString.call(value);\n  }\n\n  // Make dates with properties first say the date\n  if (isDate(value)) {\n    base = \" \" + Date.prototype.toUTCString.call(value);\n  }\n\n  // Make error with message first say the error\n  if (isError(value)) {\n    base = \" \" + formatError(value);\n  }\n\n  if (keys.length === 0 && (!array || value.length == 0)) {\n    return braces[0] + base + braces[1];\n  }\n\n  if (recurseTimes < 0) {\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), \"regexp\");\n    } else {\n      return ctx.stylize(\"[Object]\", \"special\");\n    }\n  }\n\n  ctx.seen.push(value);\n\n  let output;\n  if (array) {\n    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n  } else {\n    output = keys.map(function (key) {\n      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n    });\n  }\n\n  ctx.seen.pop();\n\n  return reduceToSingleString(output, base, braces);\n}\n\nfunction formatProperty(\n  ctx: any,\n  value: any,\n  recurseTimes: any,\n  visibleKeys: any,\n  key: any,\n  array: any\n) {\n  let name, str, desc;\n  desc = { value: void 0 };\n  try {\n    // ie6 \u203A navigator.toString\n    // throws Error: Object doesn't support this property or method\n    desc.value = value[key];\n  } catch (e) {\n    // ignore\n  }\n  try {\n    // ie10 \u203A Object.getOwnPropertyDescriptor(window.location, 'hash')\n    // throws TypeError: Object doesn't support this action\n    if (Object.getOwnPropertyDescriptor) {\n      desc = Object.getOwnPropertyDescriptor(value, key) || desc;\n    }\n  } catch (e) {\n    // ignore\n  }\n  if (desc.get) {\n    if (desc.set) {\n      str = ctx.stylize(\"[Getter/Setter]\", \"special\");\n    } else {\n      str = ctx.stylize(\"[Getter]\", \"special\");\n    }\n  } else {\n    if (desc.set) {\n      str = ctx.stylize(\"[Setter]\", \"special\");\n    }\n  }\n  if (!hasOwn(visibleKeys, key)) {\n    name = \"[\" + key + \"]\";\n  }\n  if (!str) {\n    if (ctx.seen.indexOf(desc.value) < 0) {\n      if (isNull(recurseTimes)) {\n        str = formatValue(ctx, desc.value, null);\n      } else {\n        str = formatValue(ctx, desc.value, recurseTimes - 1);\n      }\n      if (str.indexOf(\"\\n\") > -1) {\n        if (array) {\n          str = str\n            .split(\"\\n\")\n            .map(function (line: any) {\n              return \"  \" + line;\n            })\n            .join(\"\\n\")\n            .substr(2);\n        } else {\n          str =\n            \"\\n\" +\n            str\n              .split(\"\\n\")\n              .map(function (line: any) {\n                return \"   \" + line;\n              })\n              .join(\"\\n\");\n        }\n      }\n    } else {\n      str = ctx.stylize(\"[Circular]\", \"special\");\n    }\n  }\n  if (isUndefined(name)) {\n    if (array && key.match(/^\\d+$/)) {\n      return str;\n    }\n    name = JSON.stringify(\"\" + key);\n    if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n      name = name.substr(1, name.length - 2);\n      name = ctx.stylize(name, \"name\");\n    } else {\n      name = name\n        .replace(/'/g, \"\\\\'\")\n        .replace(/\\\\\"/g, '\"')\n        .replace(/(^\"|\"$)/g, \"'\");\n      name = ctx.stylize(name, \"string\");\n    }\n  }\n\n  return name + \": \" + str;\n}\n\nfunction formatPrimitive(ctx: any, value: any) {\n  if (isUndefined(value)) return ctx.stylize(\"undefined\", \"undefined\");\n  if (isString(value)) {\n    const simple =\n      \"'\" +\n      JSON.stringify(value)\n        .replace(/^\"|\"$/g, \"\")\n        .replace(/'/g, \"\\\\'\")\n        .replace(/\\\\\"/g, '\"') +\n      \"'\";\n    return ctx.stylize(simple, \"string\");\n  }\n  if (isNumber(value)) return ctx.stylize(\"\" + value, \"number\");\n  if (isBoolean(value)) return ctx.stylize(\"\" + value, \"boolean\");\n  // For some reason typeof null is \"object\", so special case here.\n  if (isNull(value)) return ctx.stylize(\"null\", \"null\");\n}\n\nfunction reduceToSingleString(output: any, base: any, braces: any) {\n  let numLinesEst = 0;\n  const length = output.reduce(function (prev: any, cur: any) {\n    numLinesEst++;\n    if (cur.indexOf(\"\\n\") >= 0) numLinesEst++;\n    // eslint-disable-next-line no-control-regex\n    return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, \"\").length + 1;\n  }, 0);\n\n  if (length > 60) {\n    return (\n      braces[0] +\n      (base === \"\" ? \"\" : base + \"\\n \") +\n      \" \" +\n      output.join(\",\\n  \") +\n      \" \" +\n      braces[1]\n    );\n  }\n\n  return braces[0] + base + \" \" + output.join(\", \") + \" \" + braces[1];\n}\n", "// eslint-disable-next-line import/no-nodejs-modules\nimport { format as commonFormat } from \"../format\";\nimport { inspect } from \"./inspect\";\n\nconst format = (f: string, ...args: unknown[]) =>\n  commonFormat(inspect, f, args);\n\nexport { format };\n", "import { ColorFunction, generateColor } from \"../colors\";\nimport { format } from \"./format\";\n\nexport interface Debug {\n  (fmt: string, ...args: unknown[]): void;\n  (fn: () => string): void;\n  self: Debugger;\n}\n\nexport class Debugger {\n  manager: DebugManager;\n  ns: string;\n  color: ColorFunction;\n  last: number;\n  enabled: boolean;\n\n  constructor(manager: DebugManager, namespace: string) {\n    this.manager = manager;\n    this.ns = namespace;\n    this.color = generateColor(namespace);\n    this.last = 0;\n    this.enabled = manager.enabled.some((r) => r.test(namespace));\n  }\n\n  log(fn: () => string): void;\n  log(fmt: string, ...args: unknown[]): void;\n  log(...args: unknown[]): void {\n    if (!this.enabled) return;\n    let fmt: string;\n    const firstArg = args[0];\n    if (typeof firstArg === \"function\") {\n      fmt = firstArg();\n    } else {\n      fmt = String(firstArg);\n    }\n    const diff = Date.now() - (this.last || Date.now());\n    fmt = format(fmt, ...args);\n    const msg = `${this.color(this.ns)} ${fmt} ${this.color(`+${diff}ms`)}`;\n    // eslint-disable-next-line no-console\n    console.log(msg);\n    this.last = Date.now();\n  }\n}\n\nclass DebugManager {\n  debuggers: Map<string, Debugger>;\n  enabled: RegExp[];\n\n  constructor(enabled?: RegExp[]) {\n    this.debuggers = new Map();\n    this.enabled = enabled ?? [];\n  }\n}\n\nfunction extract(opts?: string): RegExp[] {\n  if (!opts || opts.length === 0) return [];\n  opts = opts.replace(/\\s/g, \"\").replace(/\\*/g, \".+\");\n  return opts.split(\",\").map((rule) => new RegExp(`^${rule}$`));\n}\n\nlet manager: DebugManager;\n\nexport function withoutEnv(enabled?: RegExp[] | string) {\n  if (!enabled) enabled = [];\n  if (typeof enabled === \"string\") enabled = extract(enabled);\n  manager = new DebugManager(enabled);\n}\n\nexport function debug(namespace: string): Debug {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const envVar = (globalThis as any).DEBUG;\n  if (!manager) manager = new DebugManager(extract(envVar));\n\n  const dbg = new Debugger(manager, namespace);\n  manager.debuggers.set(namespace, dbg);\n  const de: Debug = Object.assign(dbg.log.bind(dbg), {\n    self: dbg,\n  });\n  return de;\n}\n", "/**\n * System errors are generally fatal Zuplo errors that should never happen\n * These errors are logged in system logs and cause monitoring alerts\n */\nexport class SystemError extends Error {\n  constructor(message: string, options?: ErrorOptions) {\n    super(message, options);\n    this.name = \"InternalError\";\n  }\n}\n\n/**\n * Used to indicate errors that are caused by user input\n * These errors are shown to the user and logged in user logs\n * These errors are NOT fatal and will not cause monitoring alerts\n * @public\n */\nexport class RuntimeError extends Error {\n  extensionMembers: Record<string, unknown> | undefined;\n\n  constructor(message: string, options?: ErrorOptions);\n  constructor(\n    info: {\n      message: string;\n      extensionMembers?: Record<string, unknown>;\n    },\n    options?: ErrorOptions\n  );\n  constructor(\n    problem:\n      | string\n      | {\n          message: string;\n          extensionMembers?: Record<string, unknown>;\n        },\n    options?: ErrorOptions\n  ) {\n    if (typeof problem === \"string\") {\n      super(problem, options);\n    } else {\n      super(problem.message, options);\n      this.extensionMembers = problem.extensionMembers;\n    }\n    this.name = \"RuntimeError\";\n  }\n}\n\n/**\n * Errors caused by invalid user configuration -i.e. invalid parameters on policies,\n * handlers that are not functions, etc. This is not for zuplo system configuration errors,\n * use SystemError for that.\n * @public\n */\nexport class ConfigurationError extends RuntimeError {\n  constructor(message: string, options?: ErrorOptions) {\n    super(message, options);\n    this.name = \"ConfigurationError\";\n  }\n}\n\n/**\n * Throw when a user tries to use a feature that is not supported by their\n * account or plan\n */\nexport class FeatureNotEnabledError extends RuntimeError {\n  constructor(message: string, options?: ErrorOptions) {\n    super(message, options);\n    this.name = \"FeatureNotEnabledError\";\n  }\n}\n", "import { CompatibilityDate } from \"./config.generated\";\n\n//\n//  This file was automatically generated by scripts/generate-compat-flags.mjs\n//  DO NOT MODIFY IT BY HAND. Modify the file 'compatibility-flags.ts' in\n// runtime, then run:\n//\n//  npm run generate:compat-mappings --workspace @zuplo/runtime\n//\n\nexport interface CompatibilityFlags {\n  /**\n   * Whether or not outbound policies should run if the response from the\n   * handlers is not `response.ok`\n   *\n   * @compatibilityDate 2024-01-15\n   */\n  runOutboundPoliciesOnHandlerOnAllStatuses: boolean;\n\n  /**\n   * Whether or not hooks run on system routes\n   *\n   * @compatibilityDate 2024-01-15\n   */\n  doNotRunHooksOnSystemRoutes: boolean;\n\n  /**\n   * Remove all vendor (cf-, zp-) headers except for the specific\n   * list of allowed headers\n   *\n   * @compatibilityDate 2024-01-15\n   */\n  removeAllVendorHeadersExceptListed: boolean;\n}\n\nexport const DEFAULT_COMPATIBILITY_DATE: CompatibilityDate = \"2024-03-14\";\n\nexport const COMPATIBILITY_FLAG_MAPPINGS: Record<\n  CompatibilityDate | \"none\",\n  CompatibilityFlags\n> = Object.freeze({\n  none: {\n    runOutboundPoliciesOnHandlerOnAllStatuses: false,\n    doNotRunHooksOnSystemRoutes: false,\n    removeAllVendorHeadersExceptListed: false,\n  },\n  \"2023-03-14\": {\n    runOutboundPoliciesOnHandlerOnAllStatuses: false,\n    doNotRunHooksOnSystemRoutes: false,\n    removeAllVendorHeadersExceptListed: false,\n  },\n  \"2024-01-15\": {\n    runOutboundPoliciesOnHandlerOnAllStatuses: true,\n    doNotRunHooksOnSystemRoutes: true,\n    removeAllVendorHeadersExceptListed: true,\n  },\n  \"2024-03-14\": {\n    runOutboundPoliciesOnHandlerOnAllStatuses: true,\n    doNotRunHooksOnSystemRoutes: true,\n    removeAllVendorHeadersExceptListed: true,\n  },\n});\n", "import {\n  COMPATIBILITY_FLAG_MAPPINGS,\n  DEFAULT_COMPATIBILITY_DATE,\n} from \"../compatibility-flags.generated\";\nimport { Environment } from \"../utils/environment\";\n\nexport function getMockEnvironment() {\n  return new Environment({\n    build: {\n      ACCOUNT_NAME: \"mock-account-name\",\n      PROJECT_NAME: \"mock-project-name\",\n      API_VERSION: \"0.0.0\",\n      BUILD_ID: crypto.randomUUID(),\n      TIMESTAMP: new Date().toISOString(),\n      IS_PRODUCTION: false,\n      BUILD_ENV: \"test\",\n      ZUPLO_VERSION: \"0.0.0\",\n      COMPATIBILITY_DATE: DEFAULT_COMPATIBILITY_DATE,\n      ENVIRONMENT_TYPE: \"mock-environment-type\",\n      GIT_SHA: undefined,\n      COMPATIBILITY_FLAGS:\n        COMPATIBILITY_FLAG_MAPPINGS[DEFAULT_COMPATIBILITY_DATE],\n    },\n    runtime: {\n      RUNTIME_ENV: \"test\",\n      RUNTIME_STAGE: \"test\",\n      __ZUPLO_DEPLOYMENT_NAME: \"mock-deployment-name\",\n      __ZUPLO_LOG_LEVEL: \"debug\",\n      __ZUPLO_LOG_FORMAT: \"pretty\",\n      __ZUPLO_MANAGEMENT_API_URL: \"\",\n      __ZUPLO_RUNTIME_TYPE: \"deno\",\n      __ZUPLO_AUTH_API_JWT: \"\",\n    },\n  });\n}\n", "import { LogLevel } from \"../index.worker\";\nimport {\n  BuildEnvironment,\n  LoggingEnvironmentStage,\n  LoggingEnvironmentType,\n  RuntimeEnvironment,\n  ZuploRuntimeConfig,\n} from \"../interfaces\";\nimport { LogFormat } from \"../logging/interfaces\";\nimport { getMockEnvironment } from \"../mocks/environment\";\n\ninterface EnvironmentOptions {\n  build: BuildEnvironment;\n  runtime: RuntimeEnvironment;\n}\n\n/**\n * Represents the environment configuration for the Zuplo runtime.\n */\nexport class Environment {\n  private config: ZuploRuntimeConfig;\n  static #instance: Environment;\n  static #initialized = false;\n\n  static initialize(options: EnvironmentOptions) {\n    if (!this.#instance) {\n      this.#instance = new Environment(options);\n      this.#initialized = true;\n    }\n  }\n\n  static get instance() {\n    if (!this.#initialized) {\n      // eslint-disable-next-line no-console\n      console.debug(\n        `Environment has not been initialized. This is okay when running tests, a mock environment will be used.`\n      );\n      this.#instance = getMockEnvironment();\n    }\n    return this.#instance;\n  }\n\n  constructor({ build, runtime }: EnvironmentOptions) {\n    let parsedRes: ZuploRuntimeConfig | undefined = undefined;\n    try {\n      // @NOTE - if we go past the 5k limit on CF env variables we'll use\n      // more to store our config and decode/merge them here\n      if (runtime.__ZUPLO_CONFIG) {\n        const base64Decoded = atob(runtime.__ZUPLO_CONFIG);\n        parsedRes = JSON.parse(base64Decoded) as ZuploRuntimeConfig;\n      }\n    } catch (err) {\n      // eslint-disable-next-line no-console\n      console.warn(\"Failed to parse runtime configuration\");\n    }\n\n    this.config = parsedRes ?? {};\n    this.build = build;\n    this.runtime = runtime;\n    this.instanceId = crypto.randomUUID();\n  }\n\n  readonly build: Readonly<BuildEnvironment>;\n  readonly runtime: Readonly<RuntimeEnvironment>;\n\n  /**\n   * The unique identifier for the instance\n   */\n  readonly instanceId: string;\n\n  /**\n   * NOTE: - all the getters below first use a `__ZUPLO` env variable, then use\n   * the `this.config` aka `__ZUPLO_CONFIG` env variable, then use a hardcoded\n   * default if available\n   */\n\n  /**\n   * Deployment name for the zup\n   */\n  get deploymentName(): string | undefined {\n    return (\n      this.runtime.__ZUPLO_DEPLOYMENT_NAME ??\n      this.config.deployment_name ??\n      undefined\n    );\n  }\n\n  /**\n   * Should we use the new sha256 hash routing for services\n   */\n  get useSha256ServiceRouting(): string | undefined {\n    return this.config.use_sha256_service_routing ?? undefined;\n  }\n\n  /**\n   * Should we proxy fetch calls from zups?\n   */\n  get useProxyForFetchFromZups(): string | undefined {\n    return this.config.use_proxy_for_fetch_from_zups ?? undefined;\n  }\n\n  /**\n   * Points to where the developer portal is hosted\n   */\n  get devPortalBaseUrl(): string {\n    return (\n      this.runtime.__ZUPLO_DEV_PORTAL_URL ??\n      this.config.dev_portal_url ??\n      \"https://dev-portal-v4-1.zuplo.com\"\n    );\n  }\n\n  get buildAssetsUrl(): string {\n    return (\n      this.runtime.__ZUPLO_BUILD_ASSETS_URL ??\n      this.config.build_assets_url ??\n      \"https://build-assets.zuplo.com\"\n    );\n  }\n\n  /**\n   * Token used to identify zup on the log processing service\n   */\n  get remoteLogToken(): string | undefined {\n    return (\n      this.runtime.__ZUPLO_REMOTE_LOG_TOKEN ??\n      this.config.remote_log_token ??\n      undefined\n    );\n  }\n\n  /**\n   * Management API service URL\n   */\n  get managementApiURL(): string {\n    return (\n      this.runtime.__ZUPLO_MANAGEMENT_API_URL ??\n      this.config.management_api_url ??\n      \"https://api.zuplo.com\"\n    );\n  }\n\n  /**\n   * Zuplo resource CDN URL\n   */\n  get cdnURL(): string {\n    return (\n      this.runtime.__ZUPLO_CDN_URL ??\n      this.config.cdn_url ??\n      \"https://cdn.zuplo.com\"\n    );\n  }\n\n  /**\n   * URL for the service that processes logs\n   */\n  get remoteLogURL(): string {\n    return (\n      this.runtime.__ZUPLO_REMOTE_LOG_URL ??\n      this.config.log_event_api ??\n      \"https://ellie.zuplo.com\"\n    );\n  }\n\n  /**\n   * Id used on internal logs\n   */\n  get loggingId(): string | undefined {\n    return (\n      this.runtime.__ZUPLO_LOGGING_ID ?? this.config.logging_id ?? undefined\n    );\n  }\n\n  /**\n   * URL(s) to access Zuplo Redis service\n   */\n  get redisURL(): string {\n    return (\n      this.runtime.__ZUPLO_REDIS_URL ??\n      this.config.redis_proxy_url ??\n      \"https://redis-proxy.zuplo.com\"\n    );\n  }\n\n  get apiKeyServiceUrl(): string {\n    return (\n      this.runtime.__ZUPLO_API_KEY_SERVICE_URL ??\n      this.config.api_key_service_url ??\n      \"https://apikey.zuplo.com\"\n    );\n  }\n\n  get meteringServiceUrl(): string {\n    return this.config.metering_service_url ?? \"https://meters.zuplo.com\";\n  }\n\n  /**\n   * JWT issued for the zup by the Auth API service\n   */\n  get authApiJWT(): string | undefined {\n    return this.runtime.__ZUPLO_AUTH_API_JWT ?? undefined;\n  }\n\n  /**\n   * The user log level can be overridden with the\n   * ZUPLO_LOG_LEVEL env variable, otherwise it defaults\n   * to the system log level __ZUPLO_LOG_LEVEL\n   */\n  get userLogLevel(): LogLevel {\n    return (\n      this.runtime.ZUPLO_LOG_LEVEL ??\n      this.runtime.__ZUPLO_LOG_LEVEL ??\n      this.config.user_log_level ??\n      \"debug\"\n    );\n  }\n\n  /**\n   * The system log level can be overridden with the __ZUPLO_LOG_LEVEL env variable\n   * otherwise it defaults to 'debug'\n   */\n  get systemLogLevel(): LogLevel {\n    return (\n      this.runtime.__ZUPLO_LOG_LEVEL ?? this.config.system_log_level ?? \"debug\"\n    );\n  }\n\n  /**\n   * Log format for both user & system logs\n   */\n  get logFormat(): LogFormat {\n    return (\n      this.runtime.__ZUPLO_LOG_FORMAT ?? this.config.log_format ?? \"cloudflare\"\n    );\n  }\n\n  /**\n   * Check if runtime is cloudflare\n   */\n  get isCloudflare(): boolean {\n    if (this.runtime.__ZUPLO_RUNTIME_TYPE) {\n      return this.runtime.__ZUPLO_RUNTIME_TYPE === \"cloudflare\";\n    } else if (this.config.runtime_type) {\n      return this.config.runtime_type === \"cloudflare\";\n    } else {\n      // Hack fallback for environments that dont have this variable set\n      return typeof WebSocketPair === \"function\";\n    }\n  }\n\n  /**\n   * Check if runtime is deno\n   */\n  get isDeno(): boolean {\n    if (this.runtime.__ZUPLO_RUNTIME_TYPE) {\n      return this.runtime.__ZUPLO_RUNTIME_TYPE === \"deno\";\n    } else if (this.config.runtime_type) {\n      return this.config.runtime_type === \"deno\";\n    } else {\n      // Hack fallback for environments that dont have this variable set\n      return typeof WebSocketPair !== \"function\";\n    }\n  }\n\n  /**\n   * Check if we are on local development\n   */\n  get isLocalDevelopment(): boolean {\n    if (this.build.ENVIRONMENT_TYPE) {\n      return this.build.ENVIRONMENT_TYPE === \"LOCAL_DEVELOPMENT\";\n    } else {\n      return false;\n    }\n  }\n\n  get systemUserAgent(): string {\n    return `Zuplo/${this.build.ZUPLO_VERSION}`;\n  }\n\n  get loggingEnvironmentType(): LoggingEnvironmentType {\n    if (this.isCloudflare) {\n      return \"edge\";\n    } else if (this.isLocalDevelopment) {\n      return \"local\";\n    } else if (this.isDeno) {\n      return \"working-copy\";\n    } else {\n      return \"unknown\";\n    }\n  }\n\n  get loggingEnvironmentStage(): LoggingEnvironmentStage {\n    if (this.build.ENVIRONMENT_TYPE === \"PRODUCTION\") {\n      return \"production\";\n    } else if (this.build.ENVIRONMENT_TYPE === \"PREVIEW\") {\n      return \"preview\";\n    } else if (this.isLocalDevelopment) {\n      return \"local\";\n    } else if (this.isDeno) {\n      return \"working-copy\";\n    } else {\n      return \"unknown\";\n    }\n  }\n\n  get isWorkingCopy(): boolean {\n    return this.build.ENVIRONMENT_TYPE === \"WORKING_COPY\";\n  }\n}\n", "import { debug } from \"@zuplo/debug\";\nimport { RuntimeError } from \"./errors\";\nimport internals from \"./internals\";\nimport { Environment } from \"./utils/environment\";\n\nconst log = debug(\"zuplo:runtime:external-service\");\n\nexport interface ServiceConfiguration {\n  hostname: string;\n  clientId: string;\n  clientSecret: string;\n}\n\nexport type ServiceConfigurations = Record<string, ServiceConfiguration>;\n\nexport interface TunnelServiceAuth {\n  clientId: string;\n  clientSecret: string;\n  customServiceMapping?: Record<string, string>;\n}\n\nfunction getServiceAuth(): TunnelServiceAuth | undefined {\n  let serviceAuth: TunnelServiceAuth | undefined;\n\n  const { __ZUPLO_EXTERNAL_SERVICE_TOKEN: serviceAuthJson } =\n    Environment.instance.runtime;\n  if (serviceAuthJson && serviceAuthJson !== \"undefined\") {\n    try {\n      const base64Decoded = atob(serviceAuthJson);\n      serviceAuth = JSON.parse(base64Decoded);\n    } catch (err) {\n      // Invalid JSON, ignore and test below\n    }\n  }\n  return serviceAuth;\n}\n\n// @NOTE - currently used only for Deno tunnels but will later be used by the handler below\nexport async function externalServiceTunnelConfig(\n  request: Request | string\n): Promise<{ serviceBaseUrl: string; tunnelHeaders: Record<string, string> }> {\n  const serviceAuth = getServiceAuth();\n  if (!serviceAuth) {\n    // Global logging for trace diagnostics in CF workers\n    log(`There is no external service auth configured for this zup.`);\n    throw new RuntimeError(\n      \"There are no external services configured for this zup.\"\n    );\n  }\n\n  if (typeof request !== \"string\") {\n    // Global logging for trace diagnostics in CF workers\n    log(`Cannot call external service with Request object`);\n    throw new RuntimeError(\n      \"Currently, we only support fetch(<some_string>, ...).\"\n    );\n  }\n\n  const url = new URL(request);\n  const serviceName = url.hostname;\n\n  const tunnelHeaders: Record<string, string> = {};\n\n  // This part is very specific to the way we are doing Cloudflare Tunnels and auth policies.\n  tunnelHeaders[\"CF-Access-Client-Id\"] = serviceAuth.clientId;\n  tunnelHeaders[\"CF-Access-Client-Secret\"] = serviceAuth.clientSecret;\n\n  let serviceBaseUrl: string;\n\n  // Change the hostname to the tunnel host\n  if (\n    serviceAuth.customServiceMapping &&\n    serviceAuth.customServiceMapping[serviceName]\n  ) {\n    serviceBaseUrl = `https://${serviceAuth.customServiceMapping[serviceName]}`;\n  } else if (Environment.instance.useSha256ServiceRouting) {\n    log(`Using sha256 service routing`);\n    const rawBuild = Environment.instance.build;\n    if (\n      rawBuild.ACCOUNT_NAME &&\n      rawBuild.PROJECT_NAME &&\n      rawBuild.ENVIRONMENT_TYPE\n    ) {\n      const fullyHashedSubdomain = await hashServiceName(\n        serviceName,\n        rawBuild.ACCOUNT_NAME,\n        rawBuild.PROJECT_NAME,\n        rawBuild.ENVIRONMENT_TYPE\n      );\n      serviceBaseUrl = `https://${fullyHashedSubdomain}.zuptunnel.com`;\n    } else {\n      // This means that it's broken\n      log(`Cannot use sha256 service routing, missing build variables`);\n      throw new RuntimeError(\"Failed to generate fully qualified tunnel url.\");\n    }\n  } else {\n    serviceBaseUrl = `https://${serviceName}.zuptunnel.com`;\n  }\n\n  return {\n    serviceBaseUrl,\n    tunnelHeaders,\n  };\n}\n\n/**\n * @internal\n */\nexport async function externalServiceHandler(\n  request: Request | string,\n  init?: RequestInit\n): Promise<Response> {\n  const serviceAuth = getServiceAuth();\n  if (serviceAuth) {\n    // Global logging for trace diagnostics in CF workers\n    log(`Using external service auth. ClientId: ${serviceAuth.clientId})`);\n    if (typeof request === \"string\") {\n      const url = new URL(request);\n      const serviceName = url.hostname;\n\n      const decoratedInit = init ?? {};\n\n      // This part is very specific to the way we are doing Cloudflare Tunnels and auth policies.\n      const headers = new Headers(decoratedInit.headers || {});\n      headers.set(\"CF-Access-Client-Id\", serviceAuth.clientId);\n      headers.set(\"CF-Access-Client-Secret\", serviceAuth.clientSecret);\n      decoratedInit.headers = headers;\n\n      let serviceBaseUrl: string;\n\n      // Change the hostname to the tunnel host\n      if (\n        serviceAuth.customServiceMapping &&\n        serviceAuth.customServiceMapping[serviceName]\n      ) {\n        serviceBaseUrl = `https://${serviceAuth.customServiceMapping[serviceName]}`;\n      } else if (Environment.instance.useSha256ServiceRouting) {\n        log(`Using sha256 service routing`);\n        const rawBuild = Environment.instance.build;\n        if (\n          rawBuild.ACCOUNT_NAME &&\n          rawBuild.PROJECT_NAME &&\n          rawBuild.ENVIRONMENT_TYPE\n        ) {\n          const fullyHashedSubdomain = await hashServiceName(\n            serviceName,\n            rawBuild.ACCOUNT_NAME,\n            rawBuild.PROJECT_NAME,\n            rawBuild.ENVIRONMENT_TYPE\n          );\n          serviceBaseUrl = `https://${fullyHashedSubdomain}.zuptunnel.com`;\n        } else {\n          // This means that it's broken\n          log(`Cannot use sha256 service routing, missing build variables`);\n          throw new RuntimeError(\n            \"Failed to generate fully qualified tunnel url.\"\n          );\n        }\n      } else {\n        serviceBaseUrl = `https://${serviceName}.zuptunnel.com`;\n      }\n\n      const serviceUrl = new URL(\n        `${serviceBaseUrl}${url.pathname}${url.search}`\n      );\n\n      // Global logging for trace diagnostics in CF workers\n      log(`Calling external service: ${serviceUrl.toString()}`);\n\n      // Using original fetch to prevent loops in the event of a bug\n      const response = await internals.fetch(\n        serviceUrl.toString(),\n        decoratedInit\n      );\n      if (\n        response.status === 403 &&\n        response.headers.get(\"cf-access-domain\") !== null\n      ) {\n        // If we get a 403 here it means the tunnel is misconfigured\n        // eslint-disable-next-line no-console\n        console.error(`403 Forbidden when calling external service.`, {\n          clientId: serviceAuth.clientId,\n          tunnelHost: serviceBaseUrl,\n        });\n        throw new RuntimeError(\"Could not connect to secure tunnel.\");\n      }\n      return response;\n    } else {\n      // Global logging for trace diagnostics in CF workers\n      log(`Cannot call external service with Request object`);\n      throw new RuntimeError(\n        \"Currently, we only support fetch(<some_string>, ...).\"\n      );\n    }\n  } else {\n    // Global logging for trace diagnostics in CF workers\n    log(`There is no external service auth configured for this zup.`);\n    throw new RuntimeError(\n      \"There are no external services configured for this zup.\"\n    );\n  }\n}\n\nasync function hashServiceName(\n  serviceName: string,\n  accountName: string,\n  projectName: string,\n  environmentType: string\n) {\n  const service = serviceName.toLowerCase();\n  const account = accountName.toLowerCase();\n  const project = projectName.toLowerCase();\n  const environment = sanitizeEnvironmentType(environmentType);\n\n  log(\n    `Hashing service name: ${account}-${service}.${account}-${project}-${environment}`\n  );\n\n  const hashedService = await hashSegment(`${account}-${service}`);\n  const hashedSubdomain = await hashSegment(\n    `${account}-${project}-${environment}`\n  );\n  return `${hashedService}.${hashedSubdomain}`;\n}\n\nasync function hashSegment(segment: string) {\n  const msgUint8 = new TextEncoder().encode(segment);\n  const hashBuffer = await crypto.subtle.digest(\"SHA-256\", msgUint8);\n  const hashArray = Array.from(new Uint8Array(hashBuffer));\n  const hashHex = hashArray\n    .map((b) => b.toString(16).padStart(2, \"0\"))\n    .join(\"\")\n    .slice(0, -1);\n  return hashHex;\n}\n\nfunction sanitizeEnvironmentType(environmentType: string) {\n  const lowercased = environmentType.toLowerCase();\n  switch (lowercased) {\n    case \"production\":\n    case \"preview\":\n      return lowercased;\n    default:\n      return \"working-copy\";\n  }\n}\n", "import { externalServiceHandler } from \"./external-services\";\n/**\n * This is a pretty loose definition of a service.\n * Not all services can handle (or should handle) the breadth of arguments (i.e., RequestInit) that fetch has.\n * But, for now, we assume that the services that we have are indeed `fetch-able`.\n */\nconst protocolHandlers = new Map<\n  string,\n  (request: string | Request, init?: RequestInit) => Promise<Response>\n>();\nprotocolHandlers.set(\"service:\", externalServiceHandler);\n\n// Capturing the original fetch here\nconst originalFetch = globalThis.fetch;\n\n// The new fetch\nexport function internalFetch(\n  request: URL | RequestInfo,\n  init?: RequestInit | Request\n): Promise<Response> {\n  const transformedInit = transformInit(init);\n\n  // TODO: We only support fetch(\"service://service-name/blah/blah\",...) for now.\n  // We should also support fetch(new Request(\"service://service-name/blah/blah\", {}), ...)) and extract the relevant fields from that object\n  if (typeof request === \"string\") {\n    const url = new URL(request);\n    const handler = protocolHandlers.get(url.protocol);\n    if (handler) {\n      return handler(request, transformedInit);\n    } else {\n      return originalFetch(request, transformedInit);\n    }\n  } else {\n    // Default case, let the original fetch handle it\n    return originalFetch(request, transformedInit);\n  }\n}\n\nglobalThis.fetch = internalFetch;\n\ninterface ZuploRequestInit {\n  zuplo?: {\n    cacheTtlSeconds?: number;\n    cacheEverything?: boolean;\n  };\n}\n\ninterface CFCacheInit {\n  cf?: {\n    cacheTtl?: number;\n    cacheEverything?: boolean;\n  };\n}\n\n/** We need to transform cf properties from zuplo properties\n * In this case, we take the original input and transform\n * \\{\n *    zuplo: \\{\n *       cacheTtlSeconds: 5,\n *       cacheEverything: true,\n *    \\}\n * \\}\n *\n * becomes\n *\n * \\{\n *    cf: \\{\n *      cacheTtl: 5,\n *      cacheEverything: true\n *    \\}\n * \\}\n *  */\nconst transformInit = (init: RequestInit | Request | undefined) => {\n  // Not the right type, or undefined - return original\n  if (!init || init instanceof Request) {\n    return init;\n  }\n\n  // peek at the zuplo type\n  const zuploInit = init as ZuploRequestInit;\n\n  // No zuplo type, no transformation needed\n  if (!zuploInit.zuplo) {\n    return init;\n  }\n\n  // grab a ref with a diff type signature\n  const cfInitRef = init as CFCacheInit;\n\n  // Explicitly set cf so that user's can't set them,\n  // we don't want people to use unsupported CF features\n  cfInitRef.cf = {\n    cacheEverything: zuploInit.zuplo?.cacheEverything,\n    cacheTtl: zuploInit.zuplo?.cacheTtlSeconds,\n  };\n\n  // delete the zuplo props\n  delete (init as ZuploRequestInit).zuplo;\n\n  // return newInit\n  return init;\n};\n", "// eslint-disable-next-line no-restricted-imports\nimport { internalFetch } from \"./fetch-redefinition\";\n\nconst internals = {\n  fetch: internalFetch,\n};\n\nexport default internals;\n", "import { Environment } from \"./utils/environment\";\n\n// Prevent people from grabbing a function source code\nFunction.prototype.toString = function () {\n  return \"[native code]\";\n};\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst globalAny = globalThis as any;\nconst originalCaches = globalAny.caches;\n\n// Override the cache but check if this is available (since it's not for Node.js and, thus, this should be a no-op)\nif (originalCaches) {\n  // \uD83D\uDEA8 \uD83D\uDEA8 \uD83D\uDEA8\n  // The globals.cache that we are using is a zone-level cache.\n  // Anyone in the same zone can access it if they know the name.\n  // So if worker1 in zone1 does globals.cache.open(\"my-cache\").put(key, value)\n  // Then worker1 in the same zone can do globals.cache.open(\"my-cache\").get(key)\n  // So we ensure that we always prefix things with the deployment name or buildId, which they cannot mess with.\n  const originalCachesOpen = originalCaches.open;\n  globalAny.caches.open = function (cacheName: string): Promise<Cache> {\n    const uniquePrefix =\n      Environment.instance.deploymentName ??\n      Environment.instance.build.BUILD_ID;\n    return originalCachesOpen.call(this, `${uniquePrefix}-${cacheName}`);\n  };\n\n  // Remove the default cache since we should not use it (it's not namespaced)\n  delete globalAny.caches.default;\n\n  // Prevent any further modifications to the cache\n  Object.freeze(globalAny.caches);\n}\n", "// Defaults\nconst PURGE_PERIOD_MS = 10000;\nconst DEFAULT_MAX_SIZE = 1000;\n\nconst memoryCaches: Map<string, InnerCache> = new Map();\n\ninterface CacheEntry {\n  data: unknown;\n  expiresAt: number;\n  created: number;\n  lastUsed: number;\n}\n\nexport interface MemoryCacheOptions {\n  maxSize: number;\n}\n\nclass InnerCache {\n  constructor(options: MemoryCacheOptions) {\n    this.#maxItems = options.maxSize;\n  }\n\n  #maxItems: number;\n  #lastPurged = 0;\n  #storage: Map<string, CacheEntry> = new Map();\n  #keyStack: string[] = [];\n\n  get(key: string) {\n    const entry = this.#storage.get(key);\n    if (!entry) {\n      return;\n    }\n    const now = Date.now();\n    if (now > entry.expiresAt) {\n      this.#storage.delete(key);\n      return;\n    }\n    entry.lastUsed = now;\n\n    this.#periodicPurge();\n    return entry?.data;\n  }\n\n  put(key: string, data: unknown, ttlSeconds: number) {\n    if (ttlSeconds <= 0) {\n      return;\n    }\n\n    if (this.#storage.size >= this.#maxItems) {\n      const oldKey = this.#keyStack.shift();\n      if (oldKey) {\n        this.#storage.delete(oldKey);\n      }\n    }\n\n    const now = Date.now();\n    const entry: CacheEntry = {\n      created: now,\n      lastUsed: now,\n      expiresAt: now + ttlSeconds * 1000,\n      data,\n    };\n\n    this.#keyStack.push(key);\n    this.#storage.set(key, entry);\n  }\n\n  delete(key: string) {\n    const index = this.#keyStack.indexOf(key);\n    if (index >= 0) {\n      this.#keyStack.slice(index, 1);\n    }\n    this.#storage.delete(key);\n  }\n\n  get size(): number {\n    return this.#storage.size;\n  }\n\n  #periodicPurge() {\n    const now = Date.now();\n    const purgeDue = this.#lastPurged + PURGE_PERIOD_MS * 1000 > now;\n\n    if (purgeDue) {\n      this.purge();\n      this.#lastPurged = now;\n    }\n  }\n\n  purge() {\n    const now = Date.now();\n    this.#storage.forEach((entry, key) => {\n      if (entry.expiresAt >= now) {\n        this.#storage.delete(key);\n      }\n    });\n  }\n}\n\nexport class MemoryCache<T = unknown> {\n  constructor(\n    name: string,\n    options: MemoryCacheOptions = { maxSize: DEFAULT_MAX_SIZE }\n  ) {\n    this.name = name;\n\n    let cache = memoryCaches.get(name);\n    if (!cache) {\n      cache = new InnerCache(options);\n      memoryCaches.set(name, cache);\n    }\n    this.#cache = cache;\n  }\n\n  readonly name: string;\n  #cache: InnerCache;\n\n  get(key: string): T {\n    return this.#cache.get(key) as T;\n  }\n\n  put(key: string, data: T, ttlSeconds: number) {\n    return this.#cache.put(key, data, ttlSeconds);\n  }\n\n  delete(key: string) {\n    return this.#cache.delete(key);\n  }\n\n  get size(): number {\n    return this.#cache.size;\n  }\n\n  purge() {\n    this.#cache.purge();\n  }\n}\n", "import { ZuploContext } from \"../context\";\nimport { CacheOptions } from \"./interfaces\";\n\n// used only in DENO to help with manual expiry\nconst EXPIRY_HEADER = \"__zuplo-expiry-header\";\n\n/**\n * This is a simple wrapper around the data-center HTTP cache\n * to enable simple objects to be stored by a string key. This is\n * useful to us and customers and provides a very high-performance\n * read-through cache that stores data in the same data-center. It is\n * not replicated.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport class ZoneCache<T = any> {\n  constructor(name: string, context: ZuploContext);\n  /**\n   * Internal only constructor\n   * @internal\n   */\n  constructor(name: string, options: CacheOptions);\n  constructor(name: string, context: ZuploContext | CacheOptions) {\n    this.#name = name;\n    this.#context = context;\n  }\n\n  #context: ZuploContext | CacheOptions;\n  #name: string;\n  #cache: Cache | undefined;\n\n  async #getCache() {\n    if (!this.#cache) {\n      // note - we have a security layer in security.ts that ensures\n      // unique name is created when creating the cache.\n      this.#cache = await caches.open(this.#name);\n    }\n    return this.#cache;\n  }\n\n  #getRequest(key: string) {\n    return new Request(\n      `https://zone-cache.zuplo.app/${encodeURIComponent(key)}`\n    );\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  async get(key: string): Promise<T | undefined> {\n    try {\n      const cache = await this.#getCache();\n      const request = this.#getRequest(key);\n      const result = await cache.match(request);\n      if (!result) {\n        return undefined;\n      }\n\n      // The deno cache does not expire, so we do this manually\n      // with an internal header. On Cloudflare, this is a safeguard\n      // to ensure that even if their cache TTL doesn't work as expected\n      // we don't return old values. This is important because this cache\n      // can be used for storing things like JWT tokens that have expirations\n      const expiryHeader = result.headers.get(EXPIRY_HEADER);\n\n      if (!expiryHeader) {\n        try {\n          await cache.delete(request);\n        } catch (err) {\n          this.logDebug(\n            \"Handled failure to delete with CF cache because of missing expiryHeader\",\n            err\n          );\n          await this.deleteFallback(key);\n        }\n        return undefined;\n      }\n\n      const expiresAt = parseInt(expiryHeader);\n\n      if (Date.now() >= expiresAt) {\n        try {\n          await cache.delete(request);\n        } catch (err) {\n          this.logDebug(\n            \"Handled failure to delete with CF cache because of expiration\",\n            err\n          );\n          await this.deleteFallback(key);\n        }\n        return undefined;\n      }\n\n      const data: T = await result.json();\n      return data;\n    } catch (err) {\n      this.logDebug(err);\n    }\n\n    // Fallback\n    // In case of any failures, assume that this is a cache miss\n    return undefined;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  async put(key: string, data: T, ttlSeconds: number) {\n    const headers = new Headers({\n      \"cache-control\": `s-maxage=${ttlSeconds}, must-revalidate`,\n      \"content-type\": \"application/json\",\n    });\n    headers.set(EXPIRY_HEADER, `${Date.now() + ttlSeconds * 1000}`);\n\n    const cache = await this.#getCache();\n    const request = this.#getRequest(key);\n    const response = new Response(JSON.stringify(data), {\n      headers,\n    });\n    await cache.put(request, response);\n  }\n\n  async delete(key: string) {\n    const cache = await this.#getCache();\n    const request = this.#getRequest(key);\n    try {\n      await cache.delete(request);\n    } catch (err) {\n      this.logDebug(\n        \"Handled failure to delete with CF cache due to explicit delete call\",\n        err\n      );\n      await this.deleteFallback(key);\n    }\n  }\n\n  // Wrap the deletes in try/catch because of https://github.com/cloudflare/workers-sdk/issues/2790\n  async deleteFallback(key: string) {\n    const headers = new Headers({\n      \"Cache-Control\": `s-maxage=0, must-revalidate`,\n    });\n    headers.set(EXPIRY_HEADER, `${Date.now()}`);\n    const cache = await this.#getCache();\n    const request = this.#getRequest(key);\n    const response = new Response(\"\", {\n      headers,\n    });\n    await cache.put(request, response);\n  }\n\n  logDebug(...messages: unknown[]) {\n    // This allows the system instantiated loggers to pass the system logger\n    // and user instantiated instances to use the user logger. Once we improve\n    // the logger this won't be needed anymore.\n    if (\"logger\" in this.#context) {\n      this.#context.logger?.debug(\n        `Error in ZoneCache: '${this.#name}'`,\n        messages\n      );\n    } else if (\"log\" in this.#context) {\n      this.#context.log.debug(`Error in ZoneCache: '${this.#name}'`, messages);\n    }\n  }\n}\n", "import { ZuploContext } from \"../context\";\nimport { MemoryCache } from \"./memory-cache\";\nimport { ZoneCache } from \"./zone-cache\";\n\ninterface ZoneCacheEntryWrapper<T> {\n  data: T;\n  expires: number;\n}\n\nexport class MemoryZoneReadThroughCache<T = unknown> {\n  constructor(name: string, context: ZuploContext) {\n    // We add the mzr prefix here because we are using ZoneCache with the name underneath.\n    // If we don't add it, then it will prevent someone from creating the ZoneCache with the same name.\n    // Which could be confusing.\n    const safeName = `f6726488-fd18-4b7f-9c30-6070565e8042-${name}`;\n    this.#name = name;\n    this.#memory = new MemoryCache(safeName);\n    // Cast here is to work around the typescript limitation of constructor\n    // overrides, both classes have the same constructor. Normally, we would\n    // use a union type on the constructor ZuploContext | CacheOptions without\n    // the overrides, but in this case, we want the internal constructor to be\n    // removed from the public types.\n    this.#zone = new ZoneCache(safeName, context as ZuploContext);\n    this.#context = context;\n  }\n\n  #name: string;\n  #memory: MemoryCache<T>;\n  #zone: ZoneCache;\n  #context: ZuploContext;\n\n  async get(key: string): Promise<T | undefined> {\n    const memory = this.#memory.get(key);\n    if (memory) {\n      return memory as T;\n    }\n    const zone: ZoneCacheEntryWrapper<T> | undefined =\n      await this.#zone.get(key);\n    if (zone) {\n      // Not in memory, but in Zone\n      // let's put in memory for the appropriate duration\n      const ttlRemaining = Math.floor((zone.expires - Date.now()) / 1000);\n      if (ttlRemaining > 0) {\n        this.#memory.put(key, zone.data, ttlRemaining);\n        return zone.data as T;\n      }\n    }\n  }\n\n  put(key: string, data: T, ttlSeconds: number) {\n    this.#memory.put(key, data, ttlSeconds);\n\n    const wrapper: ZoneCacheEntryWrapper<T> = {\n      data,\n      expires: Date.now() + ttlSeconds * 1000,\n    };\n    // get it from memory // no need to await this, if they want to get it back they'll\n    const promise = this.#zone.put(key, wrapper, ttlSeconds).catch((err) => {\n      this.#context.log.error(\n        `Error in MemoryZoneReadThroughCache: '${this.#name}'`,\n        err\n      );\n    });\n\n    this.#context.waitUntil(promise);\n  }\n\n  // NO DELETE - if you need to delete cache entries\n  // you shouldn't be using this cache, too complicated to reason\n  // about it. Stuff will expire - you can't delete.\n  // async delete(key: string) {\n  //   this.#memory.delete(key);\n  //   this.#zone.delete(key);\n  // }\n}\n", "export const LEGACY_REQUEST_ID_HEADER = \"zuplo-request-id\";\nexport const REQUEST_ID_HEADER = \"zp-rid\";\nexport const BODY_REMOVED_HEADER = \"zp-body-removed\";\nexport const RAY_ID_HEADER = \"cf-ray\";\nexport const X_REAL_IP_HEADER = \"x-real-ip\";\n\n// Cloudflare Headers are from manage transforms\n// https://developers.cloudflare.com/rules/transform/managed-transforms/reference/\nexport const CF_IP_CITY_HEADER = \"cf-ipcity\";\nexport const CF_IP_CONTINENT_HEADER = \"cf-ipcontinent\";\nexport const CF_IP_COUNTRY_HEADER = \"cf-ipcountry\";\nexport const CF_IP_LONGITUDE_HEADER = \"cf-iplongitude\";\nexport const CF_IP_LATITUDE_HEADER = \"cf-iplatitude\";\nexport const CF_IP_REGION_HEADER = \"cf-region\";\nexport const CF_REGION_CODE_HEADER = \"cf-region-code\";\nexport const CF_METRO_CODE_HEADER = \"cf-metro-code\";\nexport const CF_POSTAL_CODE_HEADER = \"cf-postal-code\";\nexport const CF_TIMEZONE_HEADER = \"cf-timezone\";\n\n// See https://www.loom.com/share/e1d23f75c8e2489bacc422996d234045?sid=701ade22-26a2-4f88-ba9e-4d398fe20b84\n// on why these are duplicated as fallbacks\nexport const ZP_IP_CITY_HEADER = \"zp-ipcity\";\nexport const ZP_IP_CONTINENT_HEADER = \"zp-ipcontinent\";\nexport const ZP_IP_COUNTRY_HEADER = \"zp-ipcountry\";\nexport const ZP_IP_LONGITUDE_HEADER = \"zp-iplongitude\";\nexport const ZP_IP_LATITUDE_HEADER = \"zp-iplatitude\";\n\nexport const TRUE_CLIENT_IP = \"true-client-ip\"; // See: https://developers.cloudflare.com/support/network/understanding-the-true-client-ip-header/\n\n// Zuplo Headers are added by the dispatch worker or the zuplo dev worker\n// https://github.com/zuplo/dispatch-worker/blob/main/src/index.ts\n// https://github.com/zuplo/infra/blob/main/workers/zuplo-dev-headers/src/index.mjs\nexport const ZP_ASN_HEADER = \"zp-asn\";\nexport const ZP_AS_ORG_HEADER = \"zp-asorg\";\nexport const ZP_COLO_HEADER = \"zp-colo\";\nexport const ZP_POSTAL_CODE_HEADER = \"zp-postalcode\";\nexport const ZP_METRO_CODE_HEADER = \"zp-metrocode\";\nexport const ZP_REGION_HEADER = \"zp-region\";\nexport const ZP_REGION_CODE_HEADER = \"zp-regioncode\";\nexport const ZP_TIMEZONE_HEADER = \"zp-timezone\";\n\n/**\n * Headers sent from the dispatch workers to the gateway\n * worker. These are removed before user code is run\n */\nexport const DISPATCH_HEADERS_TO_REMOVE = [\n  // These managed transform headers are always removed\n  CF_IP_CITY_HEADER,\n  CF_IP_CONTINENT_HEADER,\n  CF_IP_COUNTRY_HEADER,\n  CF_IP_LONGITUDE_HEADER,\n  CF_IP_LATITUDE_HEADER,\n\n  // Zuplo Headers, for dispatch to worker communication\n  ZP_ASN_HEADER,\n  ZP_AS_ORG_HEADER,\n  ZP_COLO_HEADER,\n  ZP_POSTAL_CODE_HEADER,\n  ZP_METRO_CODE_HEADER,\n  ZP_REGION_HEADER,\n  ZP_REGION_CODE_HEADER,\n  ZP_TIMEZONE_HEADER,\n];\n\nexport const VENDOR_HEADER_PREFIXES = [\"zp-\", \"cf-\"];\nexport const VENDOR_HEADERS_TO_ALLOW = [\n  REQUEST_ID_HEADER,\n  RAY_ID_HEADER,\n  BODY_REMOVED_HEADER,\n];\n/**\n * Headers to be stripped out before the user code runs\n */\nexport const INTERNAL_HEADERS_TO_REMOVE = [\n  \"x-b3-sampled\",\n  \"x-b3-spanid\",\n  \"x-b3-traceid\",\n  \"x-envoy-attempt-count\",\n  \"x-envoy-decorator-operation\",\n  \"x-envoy-external-address\",\n  \"x-envoy-peer-metadata\",\n  \"x-envoy-peer-metadata-id\",\n  \"k-proxy-request\",\n  \"fly-client-ip\",\n  \"fly-forwarded-port\",\n  \"fly-forwarded-proto\",\n  \"fly-forwarded-ssl\",\n  \"fly-region\",\n  \"fly-request-id\",\n  \"fly-traceparent\",\n  \"fly-tracestate\",\n];\n\nexport const METERING_SUBSCRIPTION_CONTEXT_DATA =\n  \"zuplo_meters_d7831150-6d8a-416d-b920-4a7bec209a49\";\nexport const DYNAMIC_METERS_CONTEXT_DATA =\n  \"zuplo_dynamic_meters_0c8cdc26-2514-4756-8adb-474a6e103d91\";\n\n/**\n * @internal\n */\nexport const SYSTEM_LOGGER = \"system-logger\";\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// Updates to this file should also be replicated to @opentelemetry/core too.\n\n/**\n * - globalThis (New standard)\n * - self (Will return the current window instance for supported browsers)\n * - window (fallback for older browser implementations)\n * - global (NodeJS implementation)\n * - <object> (When all else fails)\n */\n\n/** only globals that common to node and browsers are allowed */\n// eslint-disable-next-line node/no-unsupported-features/es-builtins, no-undef\nexport const _globalThis: typeof globalThis =\n  typeof globalThis === 'object'\n    ? globalThis\n    : typeof self === 'object'\n    ? self\n    : typeof window === 'object'\n    ? window\n    : typeof global === 'object'\n    ? global\n    : ({} as typeof globalThis);\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport * from './globalThis';\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// this is autogenerated file, see scripts/version-update.js\nexport const VERSION = '1.7.0';\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { VERSION } from '../version';\n\nconst re = /^(\\d+)\\.(\\d+)\\.(\\d+)(-(.+))?$/;\n\n/**\n * Create a function to test an API version to see if it is compatible with the provided ownVersion.\n *\n * The returned function has the following semantics:\n * - Exact match is always compatible\n * - Major versions must match exactly\n *    - 1.x package cannot use global 2.x package\n *    - 2.x package cannot use global 1.x package\n * - The minor version of the API module requesting access to the global API must be less than or equal to the minor version of this API\n *    - 1.3 package may use 1.4 global because the later global contains all functions 1.3 expects\n *    - 1.4 package may NOT use 1.3 global because it may try to call functions which don't exist on 1.3\n * - If the major version is 0, the minor version is treated as the major and the patch is treated as the minor\n * - Patch and build tag differences are not considered at this time\n *\n * @param ownVersion version which should be checked against\n */\nexport function _makeCompatibilityCheck(\n  ownVersion: string\n): (globalVersion: string) => boolean {\n  const acceptedVersions = new Set<string>([ownVersion]);\n  const rejectedVersions = new Set<string>();\n\n  const myVersionMatch = ownVersion.match(re);\n  if (!myVersionMatch) {\n    // we cannot guarantee compatibility so we always return noop\n    return () => false;\n  }\n\n  const ownVersionParsed = {\n    major: +myVersionMatch[1],\n    minor: +myVersionMatch[2],\n    patch: +myVersionMatch[3],\n    prerelease: myVersionMatch[4],\n  };\n\n  // if ownVersion has a prerelease tag, versions must match exactly\n  if (ownVersionParsed.prerelease != null) {\n    return function isExactmatch(globalVersion: string): boolean {\n      return globalVersion === ownVersion;\n    };\n  }\n\n  function _reject(v: string) {\n    rejectedVersions.add(v);\n    return false;\n  }\n\n  function _accept(v: string) {\n    acceptedVersions.add(v);\n    return true;\n  }\n\n  return function isCompatible(globalVersion: string): boolean {\n    if (acceptedVersions.has(globalVersion)) {\n      return true;\n    }\n\n    if (rejectedVersions.has(globalVersion)) {\n      return false;\n    }\n\n    const globalVersionMatch = globalVersion.match(re);\n    if (!globalVersionMatch) {\n      // cannot parse other version\n      // we cannot guarantee compatibility so we always noop\n      return _reject(globalVersion);\n    }\n\n    const globalVersionParsed = {\n      major: +globalVersionMatch[1],\n      minor: +globalVersionMatch[2],\n      patch: +globalVersionMatch[3],\n      prerelease: globalVersionMatch[4],\n    };\n\n    // if globalVersion has a prerelease tag, versions must match exactly\n    if (globalVersionParsed.prerelease != null) {\n      return _reject(globalVersion);\n    }\n\n    // major versions must match\n    if (ownVersionParsed.major !== globalVersionParsed.major) {\n      return _reject(globalVersion);\n    }\n\n    if (ownVersionParsed.major === 0) {\n      if (\n        ownVersionParsed.minor === globalVersionParsed.minor &&\n        ownVersionParsed.patch <= globalVersionParsed.patch\n      ) {\n        return _accept(globalVersion);\n      }\n\n      return _reject(globalVersion);\n    }\n\n    if (ownVersionParsed.minor <= globalVersionParsed.minor) {\n      return _accept(globalVersion);\n    }\n\n    return _reject(globalVersion);\n  };\n}\n\n/**\n * Test an API version to see if it is compatible with this API.\n *\n * - Exact match is always compatible\n * - Major versions must match exactly\n *    - 1.x package cannot use global 2.x package\n *    - 2.x package cannot use global 1.x package\n * - The minor version of the API module requesting access to the global API must be less than or equal to the minor version of this API\n *    - 1.3 package may use 1.4 global because the later global contains all functions 1.3 expects\n *    - 1.4 package may NOT use 1.3 global because it may try to call functions which don't exist on 1.3\n * - If the major version is 0, the minor version is treated as the major and the patch is treated as the minor\n * - Patch and build tag differences are not considered at this time\n *\n * @param version version of the API requesting an instance of the global API\n */\nexport const isCompatible = _makeCompatibilityCheck(VERSION);\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { MeterProvider } from '../metrics/MeterProvider';\nimport { ContextManager } from '../context/types';\nimport { DiagLogger } from '../diag/types';\nimport { _globalThis } from '../platform';\nimport { TextMapPropagator } from '../propagation/TextMapPropagator';\nimport type { TracerProvider } from '../trace/tracer_provider';\nimport { VERSION } from '../version';\nimport { isCompatible } from './semver';\n\nconst major = VERSION.split('.')[0];\nconst GLOBAL_OPENTELEMETRY_API_KEY = Symbol.for(\n  `opentelemetry.js.api.${major}`\n);\n\nconst _global = _globalThis as OTelGlobal;\n\nexport function registerGlobal<Type extends keyof OTelGlobalAPI>(\n  type: Type,\n  instance: OTelGlobalAPI[Type],\n  diag: DiagLogger,\n  allowOverride = false\n): boolean {\n  const api = (_global[GLOBAL_OPENTELEMETRY_API_KEY] = _global[\n    GLOBAL_OPENTELEMETRY_API_KEY\n  ] ?? {\n    version: VERSION,\n  });\n\n  if (!allowOverride && api[type]) {\n    // already registered an API of this type\n    const err = new Error(\n      `@opentelemetry/api: Attempted duplicate registration of API: ${type}`\n    );\n    diag.error(err.stack || err.message);\n    return false;\n  }\n\n  if (api.version !== VERSION) {\n    // All registered APIs must be of the same version exactly\n    const err = new Error(\n      `@opentelemetry/api: Registration of version v${api.version} for ${type} does not match previously registered API v${VERSION}`\n    );\n    diag.error(err.stack || err.message);\n    return false;\n  }\n\n  api[type] = instance;\n  diag.debug(\n    `@opentelemetry/api: Registered a global for ${type} v${VERSION}.`\n  );\n\n  return true;\n}\n\nexport function getGlobal<Type extends keyof OTelGlobalAPI>(\n  type: Type\n): OTelGlobalAPI[Type] | undefined {\n  const globalVersion = _global[GLOBAL_OPENTELEMETRY_API_KEY]?.version;\n  if (!globalVersion || !isCompatible(globalVersion)) {\n    return;\n  }\n  return _global[GLOBAL_OPENTELEMETRY_API_KEY]?.[type];\n}\n\nexport function unregisterGlobal(type: keyof OTelGlobalAPI, diag: DiagLogger) {\n  diag.debug(\n    `@opentelemetry/api: Unregistering a global for ${type} v${VERSION}.`\n  );\n  const api = _global[GLOBAL_OPENTELEMETRY_API_KEY];\n\n  if (api) {\n    delete api[type];\n  }\n}\n\ntype OTelGlobal = {\n  [GLOBAL_OPENTELEMETRY_API_KEY]?: OTelGlobalAPI;\n};\n\ntype OTelGlobalAPI = {\n  version: string;\n\n  diag?: DiagLogger;\n  trace?: TracerProvider;\n  context?: ContextManager;\n  metrics?: MeterProvider;\n  propagation?: TextMapPropagator;\n};\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { getGlobal } from '../internal/global-utils';\nimport { ComponentLoggerOptions, DiagLogger, DiagLogFunction } from './types';\n\n/**\n * Component Logger which is meant to be used as part of any component which\n * will add automatically additional namespace in front of the log message.\n * It will then forward all message to global diag logger\n * @example\n * const cLogger = diag.createComponentLogger({ namespace: '@opentelemetry/instrumentation-http' });\n * cLogger.debug('test');\n * // @opentelemetry/instrumentation-http test\n */\nexport class DiagComponentLogger implements DiagLogger {\n  private _namespace: string;\n\n  constructor(props: ComponentLoggerOptions) {\n    this._namespace = props.namespace || 'DiagComponentLogger';\n  }\n\n  public debug(...args: any[]): void {\n    return logProxy('debug', this._namespace, args);\n  }\n\n  public error(...args: any[]): void {\n    return logProxy('error', this._namespace, args);\n  }\n\n  public info(...args: any[]): void {\n    return logProxy('info', this._namespace, args);\n  }\n\n  public warn(...args: any[]): void {\n    return logProxy('warn', this._namespace, args);\n  }\n\n  public verbose(...args: any[]): void {\n    return logProxy('verbose', this._namespace, args);\n  }\n}\n\nfunction logProxy(\n  funcName: keyof DiagLogger,\n  namespace: string,\n  args: any\n): void {\n  const logger = getGlobal('diag');\n  // shortcut if logger not set\n  if (!logger) {\n    return;\n  }\n\n  args.unshift(namespace);\n  return logger[funcName](...(args as Parameters<DiagLogFunction>));\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport type DiagLogFunction = (message: string, ...args: unknown[]) => void;\n\n/**\n * Defines an internal diagnostic logger interface which is used to log internal diagnostic\n * messages, you can set the default diagnostic logger via the {@link DiagAPI} setLogger function.\n * API provided implementations include :-\n * - a No-Op {@link createNoopDiagLogger}\n * - a {@link DiagLogLevel} filtering wrapper {@link createLogLevelDiagLogger}\n * - a general Console {@link DiagConsoleLogger} version.\n */\nexport interface DiagLogger {\n  /** Log an error scenario that was not expected and caused the requested operation to fail. */\n  error: DiagLogFunction;\n\n  /**\n   * Log a warning scenario to inform the developer of an issues that should be investigated.\n   * The requested operation may or may not have succeeded or completed.\n   */\n  warn: DiagLogFunction;\n\n  /**\n   * Log a general informational message, this should not affect functionality.\n   * This is also the default logging level so this should NOT be used for logging\n   * debugging level information.\n   */\n  info: DiagLogFunction;\n\n  /**\n   * Log a general debug message that can be useful for identifying a failure.\n   * Information logged at this level may include diagnostic details that would\n   * help identify a failure scenario.\n   * For example: Logging the order of execution of async operations.\n   */\n  debug: DiagLogFunction;\n\n  /**\n   * Log a detailed (verbose) trace level logging that can be used to identify failures\n   * where debug level logging would be insufficient, this level of tracing can include\n   * input and output parameters and as such may include PII information passing through\n   * the API. As such it is recommended that this level of tracing should not be enabled\n   * in a production environment.\n   */\n  verbose: DiagLogFunction;\n}\n\n/**\n * Defines the available internal logging levels for the diagnostic logger, the numeric values\n * of the levels are defined to match the original values from the initial LogLevel to avoid\n * compatibility/migration issues for any implementation that assume the numeric ordering.\n */\nexport enum DiagLogLevel {\n  /** Diagnostic Logging level setting to disable all logging (except and forced logs) */\n  NONE = 0,\n\n  /** Identifies an error scenario */\n  ERROR = 30,\n\n  /** Identifies a warning scenario */\n  WARN = 50,\n\n  /** General informational log message */\n  INFO = 60,\n\n  /** General debug log message */\n  DEBUG = 70,\n\n  /**\n   * Detailed trace level logging should only be used for development, should only be set\n   * in a development environment.\n   */\n  VERBOSE = 80,\n\n  /** Used to set the logging level to include all logging */\n  ALL = 9999,\n}\n\n/**\n * Defines options for ComponentLogger\n */\nexport interface ComponentLoggerOptions {\n  namespace: string;\n}\n\nexport interface DiagLoggerOptions {\n  /**\n   * The {@link DiagLogLevel} used to filter logs sent to the logger.\n   *\n   * @defaultValue DiagLogLevel.INFO\n   */\n  logLevel?: DiagLogLevel;\n\n  /**\n   * Setting this value to `true` will suppress the warning message normally emitted when registering a logger when another logger is already registered.\n   */\n  suppressOverrideMessage?: boolean;\n}\n\nexport interface DiagLoggerApi {\n  /**\n   * Set the global DiagLogger and DiagLogLevel.\n   * If a global diag logger is already set, this will override it.\n   *\n   * @param logger - The {@link DiagLogger} instance to set as the default logger.\n   * @param options - A {@link DiagLoggerOptions} object. If not provided, default values will be set.\n   * @returns `true` if the logger was successfully registered, else `false`\n   */\n  setLogger(logger: DiagLogger, options?: DiagLoggerOptions): boolean;\n\n  /**\n   *\n   * @param logger - The {@link DiagLogger} instance to set as the default logger.\n   * @param logLevel - The {@link DiagLogLevel} used to filter logs sent to the logger. If not provided it will default to {@link DiagLogLevel.INFO}.\n   * @returns `true` if the logger was successfully registered, else `false`\n   */\n  setLogger(logger: DiagLogger, logLevel?: DiagLogLevel): boolean;\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { DiagLogFunction, DiagLogger, DiagLogLevel } from '../types';\n\nexport function createLogLevelDiagLogger(\n  maxLevel: DiagLogLevel,\n  logger: DiagLogger\n): DiagLogger {\n  if (maxLevel < DiagLogLevel.NONE) {\n    maxLevel = DiagLogLevel.NONE;\n  } else if (maxLevel > DiagLogLevel.ALL) {\n    maxLevel = DiagLogLevel.ALL;\n  }\n\n  // In case the logger is null or undefined\n  logger = logger || {};\n\n  function _filterFunc(\n    funcName: keyof DiagLogger,\n    theLevel: DiagLogLevel\n  ): DiagLogFunction {\n    const theFunc = logger[funcName];\n\n    if (typeof theFunc === 'function' && maxLevel >= theLevel) {\n      return theFunc.bind(logger);\n    }\n    return function () {};\n  }\n\n  return {\n    error: _filterFunc('error', DiagLogLevel.ERROR),\n    warn: _filterFunc('warn', DiagLogLevel.WARN),\n    info: _filterFunc('info', DiagLogLevel.INFO),\n    debug: _filterFunc('debug', DiagLogLevel.DEBUG),\n    verbose: _filterFunc('verbose', DiagLogLevel.VERBOSE),\n  };\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { DiagComponentLogger } from '../diag/ComponentLogger';\nimport { createLogLevelDiagLogger } from '../diag/internal/logLevelLogger';\nimport {\n  ComponentLoggerOptions,\n  DiagLogFunction,\n  DiagLogger,\n  DiagLoggerApi,\n  DiagLogLevel,\n} from '../diag/types';\nimport {\n  getGlobal,\n  registerGlobal,\n  unregisterGlobal,\n} from '../internal/global-utils';\n\nconst API_NAME = 'diag';\n\n/**\n * Singleton object which represents the entry point to the OpenTelemetry internal\n * diagnostic API\n */\nexport class DiagAPI implements DiagLogger, DiagLoggerApi {\n  private static _instance?: DiagAPI;\n\n  /** Get the singleton instance of the DiagAPI API */\n  public static instance(): DiagAPI {\n    if (!this._instance) {\n      this._instance = new DiagAPI();\n    }\n\n    return this._instance;\n  }\n\n  /**\n   * Private internal constructor\n   * @private\n   */\n  private constructor() {\n    function _logProxy(funcName: keyof DiagLogger): DiagLogFunction {\n      return function (...args) {\n        const logger = getGlobal('diag');\n        // shortcut if logger not set\n        if (!logger) return;\n        return logger[funcName](...args);\n      };\n    }\n\n    // Using self local variable for minification purposes as 'this' cannot be minified\n    const self = this;\n\n    // DiagAPI specific functions\n\n    const setLogger: DiagLoggerApi['setLogger'] = (\n      logger,\n      optionsOrLogLevel = { logLevel: DiagLogLevel.INFO }\n    ) => {\n      if (logger === self) {\n        // There isn't much we can do here.\n        // Logging to the console might break the user application.\n        // Try to log to self. If a logger was previously registered it will receive the log.\n        const err = new Error(\n          'Cannot use diag as the logger for itself. Please use a DiagLogger implementation like ConsoleDiagLogger or a custom implementation'\n        );\n        self.error(err.stack ?? err.message);\n        return false;\n      }\n\n      if (typeof optionsOrLogLevel === 'number') {\n        optionsOrLogLevel = {\n          logLevel: optionsOrLogLevel,\n        };\n      }\n\n      const oldLogger = getGlobal('diag');\n      const newLogger = createLogLevelDiagLogger(\n        optionsOrLogLevel.logLevel ?? DiagLogLevel.INFO,\n        logger\n      );\n      // There already is an logger registered. We'll let it know before overwriting it.\n      if (oldLogger && !optionsOrLogLevel.suppressOverrideMessage) {\n        const stack = new Error().stack ?? '<failed to generate stacktrace>';\n        oldLogger.warn(`Current logger will be overwritten from ${stack}`);\n        newLogger.warn(\n          `Current logger will overwrite one already registered from ${stack}`\n        );\n      }\n\n      return registerGlobal('diag', newLogger, self, true);\n    };\n\n    self.setLogger = setLogger;\n\n    self.disable = () => {\n      unregisterGlobal(API_NAME, self);\n    };\n\n    self.createComponentLogger = (options: ComponentLoggerOptions) => {\n      return new DiagComponentLogger(options);\n    };\n\n    self.verbose = _logProxy('verbose');\n    self.debug = _logProxy('debug');\n    self.info = _logProxy('info');\n    self.warn = _logProxy('warn');\n    self.error = _logProxy('error');\n  }\n\n  public setLogger!: DiagLoggerApi['setLogger'];\n  /**\n   *\n   */\n  public createComponentLogger!: (\n    options: ComponentLoggerOptions\n  ) => DiagLogger;\n\n  // DiagLogger implementation\n  public verbose!: DiagLogFunction;\n  public debug!: DiagLogFunction;\n  public info!: DiagLogFunction;\n  public warn!: DiagLogFunction;\n  public error!: DiagLogFunction;\n\n  /**\n   * Unregister the global logger and return to Noop\n   */\n  public disable!: () => void;\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Context } from './types';\n\n/** Get a key to uniquely identify a context value */\nexport function createContextKey(description: string) {\n  // The specification states that for the same input, multiple calls should\n  // return different keys. Due to the nature of the JS dependency management\n  // system, this creates problems where multiple versions of some package\n  // could hold different keys for the same property.\n  //\n  // Therefore, we use Symbol.for which returns the same key for the same input.\n  return Symbol.for(description);\n}\n\nclass BaseContext implements Context {\n  private _currentContext!: Map<symbol, unknown>;\n\n  /**\n   * Construct a new context which inherits values from an optional parent context.\n   *\n   * @param parentContext a context from which to inherit values\n   */\n  constructor(parentContext?: Map<symbol, unknown>) {\n    // for minification\n    const self = this;\n\n    self._currentContext = parentContext ? new Map(parentContext) : new Map();\n\n    self.getValue = (key: symbol) => self._currentContext.get(key);\n\n    self.setValue = (key: symbol, value: unknown): Context => {\n      const context = new BaseContext(self._currentContext);\n      context._currentContext.set(key, value);\n      return context;\n    };\n\n    self.deleteValue = (key: symbol): Context => {\n      const context = new BaseContext(self._currentContext);\n      context._currentContext.delete(key);\n      return context;\n    };\n  }\n\n  /**\n   * Get a value from the context.\n   *\n   * @param key key which identifies a context value\n   */\n  public getValue!: (key: symbol) => unknown;\n\n  /**\n   * Create a new context which inherits from this context and has\n   * the given key set to the given value.\n   *\n   * @param key context key for which to set the value\n   * @param value value to set for the given key\n   */\n  public setValue!: (key: symbol, value: unknown) => Context;\n\n  /**\n   * Return a new context which inherits from this context but does\n   * not contain a value for the given key.\n   *\n   * @param key context key for which to clear a value\n   */\n  public deleteValue!: (key: symbol) => Context;\n}\n\n/** The root context is used as the default parent context when there is no active context */\nexport const ROOT_CONTEXT: Context = new BaseContext();\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ROOT_CONTEXT } from './context';\nimport * as types from './types';\n\nexport class NoopContextManager implements types.ContextManager {\n  active(): types.Context {\n    return ROOT_CONTEXT;\n  }\n\n  with<A extends unknown[], F extends (...args: A) => ReturnType<F>>(\n    _context: types.Context,\n    fn: F,\n    thisArg?: ThisParameterType<F>,\n    ...args: A\n  ): ReturnType<F> {\n    return fn.call(thisArg, ...args);\n  }\n\n  bind<T>(_context: types.Context, target: T): T {\n    return target;\n  }\n\n  enable(): this {\n    return this;\n  }\n\n  disable(): this {\n    return this;\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { NoopContextManager } from '../context/NoopContextManager';\nimport { Context, ContextManager } from '../context/types';\nimport {\n  getGlobal,\n  registerGlobal,\n  unregisterGlobal,\n} from '../internal/global-utils';\nimport { DiagAPI } from './diag';\n\nconst API_NAME = 'context';\nconst NOOP_CONTEXT_MANAGER = new NoopContextManager();\n\n/**\n * Singleton object which represents the entry point to the OpenTelemetry Context API\n */\nexport class ContextAPI {\n  private static _instance?: ContextAPI;\n\n  /** Empty private constructor prevents end users from constructing a new instance of the API */\n  private constructor() {}\n\n  /** Get the singleton instance of the Context API */\n  public static getInstance(): ContextAPI {\n    if (!this._instance) {\n      this._instance = new ContextAPI();\n    }\n\n    return this._instance;\n  }\n\n  /**\n   * Set the current context manager.\n   *\n   * @returns true if the context manager was successfully registered, else false\n   */\n  public setGlobalContextManager(contextManager: ContextManager): boolean {\n    return registerGlobal(API_NAME, contextManager, DiagAPI.instance());\n  }\n\n  /**\n   * Get the currently active context\n   */\n  public active(): Context {\n    return this._getContextManager().active();\n  }\n\n  /**\n   * Execute a function with an active context\n   *\n   * @param context context to be active during function execution\n   * @param fn function to execute in a context\n   * @param thisArg optional receiver to be used for calling fn\n   * @param args optional arguments forwarded to fn\n   */\n  public with<A extends unknown[], F extends (...args: A) => ReturnType<F>>(\n    context: Context,\n    fn: F,\n    thisArg?: ThisParameterType<F>,\n    ...args: A\n  ): ReturnType<F> {\n    return this._getContextManager().with(context, fn, thisArg, ...args);\n  }\n\n  /**\n   * Bind a context to a target function or event emitter\n   *\n   * @param context context to bind to the event emitter or function. Defaults to the currently active context\n   * @param target function or event emitter to bind\n   */\n  public bind<T>(context: Context, target: T): T {\n    return this._getContextManager().bind(context, target);\n  }\n\n  private _getContextManager(): ContextManager {\n    return getGlobal(API_NAME) || NOOP_CONTEXT_MANAGER;\n  }\n\n  /** Disable and remove the global context manager */\n  public disable() {\n    this._getContextManager().disable();\n    unregisterGlobal(API_NAME, DiagAPI.instance());\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport enum TraceFlags {\n  /** Represents no flag set. */\n  NONE = 0x0,\n  /** Bit to represent whether trace is sampled in trace flags. */\n  SAMPLED = 0x1 << 0,\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { SpanContext } from './span_context';\nimport { TraceFlags } from './trace_flags';\n\nexport const INVALID_SPANID = '0000000000000000';\nexport const INVALID_TRACEID = '00000000000000000000000000000000';\nexport const INVALID_SPAN_CONTEXT: SpanContext = {\n  traceId: INVALID_TRACEID,\n  spanId: INVALID_SPANID,\n  traceFlags: TraceFlags.NONE,\n};\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Exception } from '../common/Exception';\nimport { TimeInput } from '../common/Time';\nimport { SpanAttributes } from './attributes';\nimport { INVALID_SPAN_CONTEXT } from './invalid-span-constants';\nimport { Span } from './span';\nimport { SpanContext } from './span_context';\nimport { SpanStatus } from './status';\n\n/**\n * The NonRecordingSpan is the default {@link Span} that is used when no Span\n * implementation is available. All operations are no-op including context\n * propagation.\n */\nexport class NonRecordingSpan implements Span {\n  constructor(\n    private readonly _spanContext: SpanContext = INVALID_SPAN_CONTEXT\n  ) {}\n\n  // Returns a SpanContext.\n  spanContext(): SpanContext {\n    return this._spanContext;\n  }\n\n  // By default does nothing\n  setAttribute(_key: string, _value: unknown): this {\n    return this;\n  }\n\n  // By default does nothing\n  setAttributes(_attributes: SpanAttributes): this {\n    return this;\n  }\n\n  // By default does nothing\n  addEvent(_name: string, _attributes?: SpanAttributes): this {\n    return this;\n  }\n\n  // By default does nothing\n  setStatus(_status: SpanStatus): this {\n    return this;\n  }\n\n  // By default does nothing\n  updateName(_name: string): this {\n    return this;\n  }\n\n  // By default does nothing\n  end(_endTime?: TimeInput): void {}\n\n  // isRecording always returns false for NonRecordingSpan.\n  isRecording(): boolean {\n    return false;\n  }\n\n  // By default does nothing\n  recordException(_exception: Exception, _time?: TimeInput): void {}\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { createContextKey } from '../context/context';\nimport { Context } from '../context/types';\nimport { Span } from './span';\nimport { SpanContext } from './span_context';\nimport { NonRecordingSpan } from './NonRecordingSpan';\nimport { ContextAPI } from '../api/context';\n\n/**\n * span key\n */\nconst SPAN_KEY = createContextKey('OpenTelemetry Context Key SPAN');\n\n/**\n * Return the span if one exists\n *\n * @param context context to get span from\n */\nexport function getSpan(context: Context): Span | undefined {\n  return (context.getValue(SPAN_KEY) as Span) || undefined;\n}\n\n/**\n * Gets the span from the current context, if one exists.\n */\nexport function getActiveSpan(): Span | undefined {\n  return getSpan(ContextAPI.getInstance().active());\n}\n\n/**\n * Set the span on a context\n *\n * @param context context to use as parent\n * @param span span to set active\n */\nexport function setSpan(context: Context, span: Span): Context {\n  return context.setValue(SPAN_KEY, span);\n}\n\n/**\n * Remove current span stored in the context\n *\n * @param context context to delete span from\n */\nexport function deleteSpan(context: Context): Context {\n  return context.deleteValue(SPAN_KEY);\n}\n\n/**\n * Wrap span context in a NoopSpan and set as span in a new\n * context\n *\n * @param context context to set active span on\n * @param spanContext span context to be wrapped\n */\nexport function setSpanContext(\n  context: Context,\n  spanContext: SpanContext\n): Context {\n  return setSpan(context, new NonRecordingSpan(spanContext));\n}\n\n/**\n * Get the span context of the span if it exists.\n *\n * @param context context to get values from\n */\nexport function getSpanContext(context: Context): SpanContext | undefined {\n  return getSpan(context)?.spanContext();\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { INVALID_SPANID, INVALID_TRACEID } from './invalid-span-constants';\nimport { NonRecordingSpan } from './NonRecordingSpan';\nimport { Span } from './span';\nimport { SpanContext } from './span_context';\n\nconst VALID_TRACEID_REGEX = /^([0-9a-f]{32})$/i;\nconst VALID_SPANID_REGEX = /^[0-9a-f]{16}$/i;\n\nexport function isValidTraceId(traceId: string): boolean {\n  return VALID_TRACEID_REGEX.test(traceId) && traceId !== INVALID_TRACEID;\n}\n\nexport function isValidSpanId(spanId: string): boolean {\n  return VALID_SPANID_REGEX.test(spanId) && spanId !== INVALID_SPANID;\n}\n\n/**\n * Returns true if this {@link SpanContext} is valid.\n * @return true if this {@link SpanContext} is valid.\n */\nexport function isSpanContextValid(spanContext: SpanContext): boolean {\n  return (\n    isValidTraceId(spanContext.traceId) && isValidSpanId(spanContext.spanId)\n  );\n}\n\n/**\n * Wrap the given {@link SpanContext} in a new non-recording {@link Span}\n *\n * @param spanContext span context to be wrapped\n * @returns a new non-recording {@link Span} with the provided context\n */\nexport function wrapSpanContext(spanContext: SpanContext): Span {\n  return new NonRecordingSpan(spanContext);\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ContextAPI } from '../api/context';\nimport { Context } from '../context/types';\nimport { getSpanContext, setSpan } from '../trace/context-utils';\nimport { NonRecordingSpan } from './NonRecordingSpan';\nimport { Span } from './span';\nimport { isSpanContextValid } from './spancontext-utils';\nimport { SpanOptions } from './SpanOptions';\nimport { SpanContext } from './span_context';\nimport { Tracer } from './tracer';\n\nconst contextApi = ContextAPI.getInstance();\n\n/**\n * No-op implementations of {@link Tracer}.\n */\nexport class NoopTracer implements Tracer {\n  // startSpan starts a noop span.\n  startSpan(\n    name: string,\n    options?: SpanOptions,\n    context = contextApi.active()\n  ): Span {\n    const root = Boolean(options?.root);\n    if (root) {\n      return new NonRecordingSpan();\n    }\n\n    const parentFromContext = context && getSpanContext(context);\n\n    if (\n      isSpanContext(parentFromContext) &&\n      isSpanContextValid(parentFromContext)\n    ) {\n      return new NonRecordingSpan(parentFromContext);\n    } else {\n      return new NonRecordingSpan();\n    }\n  }\n\n  startActiveSpan<F extends (span: Span) => ReturnType<F>>(\n    name: string,\n    fn: F\n  ): ReturnType<F>;\n  startActiveSpan<F extends (span: Span) => ReturnType<F>>(\n    name: string,\n    opts: SpanOptions | undefined,\n    fn: F\n  ): ReturnType<F>;\n  startActiveSpan<F extends (span: Span) => ReturnType<F>>(\n    name: string,\n    opts: SpanOptions | undefined,\n    ctx: Context | undefined,\n    fn: F\n  ): ReturnType<F>;\n  startActiveSpan<F extends (span: Span) => ReturnType<F>>(\n    name: string,\n    arg2?: F | SpanOptions,\n    arg3?: F | Context,\n    arg4?: F\n  ): ReturnType<F> | undefined {\n    let opts: SpanOptions | undefined;\n    let ctx: Context | undefined;\n    let fn: F;\n\n    if (arguments.length < 2) {\n      return;\n    } else if (arguments.length === 2) {\n      fn = arg2 as F;\n    } else if (arguments.length === 3) {\n      opts = arg2 as SpanOptions | undefined;\n      fn = arg3 as F;\n    } else {\n      opts = arg2 as SpanOptions | undefined;\n      ctx = arg3 as Context | undefined;\n      fn = arg4 as F;\n    }\n\n    const parentContext = ctx ?? contextApi.active();\n    const span = this.startSpan(name, opts, parentContext);\n    const contextWithSpanSet = setSpan(parentContext, span);\n\n    return contextApi.with(contextWithSpanSet, fn, undefined, span);\n  }\n}\n\nfunction isSpanContext(spanContext: any): spanContext is SpanContext {\n  return (\n    typeof spanContext === 'object' &&\n    typeof spanContext['spanId'] === 'string' &&\n    typeof spanContext['traceId'] === 'string' &&\n    typeof spanContext['traceFlags'] === 'number'\n  );\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Context } from '../context/types';\nimport { NoopTracer } from './NoopTracer';\nimport { Span } from './span';\nimport { SpanOptions } from './SpanOptions';\nimport { Tracer } from './tracer';\nimport { TracerOptions } from './tracer_options';\n\nconst NOOP_TRACER = new NoopTracer();\n\n/**\n * Proxy tracer provided by the proxy tracer provider\n */\nexport class ProxyTracer implements Tracer {\n  // When a real implementation is provided, this will be it\n  private _delegate?: Tracer;\n\n  constructor(\n    private _provider: TracerDelegator,\n    public readonly name: string,\n    public readonly version?: string,\n    public readonly options?: TracerOptions\n  ) {}\n\n  startSpan(name: string, options?: SpanOptions, context?: Context): Span {\n    return this._getTracer().startSpan(name, options, context);\n  }\n\n  startActiveSpan<F extends (span: Span) => unknown>(\n    _name: string,\n    _options: F | SpanOptions,\n    _context?: F | Context,\n    _fn?: F\n  ): ReturnType<F> {\n    const tracer = this._getTracer();\n    return Reflect.apply(tracer.startActiveSpan, tracer, arguments);\n  }\n\n  /**\n   * Try to get a tracer from the proxy tracer provider.\n   * If the proxy tracer provider has no delegate, return a noop tracer.\n   */\n  private _getTracer() {\n    if (this._delegate) {\n      return this._delegate;\n    }\n\n    const tracer = this._provider.getDelegateTracer(\n      this.name,\n      this.version,\n      this.options\n    );\n\n    if (!tracer) {\n      return NOOP_TRACER;\n    }\n\n    this._delegate = tracer;\n    return this._delegate;\n  }\n}\n\nexport interface TracerDelegator {\n  getDelegateTracer(\n    name: string,\n    version?: string,\n    options?: TracerOptions\n  ): Tracer | undefined;\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { NoopTracer } from './NoopTracer';\nimport { Tracer } from './tracer';\nimport { TracerOptions } from './tracer_options';\nimport { TracerProvider } from './tracer_provider';\n\n/**\n * An implementation of the {@link TracerProvider} which returns an impotent\n * Tracer for all calls to `getTracer`.\n *\n * All operations are no-op.\n */\nexport class NoopTracerProvider implements TracerProvider {\n  getTracer(\n    _name?: string,\n    _version?: string,\n    _options?: TracerOptions\n  ): Tracer {\n    return new NoopTracer();\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Tracer } from './tracer';\nimport { TracerProvider } from './tracer_provider';\nimport { ProxyTracer } from './ProxyTracer';\nimport { NoopTracerProvider } from './NoopTracerProvider';\nimport { TracerOptions } from './tracer_options';\n\nconst NOOP_TRACER_PROVIDER = new NoopTracerProvider();\n\n/**\n * Tracer provider which provides {@link ProxyTracer}s.\n *\n * Before a delegate is set, tracers provided are NoOp.\n *   When a delegate is set, traces are provided from the delegate.\n *   When a delegate is set after tracers have already been provided,\n *   all tracers already provided will use the provided delegate implementation.\n */\nexport class ProxyTracerProvider implements TracerProvider {\n  private _delegate?: TracerProvider;\n\n  /**\n   * Get a {@link ProxyTracer}\n   */\n  getTracer(name: string, version?: string, options?: TracerOptions): Tracer {\n    return (\n      this.getDelegateTracer(name, version, options) ??\n      new ProxyTracer(this, name, version, options)\n    );\n  }\n\n  getDelegate(): TracerProvider {\n    return this._delegate ?? NOOP_TRACER_PROVIDER;\n  }\n\n  /**\n   * Set the delegate tracer provider\n   */\n  setDelegate(delegate: TracerProvider) {\n    this._delegate = delegate;\n  }\n\n  getDelegateTracer(\n    name: string,\n    version?: string,\n    options?: TracerOptions\n  ): Tracer | undefined {\n    return this._delegate?.getTracer(name, version, options);\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport interface SpanStatus {\n  /** The status code of this message. */\n  code: SpanStatusCode;\n  /** A developer-facing error message. */\n  message?: string;\n}\n\n/**\n * An enumeration of status codes.\n */\nexport enum SpanStatusCode {\n  /**\n   * The default status.\n   */\n  UNSET = 0,\n  /**\n   * The operation has been validated by an Application developer or\n   * Operator to have completed successfully.\n   */\n  OK = 1,\n  /**\n   * The operation contains an error.\n   */\n  ERROR = 2,\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  getGlobal,\n  registerGlobal,\n  unregisterGlobal,\n} from '../internal/global-utils';\nimport { ProxyTracerProvider } from '../trace/ProxyTracerProvider';\nimport {\n  isSpanContextValid,\n  wrapSpanContext,\n} from '../trace/spancontext-utils';\nimport { Tracer } from '../trace/tracer';\nimport { TracerProvider } from '../trace/tracer_provider';\nimport {\n  deleteSpan,\n  getActiveSpan,\n  getSpan,\n  getSpanContext,\n  setSpan,\n  setSpanContext,\n} from '../trace/context-utils';\nimport { DiagAPI } from './diag';\n\nconst API_NAME = 'trace';\n\n/**\n * Singleton object which represents the entry point to the OpenTelemetry Tracing API\n */\nexport class TraceAPI {\n  private static _instance?: TraceAPI;\n\n  private _proxyTracerProvider = new ProxyTracerProvider();\n\n  /** Empty private constructor prevents end users from constructing a new instance of the API */\n  private constructor() {}\n\n  /** Get the singleton instance of the Trace API */\n  public static getInstance(): TraceAPI {\n    if (!this._instance) {\n      this._instance = new TraceAPI();\n    }\n\n    return this._instance;\n  }\n\n  /**\n   * Set the current global tracer.\n   *\n   * @returns true if the tracer provider was successfully registered, else false\n   */\n  public setGlobalTracerProvider(provider: TracerProvider): boolean {\n    const success = registerGlobal(\n      API_NAME,\n      this._proxyTracerProvider,\n      DiagAPI.instance()\n    );\n    if (success) {\n      this._proxyTracerProvider.setDelegate(provider);\n    }\n    return success;\n  }\n\n  /**\n   * Returns the global tracer provider.\n   */\n  public getTracerProvider(): TracerProvider {\n    return getGlobal(API_NAME) || this._proxyTracerProvider;\n  }\n\n  /**\n   * Returns a tracer from the global tracer provider.\n   */\n  public getTracer(name: string, version?: string): Tracer {\n    return this.getTracerProvider().getTracer(name, version);\n  }\n\n  /** Remove the global tracer provider */\n  public disable() {\n    unregisterGlobal(API_NAME, DiagAPI.instance());\n    this._proxyTracerProvider = new ProxyTracerProvider();\n  }\n\n  public wrapSpanContext = wrapSpanContext;\n\n  public isSpanContextValid = isSpanContextValid;\n\n  public deleteSpan = deleteSpan;\n\n  public getSpan = getSpan;\n\n  public getActiveSpan = getActiveSpan;\n\n  public getSpanContext = getSpanContext;\n\n  public setSpan = setSpan;\n\n  public setSpanContext = setSpanContext;\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// Split module-level variable definition into separate files to allow\n// tree-shaking on each api instance.\nimport { TraceAPI } from './api/trace';\n/** Entrypoint for trace API */\nexport const trace = TraceAPI.getInstance();\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport { BaggageEntry, BaggageEntryMetadata, Baggage } from './baggage/types';\nexport { baggageEntryMetadataFromString } from './baggage/utils';\nexport { Exception } from './common/Exception';\nexport { HrTime, TimeInput } from './common/Time';\nexport { Attributes, AttributeValue } from './common/Attributes';\n\n// Context APIs\nexport { createContextKey, ROOT_CONTEXT } from './context/context';\nexport { Context, ContextManager } from './context/types';\nexport type { ContextAPI } from './api/context';\n\n// Diag APIs\nexport { DiagConsoleLogger } from './diag/consoleLogger';\nexport {\n  DiagLogFunction,\n  DiagLogger,\n  DiagLogLevel,\n  ComponentLoggerOptions,\n  DiagLoggerOptions,\n} from './diag/types';\nexport type { DiagAPI } from './api/diag';\n\n// Metrics APIs\nexport { createNoopMeter } from './metrics/NoopMeter';\nexport { MeterOptions, Meter } from './metrics/Meter';\nexport { MeterProvider } from './metrics/MeterProvider';\nexport {\n  ValueType,\n  Counter,\n  Histogram,\n  MetricOptions,\n  Observable,\n  ObservableCounter,\n  ObservableGauge,\n  ObservableUpDownCounter,\n  UpDownCounter,\n  BatchObservableCallback,\n  MetricAdvice,\n  MetricAttributes,\n  MetricAttributeValue,\n  ObservableCallback,\n} from './metrics/Metric';\nexport {\n  BatchObservableResult,\n  ObservableResult,\n} from './metrics/ObservableResult';\nexport type { MetricsAPI } from './api/metrics';\n\n// Propagation APIs\nexport {\n  TextMapPropagator,\n  TextMapSetter,\n  TextMapGetter,\n  defaultTextMapGetter,\n  defaultTextMapSetter,\n} from './propagation/TextMapPropagator';\nexport type { PropagationAPI } from './api/propagation';\n\n// Trace APIs\nexport { SpanAttributes, SpanAttributeValue } from './trace/attributes';\nexport { Link } from './trace/link';\nexport { ProxyTracer, TracerDelegator } from './trace/ProxyTracer';\nexport { ProxyTracerProvider } from './trace/ProxyTracerProvider';\nexport { Sampler } from './trace/Sampler';\nexport { SamplingDecision, SamplingResult } from './trace/SamplingResult';\nexport { SpanContext } from './trace/span_context';\nexport { SpanKind } from './trace/span_kind';\nexport { Span } from './trace/span';\nexport { SpanOptions } from './trace/SpanOptions';\nexport { SpanStatus, SpanStatusCode } from './trace/status';\nexport { TraceFlags } from './trace/trace_flags';\nexport { TraceState } from './trace/trace_state';\nexport { createTraceState } from './trace/internal/utils';\nexport { TracerProvider } from './trace/tracer_provider';\nexport { Tracer } from './trace/tracer';\nexport { TracerOptions } from './trace/tracer_options';\nexport {\n  isSpanContextValid,\n  isValidTraceId,\n  isValidSpanId,\n} from './trace/spancontext-utils';\nexport {\n  INVALID_SPANID,\n  INVALID_TRACEID,\n  INVALID_SPAN_CONTEXT,\n} from './trace/invalid-span-constants';\nexport type { TraceAPI } from './api/trace';\n\n// Split module-level variable definition into separate files to allow\n// tree-shaking on each api instance.\nimport { context } from './context-api';\nimport { diag } from './diag-api';\nimport { metrics } from './metrics-api';\nimport { propagation } from './propagation-api';\nimport { trace } from './trace-api';\n\n// Named export.\nexport { context, diag, metrics, propagation, trace };\n// Default export.\nexport default {\n  context,\n  diag,\n  metrics,\n  propagation,\n  trace,\n};\n", "import { ZuploEventContext } from \"../interfaces\";\n\n/**\n * @internal\n */\nexport type RequestHandlerProxy = (\n  inner: RequestHandlerFunction\n) => RequestHandlerFunction;\n\n/**\n * @internal\n */\nexport type RequestHandlerFunction = (\n  request: Request,\n  event: ZuploEventContext\n) => Promise<Response>;\n\nlet globalRequestHandlerProxy: RequestHandlerProxy =\n  (inner) => (request, event) => {\n    return inner(request, event);\n  };\n\nexport function setTelemetryInitFunction(\n  requestHandlerProxy: RequestHandlerProxy\n) {\n  globalRequestHandlerProxy = requestHandlerProxy;\n}\n\nexport const proxyHandler = (wrapped: RequestHandlerFunction) => {\n  return globalRequestHandlerProxy(wrapped);\n};\n", "// For clean signature purposes only\n\nimport { RequestHandlerProxy } from \"../diagnostics/telemetry\";\nimport { RuntimeExtensions } from \"../extensions\";\nimport { Gateway } from \"../gateway\";\nimport { LoggingEnvironmentStage, LoggingEnvironmentType } from \"../interfaces\";\nimport { Router } from \"../router/router\";\n\n/**\n * @public\n */\nexport abstract class RuntimePlugin {}\n\n/**\n * @public\n */\nexport interface InitializableRuntimePlugin {}\n\n/**\n * @public\n */\nexport interface RoutableRuntimePlugin {}\n\n/**\n * Plugins for registering system capabilities\n * @public\n */\nexport abstract class SystemRuntimePlugin extends RuntimePlugin {\n  /**\n   * @internal\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  async initialize(runtimeInit: RuntimeExtensions): Promise<void> {\n    return Promise.resolve();\n  }\n\n  /**\n   * @internal\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  registerRoutes(router: Router, gateway: Gateway): void {\n    // no-op\n  }\n}\n\n/**\n * Base class for determining type of plugin\n * @public\n */\nexport abstract class MeteringPlugin extends SystemRuntimePlugin {}\n\n/**\n * Represents the environment configuration for the Zuplo runtime.\n * @internal\n */\nexport interface TelemetryInitializationOptions {\n  accountName: string | undefined;\n  projectName: string | undefined;\n  deploymentName: string | undefined;\n  buildId: string;\n  zuploVersion: string;\n  compatibilityDate: string | undefined;\n  instanceId: string;\n  environmentType: LoggingEnvironmentType;\n  environmentStage: LoggingEnvironmentStage;\n}\n\n/**\n * Base class for determining type of plugin\n * @public\n */\nexport abstract class TelemetryPlugin extends RuntimePlugin {\n  /**\n   * @internal\n   */\n  abstract instrument(init: TelemetryInitializationOptions): {\n    requestHandlerProxy: RequestHandlerProxy;\n  };\n}\n", "import { RuntimeError } from \"../errors\";\nimport { ZuploContext } from \"../index.worker\";\nimport { ZuploRequest } from \"../request\";\nimport { ProblemResponseDetails } from \"./problem\";\n\n/**\n * @beta\n */\nexport interface ProblemResponseFormat {\n  (\n    problemDetails: ProblemResponseDetails,\n    request: ZuploRequest,\n    context: ZuploContext\n  ): Promise<Response> | Response;\n}\n\nexport class InternalProblemResponseFormatter {\n  static problemResponseFormat: ProblemResponseFormat = async (\n    problemContext\n  ) => {\n    const data = problemContext.problem;\n\n    const content = JSON.stringify(data, null, 2);\n\n    return new Response(content, {\n      status: problemContext.problem.status,\n      statusText: problemContext.statusText,\n      headers: {\n        ...problemContext.additionalHeaders,\n        \"content-type\": \"application/problem+json\",\n      },\n    });\n  };\n\n  static setProblemResponseFormat(formatter?: ProblemResponseFormat) {\n    if (formatter) {\n      InternalProblemResponseFormatter.problemResponseFormat = (\n        problemDetails,\n        request,\n        context\n      ) => {\n        try {\n          return formatter(problemDetails, request, context);\n        } catch (err) {\n          throw new RuntimeError(`Error in custom 'problemResponseFormat'`, {\n            cause: err,\n          });\n        }\n      };\n    }\n  }\n}\n\n/**\n * @beta\n */\nexport class ProblemResponseFormatter {\n  static async format(\n    problemDetails: ProblemResponseDetails,\n    request: ZuploRequest,\n    context: ZuploContext\n  ): Promise<Response> {\n    return await InternalProblemResponseFormatter.problemResponseFormat(\n      problemDetails,\n      request,\n      context\n    );\n  }\n}\n", "/**\n * WARNING: BE EXTREMELY CAREFUL WHEN USING THIS. IT SHOULD BE USED\n * SPARINGLY. THIS CAN HAVE MASSIVE PERFORMANCE PENALTIES\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function deepFreeze<T = any>(object: T): Readonly<T> {\n  for (const name in object) {\n    const value = object[name];\n    if (value && typeof value === \"object\") {\n      deepFreeze(value);\n    }\n  }\n  return Object.freeze<T>(object);\n}\n", "import { deepFreeze } from \"./utils/freeze\";\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype UserDataDefault = any;\ntype RequestParamsDefault = Record<string, string>;\ntype RequestQueryDefault = Record<string, string>;\n\n// These are utility types that resolve the type on optional generics\ntype ResolveUserData<TUserData extends UserDataDefault | undefined> =\n  TUserData extends UserDataDefault ? TUserData : UserDataDefault;\ntype ResolveRequestParams<TParams extends RequestParamsDefault | undefined> =\n  TParams extends RequestParamsDefault ? TParams : RequestParamsDefault;\ntype ResolveRequestQuery<TQuery extends RequestQueryDefault | undefined> =\n  TQuery extends RequestQueryDefault ? TQuery : RequestQueryDefault;\n\n/**\n * The types of the properties in a request init object\n * @public\n */\nexport interface RequestInitGeneric {\n  // NOTE: These props uppercase base this is a type only interface.\n  // This isn't a \"date\" interface, but rather a type of a generic.\n  UserData?: UserDataDefault;\n  Params?: RequestParamsDefault;\n}\n\n/**\n * The types of the properties in a request\n * @public\n */\nexport interface RequestGeneric extends RequestInitGeneric {\n  // NOTE: These props uppercase base this is a type only interface.\n  // This isn't a \"date\" interface, but rather a type of a generic.\n  Query?: RequestQueryDefault;\n}\n\n/**\n * The authorized identity on the incoming request\n * @public\n */\nexport interface RequestUser<TUserData> {\n  sub: string;\n  data: TUserData;\n}\n\n/**\n * @internal\n */\nexport interface RequestProcessingStrategy {\n  processRequest(\n    request: ZuploRequest,\n    func: () => Promise<Response>\n  ): Promise<Response>;\n}\n\n/**\n * The initialization values of a request\n * @public\n */\nexport interface ZuploRequestInit<\n  TOptions extends RequestInitGeneric = RequestInitGeneric,\n> extends RequestInit {\n  params?: ResolveRequestParams<TOptions[\"Params\"]>;\n  user?: ResolveUserData<TOptions[\"UserData\"]>;\n}\n\n/**\n * ZuploRequest includes various parsed objects from the\n * incoming Request. This object inherits from the web\n * standard {@link https://developer.mozilla.org/en-US/docs/Web/API/Request | Request}.\n * @public\n */\nexport class ZuploRequest<\n  TOptions extends RequestGeneric = RequestGeneric,\n> extends Request {\n  #query?: ResolveRequestQuery<TOptions[\"Query\"]> = undefined;\n  #params: ResolveRequestParams<TOptions[\"Params\"]>;\n\n  constructor(input: string | Request, init?: ZuploRequestInit<TOptions>) {\n    super(input, init);\n    const params = init?.params;\n\n    // if params are specified, they override everything - this is consistent with how\n    // other init properties work on web standards, request\n    if (params) {\n      this.#params = params;\n    } else if (input instanceof ZuploRequest) {\n      this.#params = input.#params;\n    } else {\n      this.#params = {} as ResolveRequestParams<TOptions[\"Params\"]>; // is not optional\n    }\n\n    const user = init?.user;\n    if (user) {\n      this.user = user;\n    } else if (input instanceof ZuploRequest) {\n      this.user = input.user;\n    }\n  }\n\n  /**\n   * A dictionary of query-string values\n   *\n   * @example\n   * The url `https://example.com?foo=bar` would return\n   * the following query object:\n   *\n   * ```\n   * const foo = request.query.foo;\n   * ```\n   *\n   * @readonly\n   */\n  get query(): Readonly<ResolveRequestQuery<TOptions[\"Query\"]>> {\n    // lazily parse the QueryString, no need to do this unless it's being accessed\n    if (this.#query === undefined) {\n      const query: RequestQueryDefault = {};\n\n      const searchParams = new URL(this.url).searchParams;\n\n      for (const [key, value] of searchParams.entries()) {\n        query[key] = value;\n      }\n      this.#query = query as ResolveRequestQuery<TOptions[\"Query\"]>;\n    }\n\n    return deepFreeze(this.#query as ResolveRequestQuery<TOptions[\"Query\"]>);\n  }\n\n  /**\n   * If you use tokens in your route\u2019s URL, they are\n   * automatically parsed into properties on the params\n   * property of your request.\n   *\n   * @example\n   * The route `/products/:productId/vendors/:vendorId`\n   * would include two params:\n   *\n   * ```\n   * const productId = request.params.productId;\n   * const vendorId = request.params.vendorId;\n   * ```\n   * @readonly\n   */\n  get params(): Readonly<ResolveRequestParams<TOptions[\"Params\"]>> {\n    return deepFreeze(this.#params);\n  }\n\n  /**\n   * An optional object identifying a \u2018user\u2019.\n   *\n   * @remarks\n   * If undefined this typically means the request is\n   * anonymous. If present, the user object will have\n   * a sub property that is a unique identifier for\n   * that user. There is also an optional data property\n   * that is of any type that typically contains other\n   * information about the user. When using JWT tokens\n   * you\u2019ll usually find all the claims here.\n   *\n   * @readonly\n   */\n  user?: RequestUser<ResolveUserData<TOptions[\"UserData\"]>>;\n}\n", "/* eslint-disable @typescript-eslint/no-empty-function */\nimport { SpanStatusCode, trace } from \"@opentelemetry/api\";\nimport { ZuploContext } from \"./context\";\nimport { setTelemetryInitFunction } from \"./diagnostics/telemetry\";\nimport { ConfigurationError } from \"./errors\";\nimport {\n  RuntimePlugin,\n  SystemRuntimePlugin,\n  TelemetryPlugin,\n} from \"./plugins/plugins\";\n\nimport {\n  InternalProblemResponseFormatter,\n  ProblemResponseFormat,\n} from \"./problem-responses/problem-response-formatter\";\nimport { ZuploRequest } from \"./request\";\nimport { RouteConfiguration } from \"./router/interfaces.custom\";\nimport { Environment } from \"./utils/environment\";\n\nexport interface NotFoundOptions {\n  routesMatchedByPathOnly: RouteConfiguration[];\n}\n\n/**\n * Zuplo global runtime customization\n * @beta\n */\nexport interface RuntimeExtensions {\n  /**\n   * Custom response formatter\n   */\n  problemResponseFormat?: ProblemResponseFormat;\n  /**\n   * Register runtime plugins\n   */\n  addPlugin: (plugin: RuntimePlugin) => void;\n\n  /**\n   * Set a custom not found handler\n   */\n  notFoundHandler?: (\n    request: ZuploRequest,\n    context: ZuploContext,\n    notFoundOptions: NotFoundOptions\n  ) => Promise<Response>;\n\n  addRequestHook(hook: OnRequestHook): void;\n  addResponseSendingHook(hook: OnResponseSendingHook): void;\n  addResponseSendingFinalHook(hook: OnResponseSendingFinalHook): void;\n}\n\nexport interface RuntimeExtensionsFunction {\n  (runtime: RuntimeExtensions): Promise<void>;\n}\n\n/**\n * @public\n */\nexport interface OnRequestHook {\n  (\n    request: ZuploRequest,\n    context: ZuploContext\n  ): Promise<ZuploRequest | Response> | (ZuploRequest | Response);\n}\n\n/**\n * @public\n */\nexport interface OnResponseSendingHook {\n  (\n    response: Response,\n    request: ZuploRequest,\n    context: ZuploContext\n  ): Promise<Response> | Response;\n}\n\n/**\n * @public\n */\nexport interface OnResponseSendingFinalHook {\n  (\n    response: Response,\n    request: ZuploRequest,\n    context: ZuploContext\n  ): Promise<void> | void;\n}\n\n// plugins\nexport const runtimeExtensions: { value?: RuntimeExtensions } = {};\nconst plugins: RuntimePlugin[] = [];\nconst requestHooks: OnRequestHook[] = [];\nconst responseSendingHooks: OnResponseSendingHook[] = [];\nconst responseSendingFinalHooks: OnResponseSendingFinalHook[] = [];\n\n// Export each hook that is callable internally\nexport { plugins };\n\n// This is the facade that is exposed to the user through\n// the runtime registration.\nconst extensions: RuntimeExtensions = {\n  addPlugin(plugin: RuntimePlugin) {\n    plugins.push(plugin);\n  },\n  addRequestHook(hook) {\n    requestHooks.push(hook);\n  },\n  addResponseSendingHook(hook) {\n    responseSendingHooks.push(hook);\n  },\n  addResponseSendingFinalHook(hook) {\n    responseSendingFinalHooks.push(hook);\n  },\n};\n\nexport const invokeOnRequestExtensions: OnRequestHook = async (\n  request,\n  context\n) => {\n  if (requestHooks.length === 0) {\n    return request;\n  }\n  const tracer = trace.getTracer(\"extension\");\n  return tracer.startActiveSpan(\"hook:onRequest\", async (span) => {\n    try {\n      let latestResult: ZuploRequest = request;\n      for (const hook of requestHooks) {\n        const localResult = await tracer.startActiveSpan(\n          hook.name,\n          async (localSpan) => {\n            // User code so casting to unknown as we can't guarantee\n            const localResult: unknown = await hook(latestResult, context);\n            if (\n              localResult instanceof ZuploRequest ||\n              localResult instanceof Response\n            ) {\n              localSpan.end();\n              return localResult;\n            } else {\n              const error = new ConfigurationError(\n                `Invalid state - the OnRequest hook must return a ZuploRequest or Response. Received ${typeof latestResult}.`\n              );\n              localSpan.end();\n              localSpan.recordException(error);\n              localSpan.setStatus({ code: SpanStatusCode.ERROR });\n              throw error;\n            }\n          }\n        );\n\n        if (localResult instanceof ZuploRequest) {\n          latestResult = localResult;\n        } else {\n          return localResult;\n        }\n      }\n      return latestResult;\n    } finally {\n      span.end();\n    }\n  });\n};\n\nexport const invokeOnResponseSendingExtensions: OnResponseSendingHook = async (\n  response,\n  latestRequest,\n  context\n) => {\n  if (responseSendingHooks.length === 0) {\n    return response;\n  }\n  const tracer = trace.getTracer(\"extension\");\n  return tracer.startActiveSpan(\"hook:onResponseSending\", async (span) => {\n    try {\n      let latestResult: Response = response;\n      for (const hook of responseSendingHooks) {\n        await tracer.startActiveSpan(hook.name, async (localSpan) => {\n          // User code so casting to unknown as we can't guarantee\n          const localResult: unknown = await hook(\n            response,\n            latestRequest,\n            context\n          );\n          if (localResult instanceof Response) {\n            latestResult = localResult;\n            localSpan.end();\n          } else {\n            const error = new ConfigurationError(\n              `Invalid state - the OnResponseSending hook must return a Response. Received ${typeof latestResult}.`\n            );\n            localSpan.recordException(error);\n            localSpan.setStatus({ code: SpanStatusCode.ERROR });\n            localSpan.end();\n            throw error;\n          }\n        });\n      }\n      return latestResult;\n    } finally {\n      span.end();\n    }\n  });\n};\n\nexport const invokeOnResponseSendingFinalExtensions: OnResponseSendingFinalHook =\n  async (response, latestRequest, context) => {\n    if (responseSendingFinalHooks.length === 0) {\n      return;\n    }\n    const tracer = trace.getTracer(\"extension\");\n    return tracer.startActiveSpan(\n      \"hook:onResponseSendingFinal\",\n      async (span) => {\n        try {\n          for (const hook of responseSendingFinalHooks) {\n            await tracer.startActiveSpan(hook.name, async (localSpan) => {\n              try {\n                await hook(response, latestRequest, context);\n              } catch (err) {\n                localSpan.recordException(err);\n                localSpan.setStatus({ code: SpanStatusCode.ERROR });\n                localSpan.end();\n                throw err;\n              }\n              localSpan.end();\n            });\n          }\n        } finally {\n          span.end();\n        }\n      }\n    );\n  };\n\nlet isInitialized = false;\n\n/**\n * @internal\n * @param setup - The user provided setup function\n */\nexport async function initializeRuntime(\n  // eslint-disable-next-line @typescript-eslint/no-empty-function\n  runtimeInit: RuntimeExtensionsFunction = () => {\n    return Promise.resolve();\n  }\n) {\n  if (!isInitialized) {\n    await runtimeInit(extensions);\n    runtimeExtensions.value = extensions;\n\n    // Register plugin routes\n    for (const plugin of plugins) {\n      if (plugin instanceof TelemetryPlugin) {\n        // WARNING: Do not just pass Environment.instance to the plugin\n        // this will expose internal variables and CF bindings to the plugin\n        // which can be implemented by a user. Only copy the required fields.\n        const { requestHandlerProxy } = plugin.instrument({\n          accountName: Environment.instance.build.ACCOUNT_NAME,\n          projectName: Environment.instance.build.PROJECT_NAME,\n          buildId: Environment.instance.build.BUILD_ID,\n          zuploVersion: Environment.instance.build.ZUPLO_VERSION,\n          compatibilityDate: Environment.instance.build.COMPATIBILITY_DATE,\n          instanceId: Environment.instance.instanceId,\n          environmentType: Environment.instance.loggingEnvironmentType,\n          environmentStage: Environment.instance.loggingEnvironmentStage,\n          deploymentName: Environment.instance.deploymentName,\n        });\n        setTelemetryInitFunction(requestHandlerProxy);\n      }\n    }\n\n    // initialize plugins\n    for (const plugin of plugins) {\n      if (plugin instanceof SystemRuntimePlugin) {\n        await plugin.initialize(extensions);\n      }\n    }\n\n    // Additional internal initializers goes here\n    InternalProblemResponseFormatter.setProblemResponseFormat(\n      extensions.problemResponseFormat\n    );\n    isInitialized = true;\n  }\n}\n", "/**\n * @internal\n */\nexport const ContentTypes = {\n  Json: \"application/json\",\n  Form: \"application/x-www-form-urlencoded\",\n};\n\n/**\n * @internal\n * @param payload - The payload to be serialized\n * @param contentType - The content type to serialize\n * @returns\n */\nexport function serialize(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  payload: any,\n  contentType?: string\n): BodyInit | undefined | string {\n  // Serialization rules\n  // if the user sets the content-type it rules, no overrides\n  // if the content-type is set and we see an 'object', we will attempt to encode\n  // for JSON or FORM encoding. Everything else we just return as is.\n  // If there is no content-type set and the payload exists we will assume\n  // JSON and serialize, even if the payload is a string.\n\n  if (payload === null) {\n    return undefined;\n  }\n\n  // If the content type is specified and the value is a string, we just return\n  if (contentType && typeof payload === \"string\") {\n    return payload;\n  }\n\n  // FORM encoding\n  if (\n    typeof payload === \"object\" &&\n    contentType?.startsWith(ContentTypes.Form)\n  ) {\n    const form = new URLSearchParams(payload as Record<string, string>);\n    return form.toString();\n  }\n\n  // JSON encoding\n  if (\n    (typeof payload === \"object\" &&\n      contentType?.startsWith(ContentTypes.Json)) ||\n    !contentType\n  ) {\n    const json = JSON.stringify(payload);\n    return json;\n  }\n\n  // by this point we have an non JSON/FORM content-type and a non-string object, just send it out..\n  return payload;\n}\n", "import { Gateway } from \"../gateway\";\n\n/**\n * Determines if the current URL is a system path or not\n * @param url - The Request url\n * @returns True if the url is a system path, otherwise false.\n * @internal\n */\nexport function isSystemRoute(url: URL) {\n  const isDevPortalUrl =\n    Gateway.instance.runtimeSettings.developerPortal.enabled &&\n    url.pathname.startsWith(\n      Gateway.instance.runtimeSettings.developerPortal.sitePathname\n    );\n  return (\n    isDevPortalUrl ||\n    url.pathname.startsWith(\"/__zuplo/\") ||\n    url.pathname.startsWith(\"/__/zuplo/\")\n  );\n}\n", "import { SpanStatusCode, trace } from \"@opentelemetry/api\";\nimport {\n  ResponseSendingEvent,\n  ResponseSentEvent,\n  ZuploContext,\n  ZuploContextExtensions,\n} from \"./context\";\nimport {\n  invokeOnResponseSendingExtensions,\n  invokeOnResponseSendingFinalExtensions,\n} from \"./extensions\";\nimport { Gateway } from \"./gateway\";\nimport { RequestProcessor } from \"./interfaces\";\nimport { ZuploRequest } from \"./request\";\nimport { RouteHandler } from \"./router/router\";\nimport { serialize } from \"./serializer\";\nimport { Environment } from \"./utils/environment\";\nimport { isSystemRoute } from \"./utils/system-routes\";\n/**\n * The options for the pipeline\n */\ninterface PipelineOptions {\n  processors: RequestProcessor[];\n  handler: RouteHandler;\n  gateway: Gateway;\n}\n\n/**\n * @internal\n */\nexport class Pipeline {\n  constructor(options: PipelineOptions) {\n    this.execute = this.#toZuploPipeline(options);\n  }\n\n  execute: RouteHandler;\n\n  #errorWrappedHandler = <T>(handler: RouteHandler<T>, gateway: Gateway) => {\n    return async (request: ZuploRequest, context: ZuploContext) => {\n      const tracer = trace.getTracer(\"pipeline\");\n      return tracer.startActiveSpan(\n        `handler:${context.route.handler.export}`,\n        async (span) => {\n          try {\n            const response = await handler(request, context);\n\n            return response;\n          } catch (err) {\n            context.log.error(\"Error executing request handler.\", err);\n            const response = gateway.errorHandler(request, context, err);\n            span.setStatus({ code: SpanStatusCode.ERROR });\n            return response;\n          } finally {\n            span.end();\n          }\n        }\n      );\n    };\n  };\n\n  #toZuploPipeline = ({\n    processors,\n    gateway,\n    handler,\n  }: PipelineOptions): RouteHandler => {\n    return async (request: ZuploRequest, context: ZuploContext) => {\n      const localPipeline = [...processors];\n      const nextPipe = async (innerRequest: ZuploRequest) => {\n        const next = localPipeline.pop();\n        if (!next) {\n          const wrapped = this.#errorWrappedHandler(async (req) => {\n            const innerResult = await handler(req, context);\n            return resultToResponse(innerResult);\n          }, gateway);\n\n          const response = await wrapped(innerRequest, context);\n          return response;\n        }\n        return next(request, context, gateway, nextPipe);\n      };\n      const result = await nextPipe(request);\n      const response = result as Response;\n\n      // For system routes, we don't go any further\n      // No hooks on system routes after compatibility date\n      const url = new URL(request.url);\n      if (\n        isSystemRoute(url) &&\n        Environment.instance.build.COMPATIBILITY_FLAGS\n          .doNotRunHooksOnSystemRoutes\n      ) {\n        return response;\n      }\n\n      // === onResponseSending / responseSending hooks ===\n      // this allows mutation\n\n      // Legacy, use hooks instead. Here for backward compatibility\n      const responseSending = new ResponseSendingEvent(request, response);\n      context.dispatchEvent(responseSending);\n\n      const contextExtension =\n        ZuploContextExtensions.getContextExtensions(context);\n\n      const latestRequest = contextExtension.latestRequest;\n\n      let newResponse: Response;\n      try {\n        newResponse = await responseSending.mutableResponse;\n      } catch (err) {\n        context.log.error(err);\n        return gateway.errorHandler(request, context, err);\n      }\n\n      try {\n        newResponse = await contextExtension.onResponseSending(\n          newResponse,\n          latestRequest,\n          context\n        );\n      } catch (err) {\n        context.log.error(\n          `Error invoking 'context.onResponseSending' hook: '${err.message}'`,\n          err\n        );\n        return gateway.errorHandler(request, context, err);\n      }\n\n      try {\n        newResponse = await invokeOnResponseSendingExtensions(\n          newResponse,\n          latestRequest,\n          context\n        );\n      } catch (err) {\n        context.log.error(\n          `Error invoking 'context.onResponseSending' hook: '${err.message}'`,\n          err\n        );\n        return gateway.errorHandler(request, context, err);\n      }\n\n      // === onResponseSendingFinal / responseSent hooks ===\n      // this allows mutation\n\n      // TODO: Legacy, remove with compatibility date soon\n      context.dispatchEvent(new ResponseSentEvent(request, newResponse));\n\n      try {\n        await contextExtension.onResponseSendingFinal(\n          response,\n          latestRequest,\n          context\n        );\n      } catch (err) {\n        context.log.error(\n          `Error invoking 'runtime.onResponseSending' hook: '${err.message}'`,\n          err\n        );\n        throw err;\n      }\n\n      try {\n        await invokeOnResponseSendingFinalExtensions(\n          response,\n          latestRequest,\n          context\n        );\n      } catch (err) {\n        context.log.error(\n          `Error invoking 'runtime.onResponseSending' hook: '${err.message}'`,\n          err\n        );\n        throw err;\n      }\n\n      return newResponse;\n    };\n  };\n}\n\nfunction resultToResponse(result: unknown): Response {\n  if (result instanceof Response) {\n    return result;\n  }\n\n  if (typeof result === \"undefined\") {\n    return new Response();\n  }\n\n  // else go with JSON response\n  return new Response(serialize(result), {\n    headers: {\n      \"content-type\": \"application/json\",\n    },\n  });\n}\n", "import { RuntimePlugin } from \"../../plugins/plugins\";\nimport { MetricsTransport } from \"./interfaces\";\n\nexport abstract class MetricsPlugin extends RuntimePlugin {\n  /**\n   * @internal\n   */\n  abstract getTransport(): MetricsTransport;\n}\n", "import { ZuploContext } from \"./context\";\nimport { SystemError } from \"./errors\";\nimport { Logger } from \"./logging/interfaces\";\n\n/**\n * @internal\n */\nexport class SystemLogMap {\n  static #map = new WeakMap<ZuploContext, Logger>();\n\n  static getLogger(context: ZuploContext): Logger {\n    const logger = SystemLogMap.#map.get(context);\n    if (!logger) {\n      const message = `No system logger found for context with requestId '${context.requestId}'`;\n      // using console as no system logger available if maps aren't working\n      // eslint-disable-next-line no-console\n      console.error(message);\n      // TODO - let's return a new logger if none found, that's safest. For now, just throw\n      throw new SystemError(message);\n    }\n    return logger;\n  }\n\n  static addLogger(context: ZuploContext, logger: Logger) {\n    SystemLogMap.#map.set(context, logger);\n  }\n}\n", "import { Logger } from \"../logging/interfaces\";\n\n/**\n * @public\n */\nexport type DispatchFunction<TPayload> = (batch: TPayload[]) => Promise<void>;\n\n/**\n * @internal\n */\nexport class BatchDispatch<TPayload> {\n  constructor(\n    dispatcherName: string,\n    msDelay: number,\n    dispatchFunction: DispatchFunction<TPayload>,\n    systemLogger?: Logger\n  ) {\n    this.#dispatcherName = dispatcherName;\n    this.#msDelay = msDelay;\n    this.#dispatchFunction = dispatchFunction;\n    // Log to either the system logger or fallback to worker tracing\n    this.#systemLogger = systemLogger ?? console;\n  }\n\n  #waitingPromise: Promise<void> | undefined = undefined;\n  readonly #dispatcherName: string;\n  readonly #systemLogger: Logger;\n  readonly #dispatchFunction: DispatchFunction<TPayload>;\n  readonly #queue: TPayload[] = [];\n  readonly #msDelay: number;\n\n  enqueue = (payload: TPayload): void => {\n    this.#queue.push(payload);\n    // eslint-disable-next-line @typescript-eslint/no-misused-promises\n    if (!this.#waitingPromise) {\n      this.#waitingPromise = new Promise((res) => {\n        setTimeout(() => {\n          if (this.#queue.length > 0) {\n            const entries = [...this.#queue];\n            this.#queue.length = 0;\n            this.#waitingPromise = undefined;\n            this.#dispatchFunction(entries)\n              .catch((error) => {\n                this.#systemLogger.error(\n                  `Uncaught error in BatchDispatcher named '${this.#dispatcherName}'}`,\n                  error.message,\n                  error.stack\n                );\n              })\n              .finally(() => {\n                res();\n              });\n          }\n\n          // TODO - at extreme scale, we may need a max queue size\n        }, this.#msDelay);\n      });\n    }\n  };\n\n  waitUntilFlushed = async (): Promise<void> => {\n    // if we have a promise queued up, wait for that\n    // eslint-disable-next-line @typescript-eslint/no-misused-promises\n    if (this.#waitingPromise) {\n      return this.#waitingPromise;\n    }\n  };\n}\n", "import { ZuploContext } from \"../../../index.worker\";\nimport internals from \"../../../internals\";\nimport { MetricsData } from \"../../../processors/metrics-processor\";\nimport { SystemLogMap } from \"../../../system-log-map\";\nimport { BatchDispatch } from \"../../../utils/batch-dispatch\";\nimport { Environment } from \"../../../utils/environment\";\nimport { MetricsTransport } from \"../interfaces\";\n\nexport class EllieMetricsTransport implements MetricsTransport {\n  readonly #context: ZuploContext;\n  readonly #batcher: BatchDispatch<MetricsData>;\n  readonly #loggingId: string | undefined;\n\n  constructor(context: ZuploContext) {\n    this.#loggingId = Environment.instance.loggingId;\n    this.#context = context;\n    this.#batcher = new BatchDispatch<MetricsData>(\n      \"ellie-metrics-transport\",\n      10,\n      this.dispatchFunction,\n      SystemLogMap.getLogger(context)\n    );\n  }\n\n  pushMetrics(entry: MetricsData, context: ZuploContext): void {\n    if (this.#loggingId === undefined) {\n      return;\n    }\n    this.#batcher.enqueue(entry);\n    context.waitUntil(this.#batcher.waitUntilFlushed());\n  }\n\n  dispatchFunction = async (entries: MetricsData[]) => {\n    if (entries.length === 0) {\n      return;\n    }\n\n    let url;\n    const { loggingId, remoteLogURL, deploymentName } = Environment.instance;\n\n    // For Ellie we do not want to send these data over since we don't use them.\n    const transformedEntries = entries.map((entry) => {\n      const copy = Object.assign({}, entry);\n      delete copy.requestContentLength;\n      delete copy.responseContentLength;\n      return copy;\n    });\n\n    if (loggingId && deploymentName) {\n      url = `${remoteLogURL}/v1-alpha/metrics?loggingId=${encodeURI(\n        loggingId\n      )}&deploymentName=${encodeURI(deploymentName)}`;\n    }\n    if (url) {\n      const result = await internals.fetch(url, {\n        method: \"POST\",\n        body: JSON.stringify(transformedEntries),\n        headers: {\n          \"content-type\": \"application/json\",\n          \"zp-dn\": Environment.instance.deploymentName ?? \"unknown\",\n          \"user-agent\": Environment.instance.systemUserAgent,\n        },\n      });\n      if (!result.ok) {\n        const body = await result.text();\n        SystemLogMap.getLogger(this.#context).error(\n          `Metrics POST responded ${result.status}: ${result.statusText}`,\n          body\n        );\n      }\n    }\n  };\n}\n", "import {\n  CorsPolicy,\n  HandlerDefinition,\n  HttpMethod,\n  RouteConfiguration,\n  SystemRouteName,\n  VersionData,\n} from \"./interfaces\";\n\n/**\n * @internal\n */\nexport class SystemRouteConfiguration implements RouteConfiguration {\n  constructor({\n    label,\n    path,\n    methods,\n    systemRouteName,\n    corsPolicy = \"none\",\n  }: {\n    label: string;\n    path: string;\n    methods: HttpMethod[];\n    systemRouteName: SystemRouteName;\n    corsPolicy?: CorsPolicy;\n  }) {\n    this.label = label;\n    this.path = path;\n    this.methods = methods;\n    this.corsPolicy = corsPolicy;\n    this.version = systemNoVersion.name;\n    this.handler = { export: \"SYSTEM_IGNORED\", module: \"SYSTEM_IGNORED\" };\n    this.systemRouteName = systemRouteName;\n  }\n\n  label?: string | undefined;\n  path: string;\n  methods: HttpMethod[];\n  handler: HandlerDefinition;\n  corsPolicy: CorsPolicy;\n  version: string;\n  policies?: { inbound: string[] } | undefined;\n  /**\n   * Used to alias the system route's path in logs to something more\n   * user-friendly.\n   */\n  systemRouteName: SystemRouteName;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  raw<T = any>(): T {\n    return {} as T;\n  }\n}\n\nexport const systemNoVersion: VersionData = {\n  name: \"__system-no-version\",\n  pathPrefix: \"\",\n};\n", "import { RAY_ID_HEADER, TRUE_CLIENT_IP } from \"../constants\";\nimport { ZuploContext, ZuploContextExtensions } from \"../context\";\nimport { plugins } from \"../extensions\";\nimport { Gateway } from \"../gateway\";\nimport { RequestProcessor } from \"../interfaces\";\nimport { MetricsTransport } from \"../metrics/v1/interfaces\";\nimport { MetricsPlugin } from \"../metrics/v1/metrics-plugin\";\nimport { EllieMetricsTransport } from \"../metrics/v1/transports/ellie-metrics\";\nimport { ZuploRequest } from \"../request\";\nimport { HttpMethod } from \"../router/interfaces\";\nimport { SystemRouteConfiguration } from \"../router/system-route-configuration\";\nimport { Environment } from \"../utils/environment\";\n\n/**\n * @public\n */\nexport interface MetricsData {\n  timestamp: Date;\n  durationMs: number;\n  statusCode: number;\n  requestContentLength?: number;\n  responseContentLength?: number;\n  requestId: string;\n  routePath: string;\n  systemRouteName?: string;\n  method: HttpMethod;\n  rayId?: string;\n  instanceId: string;\n  userSub?: string;\n  clientIp?: string;\n  asn?: number;\n  asOrganization?: string;\n  colo?: string;\n  continent?: string;\n  country?: string;\n  city?: string;\n  latitude?: string;\n  longitude?: string;\n}\n\n/**\n * @internal\n */\nexport const metricsProcessor: RequestProcessor = async (\n  request: ZuploRequest,\n  context: ZuploContext,\n  gateway: Gateway,\n  next: (request: ZuploRequest) => Promise<Response>\n): Promise<Response> => {\n  const timestamp = new Date();\n  const start = Date.now();\n\n  const res = await next(request);\n\n  // If available, get the CloudFlare Ray ID and True Client IP\n  const rayId = request.headers.get(RAY_ID_HEADER) ?? undefined;\n  const clientIp = request.headers.get(TRUE_CLIENT_IP) ?? undefined;\n\n  // Using internal type so we can get access to non-public props\n  const props = context.incomingRequestProperties;\n  let systemRouteName: string | undefined = undefined;\n  if (context.route instanceof SystemRouteConfiguration) {\n    systemRouteName = context.route.systemRouteName;\n  }\n\n  const latestRequest =\n    ZuploContextExtensions.getContextExtensions(context).latestRequest;\n\n  const metricsData: MetricsData = {\n    timestamp,\n    statusCode: res.status,\n    durationMs: Date.now() - start,\n    requestContentLength: request.headers.get(\"content-length\")\n      ? Number(request.headers.get(\"content-length\"))\n      : undefined,\n    responseContentLength: res.headers.get(\"content-length\")\n      ? Number(res.headers.get(\"content-length\"))\n      : undefined,\n    routePath: context.route?.path ?? \"SYSTEM_OR_NOT_FOUND\",\n    systemRouteName,\n    requestId: context.requestId,\n    // best to use the original method for metrics, as the request may have been modified\n    method: request.method as HttpMethod,\n    asn: props.asn,\n    asOrganization: props.asOrganization,\n    colo: props.colo,\n    continent: props.continent,\n    country: props.country,\n    city: props.city,\n    latitude: props.latitude,\n    longitude: props.longitude,\n    rayId,\n    instanceId: Environment.instance.instanceId,\n    // but here, we need the latest to capture the user\n    userSub: latestRequest.user?.sub,\n    clientIp,\n  };\n\n  const transports: MetricsTransport[] = [];\n\n  // Add the default transport\n  transports.push(new EllieMetricsTransport(context));\n\n  // Add log transports exposed in runtime extensins\n  plugins.forEach((plugin) => {\n    if (plugin instanceof MetricsPlugin) {\n      const transport = plugin.getTransport();\n      transports.push(transport);\n    }\n  });\n\n  transports.forEach((transport) => {\n    // Exception handling is done in the transport (using Batch Dispatcher or some other mechanism)\n    transport.pushMetrics(metricsData, context);\n  });\n\n  return res;\n};\n", "import type { OpenAPIV3_1 } from \"openapi-types\";\nimport { HttpStatusCode, HttpStatusCodeRangeDefinition } from \"../http-status\";\nimport { ParsedCorsPolicyConfiguration } from \"../utils/cors\";\nimport { BuildRouteConfiguration, RouteData } from \"./interfaces.generated\";\n\ntype Modify<T, R> = Omit<T, keyof R> & R;\n\n/**\n * @beta\n */\nexport type ParameterBaseObject = Modify<\n  Omit<\n    OpenAPIV3_1.ParameterBaseObject,\n    | \"content\"\n    | \"allowEmptyValue\"\n    | \"style\"\n    | \"allowReserved\"\n    | \"explode\"\n    | \"example\"\n    | \"examples\"\n  >,\n  { schema: OpenAPIV3_1.SchemaObject }\n>;\n\n/**\n * @beta\n */\nexport interface ParameterDefinition extends ParameterBaseObject {\n  name: string;\n  in: string;\n}\n\n/**\n * @internal\n * System route names are kept in an enum to avoid naming collision and to keep\n * them all in one place for easy reference.\n */\nexport enum SystemRouteName {\n  Build = \"build-data\",\n  CorsPreflight = \"cors-preflight\",\n  DeveloperPortal = \"developer-portal\",\n  DeveloperPortalLegacy = \"developer-portal-legacy\",\n  StripePlugin = \"stripe-plugin\",\n  EmptyGatewayCatchall = \"empty-gateway-catchall\",\n  Ping = \"ping\",\n  UnmatchedPath = \"unmatched-path\",\n}\n\nexport interface RouteConfiguration\n  extends Omit<BuildRouteConfiguration, \"raw\"> {\n  /**\n   * @deprecated Please switch to \"raw().operationId\"\n   */\n  operationId?: string;\n  /**\n   * @deprecated Please switch to \"raw().summary\"\n   */\n  summary?: string;\n  /**\n   * @deprecated Please switch to \"raw().tags\"\n   */\n  tags?: string[];\n  /**\n   * @deprecated Please switch to \"raw().parameters\"\n   */\n  parameters?: ParameterDefinition[];\n  /**\n   * @deprecated Please switch to \"raw().responses\"\n   */\n  responses?: ResponsesDefinition;\n  raw<T>(): T;\n}\n\n/**\n * @beta\n */\nexport type ResponsesDefinition = Record<\n  HttpStatusCode | HttpStatusCodeRangeDefinition,\n  Modify<\n    Omit<OpenAPIV3_1.ResponseObject, \"links\">,\n    {\n      headers?: { [header: string]: ParameterBaseObject };\n    }\n  >\n>;\n\nexport interface ParsedRouteData extends Omit<RouteData, \"corsPolicies\"> {\n  corsPolicies: ParsedCorsPolicyConfiguration[];\n}\n", "export {};\n//# sourceMappingURL=interfaces.generated.js.map", "export * from \"./interfaces.custom\";\nexport * from \"./interfaces.generated\";\n", "import { ZuploContext } from \"../context\";\nimport { Gateway } from \"../gateway\";\nimport { HttpProblems } from \"../index.worker\";\nimport { Pipeline } from \"../pipeline\";\nimport { metricsProcessor } from \"../processors/metrics-processor\";\nimport { ZuploRequest } from \"../request\";\nimport { SystemRouteName } from \"../router/interfaces\";\nimport { RouteHandler, Router } from \"../router/router\";\nimport { SystemRouteConfiguration } from \"../router/system-route-configuration\";\nimport { SystemLogMap } from \"../system-log-map\";\nimport { Environment } from \"../utils/environment\";\n\n/**\n * @internal\n */\nexport const registerBuildRoute = (router: Router, gateway: Gateway) => {\n  const buildRouteHandler: RouteHandler = async (\n    request: ZuploRequest,\n    context: ZuploContext\n  ) => {\n    // We only show the build data on .app / .dev domains - protected by CloudFlare\n    // so only Zuplo personnel can see this\n    const url = new URL(request.url);\n    const hostname = url.hostname.toLowerCase();\n    if (\n      !hostname.endsWith(\".zuplo.app\") &&\n      !hostname.endsWith(\".zuplo.dev\") &&\n      !hostname.endsWith(\".fly.dev\") &&\n      !hostname.endsWith(\"zuplotest.com\") &&\n      hostname !== \"localhost\"\n    ) {\n      return HttpProblems.notFound(request, context);\n    }\n\n    const rawBuild = Environment.instance.build;\n\n    // Be explicit in what we pass to this route so\n    // environment variables aren't accidentally exposed.\n    // DO NOT CHANGE THIS TO SEND ALL OF buildEnv\n    const buildData = {\n      buildId: rawBuild.BUILD_ID,\n      zuploVersion: rawBuild.ZUPLO_VERSION,\n      compatibilityDate: rawBuild.COMPATIBILITY_DATE,\n      apiVersion: rawBuild.API_VERSION,\n      gitSha: rawBuild.GIT_SHA,\n      timestamp: rawBuild.TIMESTAMP,\n      isProduction: rawBuild.IS_PRODUCTION,\n    };\n\n    const qs = request.url.toString().split(\"?\");\n\n    if (qs.length > 0) {\n      const params = new URLSearchParams(qs[1]);\n\n      if (params.get(\"system_log\") === \"true\") {\n        SystemLogMap.getLogger(context).error(\"Test System Log\", buildData);\n      }\n    }\n\n    return new Response(JSON.stringify(buildData, null, 2), {\n      status: 200,\n      headers: { \"content-type\": \"application/json\" },\n    });\n  };\n\n  const zPipe = new Pipeline({\n    processors: [metricsProcessor],\n    handler: buildRouteHandler,\n    gateway,\n  });\n  const buildRouteConfiguration = new SystemRouteConfiguration({\n    label: \"SYSTEM_BUILD_ROUTE\",\n    methods: [\"GET\"],\n    path: \"/__zuplo/build\",\n    systemRouteName: SystemRouteName.Build,\n  });\n\n  router.addRoute(buildRouteConfiguration, zPipe.execute);\n};\n", "/* eslint-disable @typescript-eslint/no-duplicate-enum-values */\nexport type HttpStatusCodeRangeDefinition =\n  | \"1XX\"\n  | \"2XX\"\n  | \"3XX\"\n  | \"4XX\"\n  | \"5XX\";\n\n/**\n * @beta\n */\nexport enum HttpStatusCode {\n  /**\n   * The server has received the request headers and the client should proceed to send the request body\n   * (in the case of a request for which a body needs to be sent; for example, a POST request).\n   * Sending a large request body to a server after a request has been rejected for inappropriate headers would be inefficient.\n   * To have a server check the request's headers, a client must send Expect: 100-continue as a header in its initial request\n   * and receive a 100 Continue status code in response before sending the body. The response 417 Expectation Failed indicates the request should not be continued.\n   */\n  CONTINUE = 100,\n\n  /**\n   * The requester has asked the server to switch protocols and the server has agreed to do so.\n   */\n  SWITCHING_PROTOCOLS = 101,\n\n  /**\n   * A WebDAV request may contain many sub-requests involving file operations, requiring a long time to complete the request.\n   * This code indicates that the server has received and is processing the request, but no response is available yet.\n   * This prevents the client from timing out and assuming the request was lost.\n   * @deprecated This status code is deprecated and shouldn't be sent any more. Clients may still accept it, but simply ignore them.\n   */\n  PROCESSING = 102,\n\n  /**\n   * This response may be sent by a server while it is still preparing a\n   * response, with hints about the resources that the server is expecting\n   * the final response will link. This allows a browser to start preloading\n   * resources even before the server has prepared and sent that final response.\n   */\n  EARLY_HINTS = 103,\n\n  /**\n   * Standard response for successful HTTP requests.\n   * The actual response will depend on the request method used.\n   * In a GET request, the response will contain an entity corresponding to the requested resource.\n   * In a POST request, the response will contain an entity describing or containing the result of the action.\n   */\n  OK = 200,\n\n  /**\n   * The request has been fulfilled, resulting in the creation of a new resource.\n   */\n  CREATED = 201,\n\n  /**\n   * The request has been accepted for processing, but the processing has not been completed.\n   * The request might or might not be eventually acted upon, and may be disallowed when processing occurs.\n   */\n  ACCEPTED = 202,\n\n  /**\n   * SINCE HTTP/1.1\n   * The server is a transforming proxy that received a 200 OK from its origin,\n   * but is returning a modified version of the origin's response.\n   */\n  NON_AUTHORITATIVE_INFORMATION = 203,\n\n  /**\n   * The server successfully processed the request and is not returning any content.\n   */\n  NO_CONTENT = 204,\n\n  /**\n   * The server successfully processed the request, but is not returning any content.\n   * Unlike a 204 response, this response requires that the requester reset the document view.\n   */\n  RESET_CONTENT = 205,\n\n  /**\n   * The server is delivering only part of the resource (byte serving) due to a range header sent by the client.\n   * The range header is used by HTTP clients to enable resuming of interrupted downloads,\n   * or split a download into multiple simultaneous streams.\n   */\n  PARTIAL_CONTENT = 206,\n\n  /**\n   * The message body that follows is an XML message and can contain a number of separate response codes,\n   * depending on how many sub-requests were made.\n   */\n  MULTI_STATUS = 207,\n\n  /**\n   * The members of a DAV binding have already been enumerated in a preceding part of the (multistatus) response,\n   * and are not being included again.\n   */\n  ALREADY_REPORTED = 208,\n\n  /**\n   * The server has fulfilled a request for the resource,\n   * and the response is a representation of the result of one or more instance-manipulations applied to the current instance.\n   */\n  IM_USED = 226,\n\n  /**\n   * Indicates multiple options for the resource from which the client may choose (via agent-driven content negotiation).\n   * For example, this code could be used to present multiple video format options,\n   * to list files with different filename extensions, or to suggest word-sense disambiguation.\n   */\n  MULTIPLE_CHOICES = 300,\n\n  /**\n   * This and all future requests should be directed to the given URI.\n   */\n  MOVED_PERMANENTLY = 301,\n\n  /**\n   * This is an example of industry practice contradicting the standard.\n   * The HTTP/1.0 specification (RFC 1945) required the client to perform a temporary redirect\n   * (the original describing phrase was \"Moved Temporarily\"), but popular browsers implemented 302\n   * with the functionality of a 303 See Other. Therefore, HTTP/1.1 added status codes 303 and 307\n   * to distinguish between the two behaviours. However, some Web applications and frameworks\n   * use the 302 status code as if it were the 303.\n   */\n  FOUND = 302,\n\n  /**\n   * SINCE HTTP/1.1\n   * The response to the request can be found under another URI using a GET method.\n   * When received in response to a POST (or PUT/DELETE), the client should presume that\n   * the server has received the data and should issue a redirect with a separate GET message.\n   */\n  SEE_OTHER = 303,\n\n  /**\n   * Indicates that the resource has not been modified since the version specified by the request headers If-Modified-Since or If-None-Match.\n   * In such case, there is no need to retransmit the resource since the client still has a previously-downloaded copy.\n   */\n  NOT_MODIFIED = 304,\n\n  /**\n   * SINCE HTTP/1.1\n   * The requested resource is available only through a proxy, the address for which is provided in the response.\n   * Many HTTP clients (such as Mozilla and Internet Explorer) do not correctly handle responses with this status code, primarily for security reasons.\n   */\n  USE_PROXY = 305,\n\n  /**\n   * No longer used. Originally meant \"Subsequent requests should use the specified proxy.\"\n   * @deprecated No longer used\n   */\n  SWITCH_PROXY = 306,\n\n  /**\n   * SINCE HTTP/1.1\n   * In this case, the request should be repeated with another URI; however, future requests should still use the original URI.\n   * In contrast to how 302 was historically implemented, the request method is not allowed to be changed when reissuing the original request.\n   * For example, a POST request should be repeated using another POST request.\n   */\n  TEMPORARY_REDIRECT = 307,\n\n  /**\n   * The request and all future requests should be repeated using another URI.\n   * 307 and 308 parallel the behaviors of 302 and 301, but do not allow the HTTP method to change.\n   * So, for example, submitting a form to a permanently redirected resource may continue smoothly.\n   */\n  PERMANENT_REDIRECT = 308,\n\n  /**\n   * The server cannot or will not process the request due to an apparent client error\n   * (e.g., malformed request syntax, too large size, invalid request message framing, or deceptive request routing).\n   */\n  BAD_REQUEST = 400,\n\n  /**\n   * Similar to 403 Forbidden, but specifically for use when authentication is required and has failed or has not yet\n   * been provided. The response must include a WWW-Authenticate header field containing a challenge applicable to the\n   * requested resource. See Basic access authentication and Digest access authentication. 401 semantically means\n   * \"unauthenticated\",i.e. the user does not have the necessary credentials.\n   */\n  UNAUTHORIZED = 401,\n\n  /**\n   * Reserved for future use. The original intention was that this code might be used as part of some form of digital\n   * cash or micro payment scheme, but that has not happened, and this code is not usually used.\n   * Google Developers API uses this status if a particular developer has exceeded the daily limit on requests.\n   */\n  PAYMENT_REQUIRED = 402,\n\n  /**\n   * The request was valid, but the server is refusing action.\n   * The user might not have the necessary permissions for a resource.\n   */\n  FORBIDDEN = 403,\n\n  /**\n   * The requested resource could not be found but may be available in the future.\n   * Subsequent requests by the client are permissible.\n   */\n  NOT_FOUND = 404,\n\n  /**\n   * A request method is not supported for the requested resource;\n   * for example, a GET request on a form that requires data to be presented via POST, or a PUT request on a read-only resource.\n   */\n  METHOD_NOT_ALLOWED = 405,\n\n  /**\n   * The requested resource is capable of generating only content not acceptable according to the Accept headers sent in the request.\n   */\n  NOT_ACCEPTABLE = 406,\n\n  /**\n   * The client must first authenticate itself with the proxy.\n   */\n  PROXY_AUTHENTICATION_REQUIRED = 407,\n\n  /**\n   * The server timed out waiting for the request.\n   * According to HTTP specifications:\n   * \"The client did not produce a request within the time that the server was prepared to wait. The client MAY repeat the request without modifications at any later time.\"\n   */\n  REQUEST_TIMEOUT = 408,\n\n  /**\n   * Indicates that the request could not be processed because of conflict in the request,\n   * such as an edit conflict between multiple simultaneous updates.\n   */\n  CONFLICT = 409,\n\n  /**\n   * Indicates that the resource requested is no longer available and will not be available again.\n   * This should be used when a resource has been intentionally removed and the resource should be purged.\n   * Upon receiving a 410 status code, the client should not request the resource in the future.\n   * Clients such as search engines should remove the resource from their indices.\n   * Most use cases do not require clients and search engines to purge the resource, and a \"404 Not Found\" may be used instead.\n   */\n  GONE = 410,\n\n  /**\n   * The request did not specify the length of its content, which is required by the requested resource.\n   */\n  LENGTH_REQUIRED = 411,\n\n  /**\n   * The server does not meet one of the preconditions that the requester put on the request.\n   */\n  PRECONDITION_FAILED = 412,\n\n  /**\n   * The request is larger than the server is willing or able to process. Previously called \"Request Entity Too Large\".\n   */\n  CONTENT_TOO_LARGE = 413,\n\n  /**\n   * The request is larger than the server is willing or able to process. Previously called \"Request Entity Too Large\".\n   * @deprecated use CONTENT_TOO_LARGE\n   * @internal\n   */\n  PAYLOAD_TOO_LARGE = 413,\n\n  /**\n   * The URI provided was too long for the server to process. Often the result of too much data being encoded as a query-string of a GET request,\n   * in which case it should be converted to a POST request.\n   * Called \"Request-URI Too Long\" previously.\n   */\n  URI_TOO_LONG = 414,\n\n  /**\n   * The request entity has a media type which the server or resource does not support.\n   * For example, the client uploads an image as image/svg+xml, but the server requires that images use a different format.\n   */\n  UNSUPPORTED_MEDIA_TYPE = 415,\n\n  /**\n   * The client has asked for a portion of the file (byte serving), but the server cannot supply that portion.\n   * For example, if the client asked for a part of the file that lies beyond the end of the file.\n   * Called \"Requested Range Not Satisfiable\" previously.\n   */\n  RANGE_NOT_SATISFIABLE = 416,\n\n  /**\n   * The server cannot meet the requirements of the Expect request-header field.\n   */\n  EXPECTATION_FAILED = 417,\n\n  /**\n   * This code was defined in 1998 as one of the traditional IETF April Fools' jokes, in RFC 2324, Hyper Text Coffee Pot Control Protocol,\n   * and is not expected to be implemented by actual HTTP servers. The RFC specifies this code should be returned by\n   * teapots requested to brew coffee. This HTTP status is used as an Easter egg in some websites, including Google.com.\n   */\n  I_AM_A_TEAPOT = 418,\n\n  /**\n   * The request was directed at a server that is not able to produce a response (for example because a connection reuse).\n   */\n  MISDIRECTED_REQUEST = 421,\n\n  /**\n   * The request was well-formed but was unable to be followed due to semantic errors.\n   * @deprecated use UNPROCESSABLE_CONTENT\n   * @internal\n   */\n  UNPROCESSABLE_ENTITY = 422,\n\n  /**\n   * The request was well-formed but was unable to be followed due to semantic errors.\n   */\n  UNPROCESSABLE_CONTENT = 422,\n\n  /**\n   * The resource that is being accessed is locked.\n   */\n  LOCKED = 423,\n\n  /**\n   * The request failed due to failure of a previous request (e.g., a PROPPATCH).\n   */\n  FAILED_DEPENDENCY = 424,\n\n  /**\n   * The server is unwilling to risk processing a request that might be\n   * replayed, which creates the potential for a replay attack.\n   */\n  TOO_EARLY = 425,\n\n  /**\n   * The client should switch to a different protocol such as TLS/1.0, given in the Upgrade header field.\n   */\n  UPGRADE_REQUIRED = 426,\n\n  /**\n   * The origin server requires the request to be conditional.\n   * Intended to prevent \"the 'lost update' problem, where a client\n   * GETs a resource's state, modifies it, and PUTs it back to the server,\n   * when meanwhile a third party has modified the state on the server, leading to a conflict.\"\n   */\n  PRECONDITION_REQUIRED = 428,\n\n  /**\n   * The user has sent too many requests in a given amount of time. Intended for use with rate-limiting schemes.\n   */\n  TOO_MANY_REQUESTS = 429,\n\n  /**\n   * The server is unwilling to process the request because either an individual header field,\n   * or all the header fields collectively, are too large.\n   */\n  REQUEST_HEADER_FIELDS_TOO_LARGE = 431,\n\n  /**\n   * A server operator has received a legal demand to deny access to a resource or to a set of resources\n   * that includes the requested resource. The code 451 was chosen as a reference to the novel Fahrenheit 451.\n   */\n  UNAVAILABLE_FOR_LEGAL_REASONS = 451,\n\n  /**\n   * A generic error message, given when an unexpected condition was encountered and no more specific message is suitable.\n   */\n  INTERNAL_SERVER_ERROR = 500,\n\n  /**\n   * The server either does not recognize the request method, or it lacks the ability to fulfill the request.\n   * Usually this implies future availability (e.g., a new feature of a web-service API).\n   */\n  NOT_IMPLEMENTED = 501,\n\n  /**\n   * The server was acting as a gateway or proxy and received an invalid response from the upstream server.\n   */\n  BAD_GATEWAY = 502,\n\n  /**\n   * The server is currently unavailable (because it is overloaded or down for maintenance).\n   * Generally, this is a temporary state.\n   */\n  SERVICE_UNAVAILABLE = 503,\n\n  /**\n   * The server was acting as a gateway or proxy and did not receive a timely response from the upstream server.\n   */\n  GATEWAY_TIMEOUT = 504,\n\n  /**\n   * The server does not support the HTTP protocol version used in the request\n   */\n  HTTP_VERSION_NOT_SUPPORTED = 505,\n\n  /**\n   * Transparent content negotiation for the request results in a circular reference.\n   */\n  VARIANT_ALSO_NEGOTIATES = 506,\n\n  /**\n   * The server is unable to store the representation needed to complete the request.\n   */\n  INSUFFICIENT_STORAGE = 507,\n\n  /**\n   * The server detected an infinite loop while processing the request.\n   */\n  LOOP_DETECTED = 508,\n\n  /**\n   * Further extensions to the request are required for the server to fulfill it.\n   */\n  NOT_EXTENDED = 510,\n\n  /**\n   * The client needs to authenticate to gain network access.\n   * Intended for use by intercepting proxies used to control access to the network (e.g., \"captive portals\" used\n   * to require agreement to Terms of Service before granting full Internet access via a Wi-Fi hotspot).\n   */\n  NETWORK_AUTHENTICATION_REQUIRED = 511,\n}\n\n/**\n * @internal\n */\nexport const HTTP_STATUS_TITLES: Record<HttpStatusCode, string> = {\n  100: \"Continue\",\n  101: \"Switching Protocols\",\n  102: \"Processing\",\n  103: \"Early Hints\",\n  200: \"OK\",\n  201: \"Created\",\n  202: \"Accepted\",\n  203: \"Non-Authoritative Information\",\n  204: \"No Content\",\n  205: \"Reset Content\",\n  206: \"Partial Content\",\n  207: \"Multi-Status\",\n  208: \"Already Reported\",\n  226: \"IM Used\",\n  300: \"Multiple Choices\",\n  301: \"Moved Permanently\",\n  302: \"Found\",\n  303: \"See Other\",\n  304: \"Not Modified\",\n  305: \"Use Proxy\",\n  306: \"Switch Proxy\",\n  307: \"Temporary Redirect\",\n  308: \"Permanent Redirect\",\n  400: \"Bad Request\",\n  401: \"Unauthorized\",\n  402: \"Payment Required\",\n  403: \"Forbidden\",\n  404: \"Not Found\",\n  405: \"Method Not Allowed\",\n  406: \"Not Acceptable\",\n  407: \"Proxy Authentication Required\",\n  408: \"Request Timeout\",\n  409: \"Conflict\",\n  410: \"Gone\",\n  411: \"Length Required\",\n  412: \"Precondition Failed\",\n  413: \"Content Too Large\",\n  414: \"URI Too Long\",\n  415: \"Unsupported Media Type\",\n  416: \"Range Not Satisfiable\",\n  417: \"Expectation Failed\",\n  418: \"I'm a teapot\",\n  421: \"Misdirected Request\",\n  422: \"Unprocessable Content\",\n  423: \"Locked\",\n  424: \"Failed Dependency\",\n  425: \"Too Early\",\n  426: \"Upgrade Required\",\n  428: \"Precondition Required\",\n  429: \"Too Many Requests\",\n  431: \"Request Header Fields Too Large\",\n  451: \"Unavailable For Legal Reasons\",\n  500: \"Internal Server Error\",\n  501: \"Not Implemented\",\n  502: \"Bad Gateway\",\n  503: \"Service Unavailable\",\n  504: \"Gateway Timeout\",\n  505: \"HTTP Version Not Supported\",\n  506: \"Variant Also Negotiates\",\n  507: \"Insufficient Storage\",\n  508: \"Loop Detected\",\n  510: \"Not Extended\",\n  511: \"Network Authentication Required\",\n};\n", "/**\n * @internal\n */\nconst httpStatuses: { [key: number]: string } = {\n  100: \"Continue\",\n  101: \"Switching Protocols\",\n  102: \"Processing\",\n  103: \"Early Hints\",\n  200: \"OK\",\n  201: \"Created\",\n  202: \"Accepted\",\n  203: \"Non-Authoritative Information\",\n  204: \"No Content\",\n  205: \"Reset Content\",\n  206: \"Partial Content\",\n  207: \"Multi-Status\",\n  208: \"Already Reported\",\n  226: \"IM Used\",\n  300: \"Multiple Choices\",\n  301: \"Moved Permanently\",\n  302: \"Found\",\n  303: \"See Other\",\n  304: \"Not Modified\",\n  305: \"Use Proxy\",\n  307: \"Temporary Redirect\",\n  308: \"Permanent Redirect\",\n  400: \"Bad Request\",\n  401: \"Unauthorized\",\n  402: \"Payment Required\",\n  403: \"Forbidden\",\n  404: \"Not Found\",\n  405: \"Method Not Allowed\",\n  406: \"Not Acceptable\",\n  407: \"Proxy Authentication Required\",\n  408: \"Request Timeout\",\n  409: \"Conflict\",\n  410: \"Gone\",\n  411: \"Length Required\",\n  412: \"Precondition Failed\",\n  413: \"Payload Too Large\",\n  414: \"URI Too Long\",\n  415: \"Unsupported Media Type\",\n  416: \"Range Not Satisfiable\",\n  417: \"Expectation Failed\",\n  418: \"I'm a Teapot\",\n  421: \"Misdirected Request\",\n  422: \"Unprocessable Entity\",\n  423: \"Locked\",\n  424: \"Failed Dependency\",\n  425: \"Too Early\",\n  426: \"Upgrade Required\",\n  428: \"Precondition Required\",\n  429: \"Too Many Requests\",\n  431: \"Request Header Fields Too Large\",\n  451: \"Unavailable For Legal Reasons\",\n  500: \"Internal Server Error\",\n  501: \"Not Implemented\",\n  502: \"Bad Gateway\",\n  503: \"Service Unavailable\",\n  504: \"Gateway Timeout\",\n  505: \"HTTP Version Not Supported\",\n  506: \"Variant Also Negotiates\",\n  507: \"Insufficient Storage\",\n  508: \"Loop Detected\",\n  509: \"Bandwidth Limit Exceeded\",\n  510: \"Not Extended\",\n  511: \"Network Authentication Required\",\n};\n\nexport default httpStatuses;\n", "import { RAY_ID_HEADER } from \"../constants\";\nimport { ZuploContext } from \"../context\";\nimport { HTTP_STATUS_TITLES, HttpStatusCode } from \"../http-status\";\nimport { ZuploRequest } from \"../request\";\nimport httpStatuses from \"../statuses\";\nimport { Environment } from \"../utils/environment\";\nimport { ProblemDetails, ProblemResponseDetails } from \"./problem\";\nimport { ProblemResponseFormatter } from \"./problem-response-formatter\";\n\nfunction instance(request: Request) {\n  const url = new URL(request.url);\n  return `${url.pathname}`;\n}\n\nfunction trace(request: ZuploRequest, context: ZuploContext) {\n  const traceObject: Record<string, string> = {\n    timestamp: new Date().toISOString(),\n    requestId: context.requestId,\n    buildId: Environment.instance.build.BUILD_ID,\n  };\n\n  const ray = request.headers.get(RAY_ID_HEADER);\n  if (ray) {\n    traceObject.rayId = ray;\n  }\n\n  return traceObject;\n}\n\nconst merge = (\n  staticDetails: ProblemDetails,\n  request: ZuploRequest,\n  context: ZuploContext,\n  overrides?: Partial<ProblemDetails>,\n  additionalHeaders?: HeadersInit\n) => ({\n  problem: {\n    type: staticDetails.type,\n    title: staticDetails.title,\n    status: staticDetails.status,\n    detail: staticDetails.detail,\n    instance: instance(request),\n    trace: trace(request, context),\n    ...overrides,\n  },\n  additionalHeaders,\n  statusText: httpStatuses[staticDetails.status],\n});\n\nclass HttpProblemsBase {\n  /**\n   * Creates a Response in the standard format from a problem detail\n   * @param details - The details of the problem\n   * @param request - The ZuploRequest object\n   * @param context - The ZuploContext object\n   * @returns A HTTP Response promise\n   */\n  static format = (\n    details: ProblemDetails | ProblemResponseDetails,\n    request: ZuploRequest,\n    context: ZuploContext\n  ) => {\n    if (\"problem\" in details) {\n      return ProblemResponseFormatter.format(\n        details as ProblemResponseDetails,\n        request,\n        context\n      );\n    } else {\n      return ProblemResponseFormatter.format(\n        { problem: details },\n        request,\n        context\n      );\n    }\n  };\n\n  /**\n   * Creates a problem from the status code\n   */\n  static getProblemFromStatus(\n    status: HttpStatusCode,\n    problem?: Partial<Omit<ProblemDetails, \"status\" | \"title\">>\n  ): ProblemDetails {\n    return {\n      ...{\n        type: `https://httpproblems.com/http-status/${status}`,\n        status,\n        title: HTTP_STATUS_TITLES[status],\n      },\n      ...problem,\n    };\n  }\n}\n\n/**\n * @beta\n */\n// prettier-ignore\nexport class HttpProblems extends HttpProblemsBase {\n  static #buildResponse(\n    status: HttpStatusCode,\n    request: ZuploRequest,\n    context: ZuploContext,\n    overrides?: Partial<ProblemDetails>,\n    additionalHeaders?: HeadersInit\n  ) {\n    const prd = merge(\n      this.getProblemFromStatus(status),\n      request,\n      context,\n      overrides,\n      additionalHeaders\n    );\n    return ProblemResponseFormatter.format(prd, request, context);\n  }\n\n  /**\n   * The server has received the request headers and the client should proceed to send the request body\n   * (in the case of a request for which a body needs to be sent; for example, a POST request).\n   * Sending a large request body to a server after a request has been rejected for inappropriate headers would be inefficient.\n   * To have a server check the request's headers, a client must send Expect: 100-continue as a header in its initial request\n   * and receive a 100 Continue status code in response before sending the body. The response 417 Expectation Failed indicates the request should not be continued.\n   * \n   * @param request - The ZuploRequest object\n   * @param context - The ZuploContext object\n   * @param overrides - Overrides to the problem\n   * @param additionalHeaders - Additional headers to send in the outgoing response\n   * @returns A HTTP response promise\n   */\n  static continue = (request: ZuploRequest, context: ZuploContext, overrides?: Partial<ProblemDetails>, additionalHeaders?: HeadersInit) => this.#buildResponse(HttpStatusCode.OK, request, context, overrides, additionalHeaders);\n  /**\n   * The requester has asked the server to switch protocols and the server has agreed to do so.\n   * \n   * @param request - The ZuploRequest object\n   * @param context - The ZuploContext object\n   * @param overrides - Overrides to the problem\n   * @param additionalHeaders - Additional headers to send in the outgoing response\n   * @returns A HTTP response promise\n   */\n  static switchingProtocols = (request: ZuploRequest, context: ZuploContext, overrides?: Partial<ProblemDetails>, additionalHeaders?: HeadersInit) => this.#buildResponse(HttpStatusCode.SWITCHING_PROTOCOLS, request, context, overrides, additionalHeaders);\n  /**\n   * A WebDAV request may contain many sub-requests involving file operations, requiring a long time to complete the request. This code indicates that the server has received and is processing the request, but no response is available yet. This prevents the client from timing out and assuming the request was lost.\n   * @deprecated \u2014 This status code is deprecated and shouldn't be sent any more. Clients may still accept it, but simply ignore them.\n   * @param request - The ZuploRequest object\n   * @param context - The ZuploContext object\n   * @param overrides - Overrides to the problem\n   * @param additionalHeaders - Additional headers to send in the outgoing response\n   * @returns A HTTP response promise\n   */\n  static processing = (request: ZuploRequest, context: ZuploContext, overrides?: Partial<ProblemDetails>, additionalHeaders?: HeadersInit) => this.#buildResponse(HttpStatusCode.PROCESSING, request, context, overrides, additionalHeaders);\n  /**\n   * This response may be sent by a server while it is still preparing a\n   * response, with hints about the resources that the server is expecting\n   * the final response will link. This allows a browser to start preloading\n   * resources even before the server has prepared and sent that final response.\n   * \n   * @param request - The ZuploRequest object\n   * @param context - The ZuploContext object\n   * @param overrides - Overrides to the problem\n   * @param additionalHeaders - Additional headers to send in the outgoing response\n   * @returns A HTTP response promise\n   */\n  static earlyHints = (request: ZuploRequest, context: ZuploContext, overrides?: Partial<ProblemDetails>, additionalHeaders?: HeadersInit) => this.#buildResponse(HttpStatusCode.EARLY_HINTS, request, context, overrides, additionalHeaders);\n  /**\n   * Standard response for successful HTTP requests.\n   * The actual response will depend on the request method used.\n   * In a GET request, the response will contain an entity corresponding to the requested resource.\n   * In a POST request, the response will contain an entity describing or containing the result of the action.\n   * \n   * @param request - The ZuploRequest object\n   * @param context - The ZuploContext object\n   * @param overrides - Overrides to the problem\n   * @param additionalHeaders - Additional headers to send in the outgoing response\n   * @returns A HTTP response promise\n   */\n  static ok = (request: ZuploRequest, context: ZuploContext, overrides?: Partial<ProblemDetails>, additionalHeaders?: HeadersInit) => this.#buildResponse(HttpStatusCode.OK, request, context, overrides, additionalHeaders);\n  /**\n   * The request has been fulfilled, resulting in the creation of a new resource.\n   * \n   * @param request - The ZuploRequest object\n   * @param context - The ZuploContext object\n   * @param overrides - Overrides to the problem\n   * @param additionalHeaders - Additional headers to send in the outgoing response\n   * @returns A HTTP response promise\n   */\n  static created = (request: ZuploRequest, context: ZuploContext, overrides?: Partial<ProblemDetails>, additionalHeaders?: HeadersInit) => this.#buildResponse(HttpStatusCode.CREATED, request, context, overrides, additionalHeaders);\n  /**\n   * The request has been accepted for processing, but the processing has not been completed.\n   * The request might or might not be eventually acted upon, and may be disallowed when processing occurs.\n   * \n   * @param request - The ZuploRequest object\n   * @param context - The ZuploContext object\n   * @param overrides - Overrides to the problem\n   * @param additionalHeaders - Additional headers to send in the outgoing response\n   * @returns A HTTP response promise\n   */\n  static accepted = (request: ZuploRequest, context: ZuploContext, overrides?: Partial<ProblemDetails>, additionalHeaders?: HeadersInit) => this.#buildResponse(HttpStatusCode.ACCEPTED, request, context, overrides, additionalHeaders);\n  /**\n   * SINCE HTTP/1.1\n   * The server is a transforming proxy that received a 200 OK from its origin,\n   * but is returning a modified version of the origin's response.\n   * \n   * @param request - The ZuploRequest object\n   * @param context - The ZuploContext object\n   * @param overrides - Overrides to the problem\n   * @param additionalHeaders - Additional headers to send in the outgoing response\n   * @returns A HTTP response promise\n   */\n  static nonAuthoritativeInformation = (request: ZuploRequest, context: ZuploContext, overrides?: Partial<ProblemDetails>, additionalHeaders?: HeadersInit) => this.#buildResponse(HttpStatusCode.NON_AUTHORITATIVE_INFORMATION, request, context, overrides, additionalHeaders);\n  /**\n   * The server successfully processed the request and is not returning any content.\n   * \n   * @param request - The ZuploRequest object\n   * @param context - The ZuploContext object\n   * @param overrides - Overrides to the problem\n   * @param additionalHeaders - Additional headers to send in the outgoing response\n   * @returns A HTTP response promise\n   */\n  static noContent = (request: ZuploRequest, context: ZuploContext, overrides?: Partial<ProblemDetails>, additionalHeaders?: HeadersInit) => this.#buildResponse(HttpStatusCode.NO_CONTENT, request, context, overrides, additionalHeaders);\n  /**\n   * The server successfully processed the request, but is not returning any content.\n   * Unlike a 204 response, this response requires that the requester reset the document view.\n   * \n   * @param request - The ZuploRequest object\n   * @param context - The ZuploContext object\n   * @param overrides - Overrides to the problem\n   * @param additionalHeaders - Additional headers to send in the outgoing response\n   * @returns A HTTP response promise\n   */\n  static resetContent = (request: ZuploRequest, context: ZuploContext, overrides?: Partial<ProblemDetails>, additionalHeaders?: HeadersInit) => this.#buildResponse(HttpStatusCode.RESET_CONTENT, request, context, overrides, additionalHeaders);\n  /**\n   * The server is delivering only part of the resource (byte serving) due to a range header sent by the client.\n   * The range header is used by HTTP clients to enable resuming of interrupted downloads,\n   * or split a download into multiple simultaneous streams.\n   * \n   * @param request - The ZuploRequest object\n   * @param context - The ZuploContext object\n   * @param overrides - Overrides to the problem\n   * @param additionalHeaders - Additional headers to send in the outgoing response\n   * @returns A HTTP response promise\n   */\n  static partialContent = (request: ZuploRequest, context: ZuploContext, overrides?: Partial<ProblemDetails>, additionalHeaders?: HeadersInit) => this.#buildResponse(HttpStatusCode.PARTIAL_CONTENT, request, context, overrides, additionalHeaders);\n  /**\n   * The message body that follows is an XML message and can contain a number of separate response codes,\n   * depending on how many sub-requests were made.\n   * \n   * @param request - The ZuploRequest object\n   * @param context - The ZuploContext object\n   * @param overrides - Overrides to the problem\n   * @param additionalHeaders - Additional headers to send in the outgoing response\n   * @returns A HTTP response promise\n   */\n  static multiStatus = (request: ZuploRequest, context: ZuploContext, overrides?: Partial<ProblemDetails>, additionalHeaders?: HeadersInit) => this.#buildResponse(HttpStatusCode.MULTI_STATUS, request, context, overrides, additionalHeaders);\n  /**\n   * The members of a DAV binding have already been enumerated in a preceding part of the (multistatus) response,\n   * and are not being included again.\n   * \n   * @param request - The ZuploRequest object\n   * @param context - The ZuploContext object\n   * @param overrides - Overrides to the problem\n   * @param additionalHeaders - Additional headers to send in the outgoing response\n   * @returns A HTTP response promise\n   */\n  static alreadyReported = (request: ZuploRequest, context: ZuploContext, overrides?: Partial<ProblemDetails>, additionalHeaders?: HeadersInit) => this.#buildResponse(HttpStatusCode.ALREADY_REPORTED, request, context, overrides, additionalHeaders);\n  /**\n   * The server has fulfilled a request for the resource,\n   * and the response is a representation of the result of one or more instance-manipulations applied to the current instance.\n   * \n   * @param request - The ZuploRequest object\n   * @param context - The ZuploContext object\n   * @param overrides - Overrides to the problem\n   * @param additionalHeaders - Additional headers to send in the outgoing response\n   * @returns A HTTP response promise\n   */\n  static imUsed = (request: ZuploRequest, context: ZuploContext, overrides?: Partial<ProblemDetails>, additionalHeaders?: HeadersInit) => this.#buildResponse(HttpStatusCode.IM_USED, request, context, overrides, additionalHeaders);\n  /**\n   * Indicates multiple options for the resource from which the client may choose (via agent-driven content negotiation).\n   * For example, this code could be used to present multiple video format options,\n   * to list files with different filename extensions, or to suggest word-sense disambiguation.\n   * \n   * @param request - The ZuploRequest object\n   * @param context - The ZuploContext object\n   * @param overrides - Overrides to the problem\n   * @param additionalHeaders - Additional headers to send in the outgoing response\n   * @returns A HTTP response promise\n   */\n  static multipleChoices = (request: ZuploRequest, context: ZuploContext, overrides?: Partial<ProblemDetails>, additionalHeaders?: HeadersInit) => this.#buildResponse(HttpStatusCode.MULTIPLE_CHOICES, request, context, overrides, additionalHeaders);\n  /**\n   * This and all future requests should be directed to the given URI.\n   * \n   * @param request - The ZuploRequest object\n   * @param context - The ZuploContext object\n   * @param overrides - Overrides to the problem\n   * @param additionalHeaders - Additional headers to send in the outgoing response\n   * @returns A HTTP response promise\n   */\n  static movedPermanently = (request: ZuploRequest, context: ZuploContext, overrides?: Partial<ProblemDetails>, additionalHeaders?: HeadersInit) => this.#buildResponse(HttpStatusCode.MOVED_PERMANENTLY, request, context, overrides, additionalHeaders);\n  /**\n   * This is an example of industry practice contradicting the standard.\n   * The HTTP/1.0 specification (RFC 1945) required the client to perform a temporary redirect\n   * (the original describing phrase was \"Moved Temporarily\"), but popular browsers implemented 302\n   * with the functionality of a 303 See Other. Therefore, HTTP/1.1 added status codes 303 and 307\n   * to distinguish between the two behaviours. However, some Web applications and frameworks\n   * use the 302 status code as if it were the 303.\n   * \n   * @param request - The ZuploRequest object\n   * @param context - The ZuploContext object\n   * @param overrides - Overrides to the problem\n   * @param additionalHeaders - Additional headers to send in the outgoing response\n   * @returns A HTTP response promise\n   */\n  static found = (request: ZuploRequest, context: ZuploContext, overrides?: Partial<ProblemDetails>, additionalHeaders?: HeadersInit) => this.#buildResponse(HttpStatusCode.FOUND, request, context, overrides, additionalHeaders);\n  /**\n   * SINCE HTTP/1.1\n   * The response to the request can be found under another URI using a GET method.\n   * When received in response to a POST (or PUT/DELETE), the client should presume that\n   * the server has received the data and should issue a redirect with a separate GET message.\n   * \n   * @param request - The ZuploRequest object\n   * @param context - The ZuploContext object\n   * @param overrides - Overrides to the problem\n   * @param additionalHeaders - Additional headers to send in the outgoing response\n   * @returns A HTTP response promise\n   */\n  static seeOther = (request: ZuploRequest, context: ZuploContext, overrides?: Partial<ProblemDetails>, additionalHeaders?: HeadersInit) => this.#buildResponse(HttpStatusCode.SEE_OTHER, request, context, overrides, additionalHeaders);\n  /**\n   * Indicates that the resource has not been modified since the version specified by the request headers If-Modified-Since or If-None-Match.\n   * In such case, there is no need to retransmit the resource since the client still has a previously-downloaded copy.\n   * \n   * @param request - The ZuploRequest object\n   * @param context - The ZuploContext object\n   * @param overrides - Overrides to the problem\n   * @param additionalHeaders - Additional headers to send in the outgoing response\n   * @returns A HTTP response promise\n   */\n  static notModified = (request: ZuploRequest, context: ZuploContext, overrides?: Partial<ProblemDetails>, additionalHeaders?: HeadersInit) => this.#buildResponse(HttpStatusCode.NOT_MODIFIED, request, context, overrides, additionalHeaders);\n  /**\n   * SINCE HTTP/1.1\n   * The requested resource is available only through a proxy, the address for which is provided in the response.\n   * Many HTTP clients (such as Mozilla and Internet Explorer) do not correctly handle responses with this status code, primarily for security reasons.\n   * \n   * @param request - The ZuploRequest object\n   * @param context - The ZuploContext object\n   * @param overrides - Overrides to the problem\n   * @param additionalHeaders - Additional headers to send in the outgoing response\n   * @returns A HTTP response promise\n   */\n  static useProxy = (request: ZuploRequest, context: ZuploContext, overrides?: Partial<ProblemDetails>, additionalHeaders?: HeadersInit) => this.#buildResponse(HttpStatusCode.USE_PROXY, request, context, overrides, additionalHeaders);\n  /**\n   * No longer used. Originally meant \"Subsequent requests should use the specified proxy.\"\n   * \n   * @param request - The ZuploRequest object\n   * @param context - The ZuploContext object\n   * @param overrides - Overrides to the problem\n   * @param additionalHeaders - Additional headers to send in the outgoing response\n   * @returns A HTTP response promise\n   * @deprecated No longer used\n   */\n  static switchProxy = (request: ZuploRequest, context: ZuploContext, overrides?: Partial<ProblemDetails>, additionalHeaders?: HeadersInit) => this.#buildResponse(HttpStatusCode.SWITCH_PROXY, request, context, overrides, additionalHeaders);\n  /**\n   * SINCE HTTP/1.1\n   * In this case, the request should be repeated with another URI; however, future requests should still use the original URI.\n   * In contrast to how 302 was historically implemented, the request method is not allowed to be changed when reissuing the original request.\n   * For example, a POST request should be repeated using another POST request.\n   * \n   * @param request - The ZuploRequest object\n   * @param context - The ZuploContext object\n   * @param overrides - Overrides to the problem\n   * @param additionalHeaders - Additional headers to send in the outgoing response\n   * @returns A HTTP response promise\n   */\n  static temporaryRedirect = (request: ZuploRequest, context: ZuploContext, overrides?: Partial<ProblemDetails>, additionalHeaders?: HeadersInit) => this.#buildResponse(HttpStatusCode.TEMPORARY_REDIRECT, request, context, overrides, additionalHeaders);\n  /**\n   * The request and all future requests should be repeated using another URI.\n   * 307 and 308 parallel the behaviors of 302 and 301, but do not allow the HTTP method to change.\n   * So, for example, submitting a form to a permanently redirected resource may continue smoothly.\n   * \n   * @param request - The ZuploRequest object\n   * @param context - The ZuploContext object\n   * @param overrides - Overrides to the problem\n   * @param additionalHeaders - Additional headers to send in the outgoing response\n   * @returns A HTTP response promise\n   */\n  static permanentRedirect = (request: ZuploRequest, context: ZuploContext, overrides?: Partial<ProblemDetails>, additionalHeaders?: HeadersInit) => this.#buildResponse(HttpStatusCode.PERMANENT_REDIRECT, request, context, overrides, additionalHeaders);\n  /**\n   * The server cannot or will not process the request due to an apparent client error\n   * (e.g., malformed request syntax, too large size, invalid request message framing, or deceptive request routing).\n   * \n   * @param request - The ZuploRequest object\n   * @param context - The ZuploContext object\n   * @param overrides - Overrides to the problem\n   * @param additionalHeaders - Additional headers to send in the outgoing response\n   * @returns A HTTP response promise\n   */\n  static badRequest = (request: ZuploRequest, context: ZuploContext, overrides?: Partial<ProblemDetails>, additionalHeaders?: HeadersInit) => this.#buildResponse(HttpStatusCode.BAD_REQUEST, request, context, overrides, additionalHeaders);\n  /**\n   * Similar to 403 Forbidden, but specifically for use when authentication is required and has failed or has not yet\n   * been provided. The response must include a WWW-Authenticate header field containing a challenge applicable to the\n   * requested resource. See Basic access authentication and Digest access authentication. 401 semantically means\n   * \"unauthenticated\",i.e. the user does not have the necessary credentials.\n   * \n   * @param request - The ZuploRequest object\n   * @param context - The ZuploContext object\n   * @param overrides - Overrides to the problem\n   * @param additionalHeaders - Additional headers to send in the outgoing response\n   * @returns A HTTP response promise\n   */\n  static unauthorized = (request: ZuploRequest, context: ZuploContext, overrides?: Partial<ProblemDetails>, additionalHeaders?: HeadersInit) => this.#buildResponse(HttpStatusCode.UNAUTHORIZED, request, context, overrides, additionalHeaders);\n  /**\n   * Reserved for future use. The original intention was that this code might be used as part of some form of digital\n   * cash or micro payment scheme, but that has not happened, and this code is not usually used.\n   * Google Developers API uses this status if a particular developer has exceeded the daily limit on requests.\n   * \n   * @param request - The ZuploRequest object\n   * @param context - The ZuploContext object\n   * @param overrides - Overrides to the problem\n   * @param additionalHeaders - Additional headers to send in the outgoing response\n   * @returns A HTTP response promise\n   */\n  static paymentRequired = (request: ZuploRequest, context: ZuploContext, overrides?: Partial<ProblemDetails>, additionalHeaders?: HeadersInit) => this.#buildResponse(HttpStatusCode.PAYMENT_REQUIRED, request, context, overrides, additionalHeaders);\n  /**\n   * The request was valid, but the server is refusing action.\n   * The user might not have the necessary permissions for a resource.\n   * \n   * @param request - The ZuploRequest object\n   * @param context - The ZuploContext object\n   * @param overrides - Overrides to the problem\n   * @param additionalHeaders - Additional headers to send in the outgoing response\n   * @returns A HTTP response promise\n   */\n  static forbidden = (request: ZuploRequest, context: ZuploContext, overrides?: Partial<ProblemDetails>, additionalHeaders?: HeadersInit) => this.#buildResponse(HttpStatusCode.FORBIDDEN, request, context, overrides, additionalHeaders);\n  /**\n   * The requested resource could not be found but may be available in the future.\n   * Subsequent requests by the client are permissible.\n   * \n   * @param request - The ZuploRequest object\n   * @param context - The ZuploContext object\n   * @param overrides - Overrides to the problem\n   * @param additionalHeaders - Additional headers to send in the outgoing response\n   * @returns A HTTP response promise\n   */\n  static notFound = (request: ZuploRequest, context: ZuploContext, overrides?: Partial<ProblemDetails>, additionalHeaders?: HeadersInit) => this.#buildResponse(HttpStatusCode.NOT_FOUND, request, context, overrides, additionalHeaders);\n  /**\n   * A request method is not supported for the requested resource;\n   * for example, a GET request on a form that requires data to be presented via POST, or a PUT request on a read-only resource.\n   * \n   * @param request - The ZuploRequest object\n   * @param context - The ZuploContext object\n   * @param overrides - Overrides to the problem\n   * @param additionalHeaders - Additional headers to send in the outgoing response\n   * @returns A HTTP response promise\n   */\n  static methodNotAllowed = (request: ZuploRequest, context: ZuploContext, overrides?: Partial<ProblemDetails>, additionalHeaders?: HeadersInit) => this.#buildResponse(HttpStatusCode.METHOD_NOT_ALLOWED, request, context, overrides, additionalHeaders);\n  /**\n   * The requested resource is capable of generating only content not acceptable according to the Accept headers sent in the request.\n   * \n   * @param request - The ZuploRequest object\n   * @param context - The ZuploContext object\n   * @param overrides - Overrides to the problem\n   * @param additionalHeaders - Additional headers to send in the outgoing response\n   * @returns A HTTP response promise\n   */\n  static notAcceptable = (request: ZuploRequest, context: ZuploContext, overrides?: Partial<ProblemDetails>, additionalHeaders?: HeadersInit) => this.#buildResponse(HttpStatusCode.NOT_ACCEPTABLE, request, context, overrides, additionalHeaders);\n  /**\n   * The client must first authenticate itself with the proxy.\n   * \n   * @param request - The ZuploRequest object\n   * @param context - The ZuploContext object\n   * @param overrides - Overrides to the problem\n   * @param additionalHeaders - Additional headers to send in the outgoing response\n   * @returns A HTTP response promise\n   */\n  static proxyAuthenticationRequired = (request: ZuploRequest, context: ZuploContext, overrides?: Partial<ProblemDetails>, additionalHeaders?: HeadersInit) => this.#buildResponse(HttpStatusCode.PROXY_AUTHENTICATION_REQUIRED, request, context, overrides, additionalHeaders);\n  /**\n   * The server timed out waiting for the request.\n   * According to HTTP specifications:\n   * \"The client did not produce a request within the time that the server was prepared to wait. The client MAY repeat the request without modifications at any later time.\"\n   * \n   * @param request - The ZuploRequest object\n   * @param context - The ZuploContext object\n   * @param overrides - Overrides to the problem\n   * @param additionalHeaders - Additional headers to send in the outgoing response\n   * @returns A HTTP response promise\n   */\n  static requestTimeout = (request: ZuploRequest, context: ZuploContext, overrides?: Partial<ProblemDetails>, additionalHeaders?: HeadersInit) => this.#buildResponse(HttpStatusCode.REQUEST_TIMEOUT, request, context, overrides, additionalHeaders);\n  /**\n   * Indicates that the request could not be processed because of conflict in the request,\n   * such as an edit conflict between multiple simultaneous updates.\n   * \n   * @param request - The ZuploRequest object\n   * @param context - The ZuploContext object\n   * @param overrides - Overrides to the problem\n   * @param additionalHeaders - Additional headers to send in the outgoing response\n   * @returns A HTTP response promise\n   */\n  static conflict = (request: ZuploRequest, context: ZuploContext, overrides?: Partial<ProblemDetails>, additionalHeaders?: HeadersInit) => this.#buildResponse(HttpStatusCode.CONFLICT, request, context, overrides, additionalHeaders);\n  /**\n   * Indicates that the resource requested is no longer available and will not be available again.\n   * This should be used when a resource has been intentionally removed and the resource should be purged.\n   * Upon receiving a 410 status code, the client should not request the resource in the future.\n   * Clients such as search engines should remove the resource from their indices.\n   * Most use cases do not require clients and search engines to purge the resource, and a \"404 Not Found\" may be used instead.\n   * \n   * @param request - The ZuploRequest object\n   * @param context - The ZuploContext object\n   * @param overrides - Overrides to the problem\n   * @param additionalHeaders - Additional headers to send in the outgoing response\n   * @returns A HTTP response promise\n   */\n  static gone = (request: ZuploRequest, context: ZuploContext, overrides?: Partial<ProblemDetails>, additionalHeaders?: HeadersInit) => this.#buildResponse(HttpStatusCode.GONE, request, context, overrides, additionalHeaders);\n  /**\n   * The request did not specify the length of its content, which is required by the requested resource.\n   * \n   * @param request - The ZuploRequest object\n   * @param context - The ZuploContext object\n   * @param overrides - Overrides to the problem\n   * @param additionalHeaders - Additional headers to send in the outgoing response\n   * @returns A HTTP response promise\n   */\n  static lengthRequired = (request: ZuploRequest, context: ZuploContext, overrides?: Partial<ProblemDetails>, additionalHeaders?: HeadersInit) => this.#buildResponse(HttpStatusCode.LENGTH_REQUIRED, request, context, overrides, additionalHeaders);\n  /**\n   * The server does not meet one of the preconditions that the requester put on the request.\n   * \n   * @param request - The ZuploRequest object\n   * @param context - The ZuploContext object\n   * @param overrides - Overrides to the problem\n   * @param additionalHeaders - Additional headers to send in the outgoing response\n   * @returns A HTTP response promise\n   */\n  static preconditionFailed = (request: ZuploRequest, context: ZuploContext, overrides?: Partial<ProblemDetails>, additionalHeaders?: HeadersInit) => this.#buildResponse(HttpStatusCode.PRECONDITION_FAILED, request, context, overrides, additionalHeaders);\n  /**\n   * The request is larger than the server is willing or able to process. Previously called \"Request Entity Too Large\".\n   * \n   * @param request - The ZuploRequest object\n   * @param context - The ZuploContext object\n   * @param overrides - Overrides to the problem\n   * @param additionalHeaders - Additional headers to send in the outgoing response\n   * @returns A HTTP response promise\n   */\n  static contentTooLarge = (request: ZuploRequest, context: ZuploContext, overrides?: Partial<ProblemDetails>, additionalHeaders?: HeadersInit) => this.#buildResponse(HttpStatusCode.CONTENT_TOO_LARGE, request, context, overrides, additionalHeaders);\n  /**\n   * The URI provided was too long for the server to process. Often the result of too much data being encoded as a query-string of a GET request,\n   * in which case it should be converted to a POST request.\n   * Called \"Request-URI Too Long\" previously.\n   * \n   * @param request - The ZuploRequest object\n   * @param context - The ZuploContext object\n   * @param overrides - Overrides to the problem\n   * @param additionalHeaders - Additional headers to send in the outgoing response\n   * @returns A HTTP response promise\n   */\n  static uriTooLong = (request: ZuploRequest, context: ZuploContext, overrides?: Partial<ProblemDetails>, additionalHeaders?: HeadersInit) => this.#buildResponse(HttpStatusCode.URI_TOO_LONG, request, context, overrides, additionalHeaders);\n  /**\n   * The request entity has a media type which the server or resource does not support.\n   * For example, the client uploads an image as image/svg+xml, but the server requires that images use a different format.\n   * \n   * @param request - The ZuploRequest object\n   * @param context - The ZuploContext object\n   * @param overrides - Overrides to the problem\n   * @param additionalHeaders - Additional headers to send in the outgoing response\n   * @returns A HTTP response promise\n   */\n  static unsupportedMediaType = (request: ZuploRequest, context: ZuploContext, overrides?: Partial<ProblemDetails>, additionalHeaders?: HeadersInit) => this.#buildResponse(HttpStatusCode.UNSUPPORTED_MEDIA_TYPE, request, context, overrides, additionalHeaders);\n  /**\n   * The client has asked for a portion of the file (byte serving), but the server cannot supply that portion.\n   * For example, if the client asked for a part of the file that lies beyond the end of the file.\n   * Called \"Requested Range Not Satisfiable\" previously.\n   * \n   * @param request - The ZuploRequest object\n   * @param context - The ZuploContext object\n   * @param overrides - Overrides to the problem\n   * @param additionalHeaders - Additional headers to send in the outgoing response\n   * @returns A HTTP response promise\n   */\n  static rangeNotSatisfiable = (request: ZuploRequest, context: ZuploContext, overrides?: Partial<ProblemDetails>, additionalHeaders?: HeadersInit) => this.#buildResponse(HttpStatusCode.RANGE_NOT_SATISFIABLE, request, context, overrides, additionalHeaders);\n  /**\n   * The server cannot meet the requirements of the Expect request-header field.\n   * \n   * @param request - The ZuploRequest object\n   * @param context - The ZuploContext object\n   * @param overrides - Overrides to the problem\n   * @param additionalHeaders - Additional headers to send in the outgoing response\n   * @returns A HTTP response promise\n   */\n  static expectationFailed = (request: ZuploRequest, context: ZuploContext, overrides?: Partial<ProblemDetails>, additionalHeaders?: HeadersInit) => this.#buildResponse(HttpStatusCode.EXPECTATION_FAILED, request, context, overrides, additionalHeaders);\n  /**\n   * This code was defined in 1998 as one of the traditional IETF April Fools' jokes, in RFC 2324, Hyper Text Coffee Pot Control Protocol,\n   * and is not expected to be implemented by actual HTTP servers. The RFC specifies this code should be returned by\n   * teapots requested to brew coffee. This HTTP status is used as an Easter egg in some websites, including Google.com.\n   * \n   * @param request - The ZuploRequest object\n   * @param context - The ZuploContext object\n   * @param overrides - Overrides to the problem\n   * @param additionalHeaders - Additional headers to send in the outgoing response\n   * @returns A HTTP response promise\n   */\n  static imATeapot = (request: ZuploRequest, context: ZuploContext, overrides?: Partial<ProblemDetails>, additionalHeaders?: HeadersInit) => this.#buildResponse(HttpStatusCode.I_AM_A_TEAPOT, request, context, overrides, additionalHeaders);\n  /**\n   * The request was directed at a server that is not able to produce a response (for example because a connection reuse).\n   * \n   * @param request - The ZuploRequest object\n   * @param context - The ZuploContext object\n   * @param overrides - Overrides to the problem\n   * @param additionalHeaders - Additional headers to send in the outgoing response\n   * @returns A HTTP response promise\n   */\n  static misdirectedRequest = (request: ZuploRequest, context: ZuploContext, overrides?: Partial<ProblemDetails>, additionalHeaders?: HeadersInit) => this.#buildResponse(HttpStatusCode.MISDIRECTED_REQUEST, request, context, overrides, additionalHeaders);\n  /**\n   * The request was well-formed but was unable to be followed due to semantic errors.\n   * \n   * @param request - The ZuploRequest object\n   * @param context - The ZuploContext object\n   * @param overrides - Overrides to the problem\n   * @param additionalHeaders - Additional headers to send in the outgoing response\n   * @returns A HTTP response promise\n   */\n  static unprocessableContent = (request: ZuploRequest, context: ZuploContext, overrides?: Partial<ProblemDetails>, additionalHeaders?: HeadersInit) => this.#buildResponse(HttpStatusCode.UNPROCESSABLE_CONTENT, request, context, overrides, additionalHeaders);\n  /**\n   * The resource that is being accessed is locked.\n   * \n   * @param request - The ZuploRequest object\n   * @param context - The ZuploContext object\n   * @param overrides - Overrides to the problem\n   * @param additionalHeaders - Additional headers to send in the outgoing response\n   * @returns A HTTP response promise\n   */\n  static locked = (request: ZuploRequest, context: ZuploContext, overrides?: Partial<ProblemDetails>, additionalHeaders?: HeadersInit) => this.#buildResponse(HttpStatusCode.LOCKED, request, context, overrides, additionalHeaders);\n  /**\n   * The request failed due to failure of a previous request (e.g., a PROPPATCH).\n   * \n   * @param request - The ZuploRequest object\n   * @param context - The ZuploContext object\n   * @param overrides - Overrides to the problem\n   * @param additionalHeaders - Additional headers to send in the outgoing response\n   * @returns A HTTP response promise\n   */\n  static failedDependency = (request: ZuploRequest, context: ZuploContext, overrides?: Partial<ProblemDetails>, additionalHeaders?: HeadersInit) => this.#buildResponse(HttpStatusCode.FAILED_DEPENDENCY, request, context, overrides, additionalHeaders);\n  /**\n   * The server is unwilling to risk processing a request that might be\n   * replayed, which creates the potential for a replay attack.\n   * \n   * @param request - The ZuploRequest object\n   * @param context - The ZuploContext object\n   * @param overrides - Overrides to the problem\n   * @param additionalHeaders - Additional headers to send in the outgoing response\n   * @returns A HTTP response promise\n   */\n  static tooEarly = (request: ZuploRequest, context: ZuploContext, overrides?: Partial<ProblemDetails>, additionalHeaders?: HeadersInit) => this.#buildResponse(HttpStatusCode.TOO_EARLY, request, context, overrides, additionalHeaders);\n  /**\n   * The client should switch to a different protocol such as TLS/1.0, given in the Upgrade header field.\n   * \n   * @param request - The ZuploRequest object\n   * @param context - The ZuploContext object\n   * @param overrides - Overrides to the problem\n   * @param additionalHeaders - Additional headers to send in the outgoing response\n   * @returns A HTTP response promise\n   */\n  static upgradeRequired = (request: ZuploRequest, context: ZuploContext, overrides?: Partial<ProblemDetails>, additionalHeaders?: HeadersInit) => this.#buildResponse(HttpStatusCode.UPGRADE_REQUIRED, request, context, overrides, additionalHeaders);\n  /**\n   * The origin server requires the request to be conditional.\n   * Intended to prevent \"the 'lost update' problem, where a client\n   * GETs a resource's state, modifies it, and PUTs it back to the server,\n   * when meanwhile a third party has modified the state on the server, leading to a conflict.\"\n   * \n   * @param request - The ZuploRequest object\n   * @param context - The ZuploContext object\n   * @param overrides - Overrides to the problem\n   * @param additionalHeaders - Additional headers to send in the outgoing response\n   * @returns A HTTP response promise\n   */\n  static preconditionRequired = (request: ZuploRequest, context: ZuploContext, overrides?: Partial<ProblemDetails>, additionalHeaders?: HeadersInit) => this.#buildResponse(HttpStatusCode.PRECONDITION_REQUIRED, request, context, overrides, additionalHeaders);\n  /**\n   * The user has sent too many requests in a given amount of time. Intended for use with rate-limiting schemes.\n   * \n   * @param request - The ZuploRequest object\n   * @param context - The ZuploContext object\n   * @param overrides - Overrides to the problem\n   * @param additionalHeaders - Additional headers to send in the outgoing response\n   * @returns A HTTP response promise\n   */\n  static tooManyRequests = (request: ZuploRequest, context: ZuploContext, overrides?: Partial<ProblemDetails>, additionalHeaders?: HeadersInit) => this.#buildResponse(HttpStatusCode.TOO_MANY_REQUESTS, request, context, overrides, additionalHeaders);\n  /**\n   * The server is unwilling to process the request because either an individual header field,\n   * or all the header fields collectively, are too large.\n   * \n   * @param request - The ZuploRequest object\n   * @param context - The ZuploContext object\n   * @param overrides - Overrides to the problem\n   * @param additionalHeaders - Additional headers to send in the outgoing response\n   * @returns A HTTP response promise\n   */\n  static requestHeaderFieldsTooLarge = (request: ZuploRequest, context: ZuploContext, overrides?: Partial<ProblemDetails>, additionalHeaders?: HeadersInit) => this.#buildResponse(HttpStatusCode.REQUEST_HEADER_FIELDS_TOO_LARGE, request, context, overrides, additionalHeaders);\n  /**\n   * A server operator has received a legal demand to deny access to a resource or to a set of resources\n   * that includes the requested resource. The code 451 was chosen as a reference to the novel Fahrenheit 451.\n   * \n   * @param request - The ZuploRequest object\n   * @param context - The ZuploContext object\n   * @param overrides - Overrides to the problem\n   * @param additionalHeaders - Additional headers to send in the outgoing response\n   * @returns A HTTP response promise\n   */\n  static unavailableForLegalReasons = (request: ZuploRequest, context: ZuploContext, overrides?: Partial<ProblemDetails>, additionalHeaders?: HeadersInit) => this.#buildResponse(HttpStatusCode.UNAVAILABLE_FOR_LEGAL_REASONS, request, context, overrides, additionalHeaders);\n  /**\n   * A generic error message, given when an unexpected condition was encountered and no more specific message is suitable.\n   * \n   * @param request - The ZuploRequest object\n   * @param context - The ZuploContext object\n   * @param overrides - Overrides to the problem\n   * @param additionalHeaders - Additional headers to send in the outgoing response\n   * @returns A HTTP response promise\n   */\n  static internalServerError = (request: ZuploRequest, context: ZuploContext, overrides?: Partial<ProblemDetails>, additionalHeaders?: HeadersInit) => this.#buildResponse(HttpStatusCode.INTERNAL_SERVER_ERROR, request, context, overrides, additionalHeaders);\n  /**\n   * The server either does not recognize the request method, or it lacks the ability to fulfill the request.\n   * Usually this implies future availability (e.g., a new feature of a web-service API).\n   * \n   * @param request - The ZuploRequest object\n   * @param context - The ZuploContext object\n   * @param overrides - Overrides to the problem\n   * @param additionalHeaders - Additional headers to send in the outgoing response\n   * @returns A HTTP response promise\n   */\n  static notImplemented = (request: ZuploRequest, context: ZuploContext, overrides?: Partial<ProblemDetails>, additionalHeaders?: HeadersInit) => this.#buildResponse(HttpStatusCode.NOT_IMPLEMENTED, request, context, overrides, additionalHeaders);\n  /**\n   * The server was acting as a gateway or proxy and received an invalid response from the upstream server.\n   * \n   * @param request - The ZuploRequest object\n   * @param context - The ZuploContext object\n   * @param overrides - Overrides to the problem\n   * @param additionalHeaders - Additional headers to send in the outgoing response\n   * @returns A HTTP response promise\n   */\n  static badGateway = (request: ZuploRequest, context: ZuploContext, overrides?: Partial<ProblemDetails>, additionalHeaders?: HeadersInit) => this.#buildResponse(HttpStatusCode.BAD_GATEWAY, request, context, overrides, additionalHeaders);\n  /**\n   * The server is currently unavailable (because it is overloaded or down for maintenance).\n   * Generally, this is a temporary state.\n   * \n   * @param request - The ZuploRequest object\n   * @param context - The ZuploContext object\n   * @param overrides - Overrides to the problem\n   * @param additionalHeaders - Additional headers to send in the outgoing response\n   * @returns A HTTP response promise\n   */\n  static serviceUnavailable = (request: ZuploRequest, context: ZuploContext, overrides?: Partial<ProblemDetails>, additionalHeaders?: HeadersInit) => this.#buildResponse(HttpStatusCode.SERVICE_UNAVAILABLE, request, context, overrides, additionalHeaders);\n  /**\n   * The server was acting as a gateway or proxy and did not receive a timely response from the upstream server.\n   * \n   * @param request - The ZuploRequest object\n   * @param context - The ZuploContext object\n   * @param overrides - Overrides to the problem\n   * @param additionalHeaders - Additional headers to send in the outgoing response\n   * @returns A HTTP response promise\n   */\n  static gatewayTimeout = (request: ZuploRequest, context: ZuploContext, overrides?: Partial<ProblemDetails>, additionalHeaders?: HeadersInit) => this.#buildResponse(HttpStatusCode.GATEWAY_TIMEOUT, request, context, overrides, additionalHeaders);\n  /**\n   * The server does not support the HTTP protocol version used in the request\n   * \n   * @param request - The ZuploRequest object\n   * @param context - The ZuploContext object\n   * @param overrides - Overrides to the problem\n   * @param additionalHeaders - Additional headers to send in the outgoing response\n   * @returns A HTTP response promise\n   */\n  static httpVersionNotSupported = (request: ZuploRequest, context: ZuploContext, overrides?: Partial<ProblemDetails>, additionalHeaders?: HeadersInit) => this.#buildResponse(HttpStatusCode.HTTP_VERSION_NOT_SUPPORTED, request, context, overrides, additionalHeaders);\n  /**\n   * Transparent content negotiation for the request results in a circular reference.\n   * \n   * @param request - The ZuploRequest object\n   * @param context - The ZuploContext object\n   * @param overrides - Overrides to the problem\n   * @param additionalHeaders - Additional headers to send in the outgoing response\n   * @returns A HTTP response promise\n   */\n  static variantAlsoNegotiates = (request: ZuploRequest, context: ZuploContext, overrides?: Partial<ProblemDetails>, additionalHeaders?: HeadersInit) => this.#buildResponse(HttpStatusCode.VARIANT_ALSO_NEGOTIATES, request, context, overrides, additionalHeaders);\n  /**\n   * The server is unable to store the representation needed to complete the request.\n   * \n   * @param request - The ZuploRequest object\n   * @param context - The ZuploContext object\n   * @param overrides - Overrides to the problem\n   * @param additionalHeaders - Additional headers to send in the outgoing response\n   * @returns A HTTP response promise\n   */\n  static insufficientStorage = (request: ZuploRequest, context: ZuploContext, overrides?: Partial<ProblemDetails>, additionalHeaders?: HeadersInit) => this.#buildResponse(HttpStatusCode.INSUFFICIENT_STORAGE, request, context, overrides, additionalHeaders);\n  /**\n   * The server detected an infinite loop while processing the request.\n   * \n   * @param request - The ZuploRequest object\n   * @param context - The ZuploContext object\n   * @param overrides - Overrides to the problem\n   * @param additionalHeaders - Additional headers to send in the outgoing response\n   * @returns A HTTP response promise\n   */\n  static loopDetected = (request: ZuploRequest, context: ZuploContext, overrides?: Partial<ProblemDetails>, additionalHeaders?: HeadersInit) => this.#buildResponse(HttpStatusCode.LOOP_DETECTED, request, context, overrides, additionalHeaders);\n  /**\n   * Further extensions to the request are required for the server to fulfill it.\n   * \n   * @param request - The ZuploRequest object\n   * @param context - The ZuploContext object\n   * @param overrides - Overrides to the problem\n   * @param additionalHeaders - Additional headers to send in the outgoing response\n   * @returns A HTTP response promise\n   */\n  static notExtended = (request: ZuploRequest, context: ZuploContext, overrides?: Partial<ProblemDetails>, additionalHeaders?: HeadersInit) => this.#buildResponse(HttpStatusCode.NOT_EXTENDED, request, context, overrides, additionalHeaders);\n  /**\n   * The client needs to authenticate to gain network access.\n   * Intended for use by intercepting proxies used to control access to the network (e.g., \"captive portals\" used\n   * to require agreement to Terms of Service before granting full Internet access via a Wi-Fi hotspot).\n   * \n   * @param request - The ZuploRequest object\n   * @param context - The ZuploContext object\n   * @param overrides - Overrides to the problem\n   * @param additionalHeaders - Additional headers to send in the outgoing response\n   * @returns A HTTP response promise\n   */\n  static networkAuthenticationRequired = (request: ZuploRequest, context: ZuploContext, overrides?: Partial<ProblemDetails>, additionalHeaders?: HeadersInit) => this.#buildResponse(HttpStatusCode.NETWORK_AUTHENTICATION_REQUIRED, request, context, overrides, additionalHeaders);\n}\n", "/* eslint-disable @typescript-eslint/no-explicit-any */\n/* eslint-disable @typescript-eslint/ban-types */\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n// Source: https://github.com/microsoft/vscode/blob/main/src/vs/base/common/types.ts\n\nconst { toString: toStringProto } = Object.prototype;\nconst { propertyIsEnumerable } = Object.prototype;\n\nexport function toString(value: unknown): string {\n  return toStringProto.call(value);\n}\n\n/**\n * @returns whether the provided parameter is a JavaScript String or not.\n */\nexport function isString(value: unknown): value is string {\n  return typeof value === \"string\";\n}\n\n/**\n * Validates that a value is a non-empty string.\n *\n * @param value - The value to validate.\n * @returns Whether the value is a non-empty string or not.\n */\nexport function isNonEmptyString(value: unknown): value is string {\n  return isString(value) && value !== \"\";\n}\n\n/**\n * @returns whether the provided parameter is a JavaScript Array and each element in the array is a string.\n */\nexport function isStringArray(value: unknown): value is string[] {\n  return (\n    Array.isArray(value) && (<unknown[]>value).every((elem) => isString(elem))\n  );\n}\n\n/**\nCheck if a value is a regular expression.\n\n@example\n```\nimport isRegexp from 'is-regexp';\n\nisRegexp('unicorn');\n//=> false\n\nisRegexp(/unicorn/);\n//=> true\n\nisRegexp(new RegExp('unicorn'));\n//=> true\n```\nSource: https://github.com/sindresorhus/is-regexp/blob/main/index.js\n*/\nexport function isRegexp(value: unknown): value is RegExp {\n  return toString(value) === \"[object RegExp]\";\n}\n\n/**\nLike [`Object.keys()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys) but also includes [symbols](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol)\n\n@example\n```\nimport getOwnEnumerableKeys from 'get-own-enumerable-keys';\n\nconst symbol = Symbol('x');\n\nconst object = {\n\tfoo: true,\n\t[symbol]: true,\n};\n\nObject.keys(object);\n// ['foo']\n\ngetOwnEnumerableKeys(object);\n//=> ['foo', Symbol('x')]\n```\n\nSource: https://github.com/sindresorhus/get-own-enumerable-keys/blob/main/index.js\n*/\nexport function getOwnEnumerableKeys(object: object) {\n  return [\n    ...Object.keys(object),\n    ...Object.getOwnPropertySymbols(object).filter((key) =>\n      propertyIsEnumerable.call(object, key)\n    ),\n  ];\n}\n\n/**\n * @returns whether the provided parameter is of type `object` but **not**\n *\t`null`, an `array`, a `regexp`, nor a `date`.\n */\nexport function isObject(obj: unknown): obj is Object {\n  // The method can't do a type cast since there are type (like strings) which\n  // are subclasses of any put not positvely matched by the function. Hence type\n  // narrowing results in wrong results.\n  return (\n    typeof obj === \"object\" &&\n    obj !== null &&\n    !Array.isArray(obj) &&\n    !(obj instanceof RegExp) &&\n    !(obj instanceof Date)\n  );\n}\n\nexport function isArray(obj: unknown): obj is any[] {\n  return isObject(obj) && Array.isArray(obj);\n}\n\n/**\n * @returns whether the provided parameter is of type `Buffer` or Uint8Array dervived type\n */\nexport function isTypedArray(obj: unknown): obj is Object {\n  const TypedArray = Object.getPrototypeOf(Uint8Array);\n  return typeof obj === \"object\" && obj instanceof TypedArray;\n}\n\n/**\n * In **contrast** to just checking `typeof` this will return `false` for `NaN`.\n * @returns whether the provided parameter is a JavaScript Number or not.\n */\nexport function isNumber(obj: unknown): obj is number {\n  return typeof obj === \"number\" && !isNaN(obj);\n}\n\n/**\n * @returns whether the provided parameter is an Iterable, casting to the given generic\n */\nexport function isIterable<T>(obj: unknown): obj is Iterable<T> {\n  return !!obj && typeof (obj as any)[Symbol.iterator] === \"function\";\n}\n\n/**\n * @returns whether the provided parameter is a JavaScript Boolean or not.\n */\nexport function isBoolean(obj: unknown): obj is boolean {\n  return obj === true || obj === false;\n}\n\n/**\n * @returns whether the provided parameter is undefined.\n */\nexport function isUndefined(obj: unknown): obj is undefined {\n  return typeof obj === \"undefined\";\n}\n\n/**\n * @returns whether the provided parameter is defined.\n */\nexport function isDefined<T>(arg: T | null | undefined): arg is T {\n  return !isUndefinedOrNull(arg);\n}\n\n/**\n * @returns whether the provided parameter is undefined or null.\n */\nexport function isUndefinedOrNull(obj: unknown): obj is undefined | null {\n  return isUndefined(obj) || obj === null;\n}\n\nexport function assertType(\n  condition: unknown,\n  type?: string\n): asserts condition {\n  if (!condition) {\n    throw new Error(\n      type ? `Unexpected type, expected '${type}'` : \"Unexpected type\"\n    );\n  }\n}\n\n/**\n * Asserts that the argument passed in is neither undefined nor null.\n */\nexport function assertIsDefined<T>(arg: T | null | undefined): T {\n  if (isUndefinedOrNull(arg)) {\n    throw new Error(\"Assertion Failed: argument is undefined or null\");\n  }\n\n  return arg;\n}\n\n/**\n * Asserts that each argument passed in is neither undefined nor null.\n */\nexport function assertAllDefined<T1, T2>(\n  t1: T1 | null | undefined,\n  t2: T2 | null | undefined\n): [T1, T2];\nexport function assertAllDefined<T1, T2, T3>(\n  t1: T1 | null | undefined,\n  t2: T2 | null | undefined,\n  t3: T3 | null | undefined\n): [T1, T2, T3];\nexport function assertAllDefined<T1, T2, T3, T4>(\n  t1: T1 | null | undefined,\n  t2: T2 | null | undefined,\n  t3: T3 | null | undefined,\n  t4: T4 | null | undefined\n): [T1, T2, T3, T4];\n\nexport function assertAllDefined(\n  ...args: (unknown | null | undefined)[]\n): unknown[] {\n  const result: unknown[] = [];\n\n  for (let i = 0; i < args.length; i++) {\n    const arg = args[i];\n\n    if (isUndefinedOrNull(arg)) {\n      throw new Error(\n        `Assertion Failed: argument at index ${i} is undefined or null`\n      );\n    }\n\n    result.push(arg);\n  }\n\n  return result;\n}\n\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\n\n/**\n * @returns whether the provided parameter is an empty JavaScript Object or not.\n */\nexport function isEmptyObject(obj: unknown): obj is object {\n  if (!isObject(obj)) {\n    return false;\n  }\n\n  for (const key in obj) {\n    if (hasOwnProperty.call(obj, key)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * @returns whether the provided parameter is a JavaScript Function or not.\n */\nexport function isFunction(obj: unknown): obj is Function {\n  return typeof obj === \"function\";\n}\n\n/**\n * @returns whether the provided parameters is are JavaScript Function or not.\n */\nexport function areFunctions(...objects: unknown[]): boolean {\n  return objects.length > 0 && objects.every(isFunction);\n}\n\nexport type TypeConstraint = string | Function;\n\nexport function validateConstraints(\n  args: unknown[],\n  constraints: Array<TypeConstraint | undefined>\n): void {\n  const len = Math.min(args.length, constraints.length);\n  for (let i = 0; i < len; i++) {\n    validateConstraint(args[i], constraints[i]);\n  }\n}\n\nexport function validateConstraint(\n  arg: unknown,\n  constraint: TypeConstraint | undefined\n): void {\n  if (isString(constraint)) {\n    if (typeof arg !== constraint) {\n      throw new Error(\n        `argument does not match constraint: typeof ${constraint}`\n      );\n    }\n  } else if (isFunction(constraint)) {\n    try {\n      if (arg instanceof constraint) {\n        return;\n      }\n    } catch {\n      // ignore\n    }\n    if (!isUndefinedOrNull(arg) && (arg as any).constructor === constraint) {\n      return;\n    }\n    if (constraint.length === 1 && constraint.call(undefined, arg) === true) {\n      return;\n    }\n    throw new Error(\n      `argument does not match one of these constraints: arg instanceof constraint, arg.constructor === constraint, nor constraint(arg) === true`\n    );\n  }\n}\n\n/**\n * Converts null to undefined, passes all other values through.\n */\nexport function withNullAsUndefined<T>(x: T | null): T | undefined {\n  return x === null ? undefined : x;\n}\n\n/**\n * Converts undefined to null, passes all other values through.\n */\nexport function withUndefinedAsNull<T>(x: T | undefined): T | null {\n  return typeof x === \"undefined\" ? null : x;\n}\n\ntype AddFirstParameterToFunction<T, TargetFunctionsReturnType, FirstParameter> =\n  T extends (...args: any[]) => TargetFunctionsReturnType\n    ? // Function: add param to function\n      (firstArg: FirstParameter, ...args: Parameters<T>) => ReturnType<T>\n    : // Else: just leave as is\n      T;\n\n/**\n * Allows to add a first parameter to functions of a type.\n */\nexport type AddFirstParameterToFunctions<\n  Target,\n  TargetFunctionsReturnType,\n  FirstParameter,\n> = {\n  // For every property\n  [K in keyof Target]: AddFirstParameterToFunction<\n    Target[K],\n    TargetFunctionsReturnType,\n    FirstParameter\n  >;\n};\n\n/**\n * Given an object with all optional properties, requires at least one to be defined.\n * i.e. AtLeastOne<MyObject>;\n */\nexport type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &\n  U[keyof U];\n\n/**\n * A type that removed readonly-less from all properties of `T`\n */\nexport type Mutable<T> = {\n  -readonly [P in keyof T]: T[P];\n};\n\n// Source: https://github.com/sindresorhus/type-fest\n\n// MIT License\n\n// Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (https://sindresorhus.com)\n\n/**\nMatches a JSON object.\nThis type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. Don't use this as a direct return type as the user would have to double-cast it: `jsonObject as unknown as CustomResponse`. Instead, you could extend your CustomResponse type from it to ensure your type only uses JSON-compatible types: `interface CustomResponse extends JsonObject { \u2026 }`.\n*/\nexport type JsonObject = { [Key in string]: JsonValue } & {\n  [Key in string]?: JsonValue | undefined;\n};\n\n/*\nMatches a JSON array.\n*/\nexport type JsonArray = JsonValue[] | readonly JsonValue[];\n\n/*\nMatches any valid JSON primitive value.\n*/\nexport type JsonPrimitive = string | number | boolean | null;\n\n/**\nMatches any valid JSON value.\n@see `Jsonify` if you need to transform a type to one that is assignable to `JsonValue`.\n*/\nexport type JsonValue = JsonPrimitive | JsonObject | JsonArray;\nexport type Primitive =\n  | null\n  | undefined\n  | string\n  | number\n  | boolean\n  | symbol\n  | bigint;\n\nexport interface ErrorLike {\n  [key: string]: unknown;\n  name: string;\n  message: string;\n  stack: string;\n}\n\nexport function isErrorLike(value: unknown): value is ErrorLike {\n  return (\n    !!value &&\n    typeof value === \"object\" &&\n    \"name\" in value &&\n    \"message\" in value &&\n    \"stack\" in value\n  );\n}\n", "import { ConfigurationError, RuntimeError } from \"../errors\";\nimport { RequestUser } from \"../request\";\nimport { isBoolean, isString } from \"./types\";\n\nconst resultCache = new Map();\n\n/**\n * @param input - a string of comma-separated status codes and ranges, e.g. \"200, 201, 300-304\"\n * @returns an array of numbers, e.g. [200, 201, 300, 301, 302, 303, 304]\n */\nexport function statusCodesStringToNumberArray(input: unknown): number[] {\n  if (Array.isArray(input) && !input.some((v) => typeof v !== \"number\")) {\n    return input;\n  }\n  if (typeof input !== \"string\") {\n    throw new Error(\"Input must be a string or an array of numbers\");\n  }\n\n  if (!/^\\d+(?:-\\d+)?(?:,\\s*\\d+(?:-\\d+)?)*$/.test(input)) {\n    throw new Error(\"Malformed input string\");\n  }\n\n  const cached = resultCache.get(input);\n\n  if (cached) {\n    return cached;\n  }\n\n  const numbers = input.split(\",\");\n  const result: number[] = [];\n\n  for (const number of numbers) {\n    const range = number.split(\"-\");\n\n    if (range.length === 2) {\n      const start = parseInt(range[0], 10);\n      const end = parseInt(range[1], 10);\n\n      for (let i = start; i <= end; i++) {\n        result.push(i);\n      }\n    } else {\n      result.push(parseInt(number, 10));\n    }\n  }\n\n  resultCache.set(input, result);\n  return result;\n}\n\nexport function getValueFromRequestUser(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  user: RequestUser<any>,\n  path: string,\n  optionPropertyName: string\n) {\n  if (!path.startsWith(\".\")) {\n    throw new ConfigurationError(\n      `Invalid ${optionPropertyName} - must start with '.' - '${path}' does not`\n    );\n  }\n  const props = path.split(\".\").splice(1);\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  let value: any = user;\n  props.forEach((prop) => {\n    if (value === undefined) {\n      throw new RuntimeError(\n        `Error applying ${optionPropertyName} '${path}', reading '${prop}'`\n      );\n    }\n    value = value[prop];\n  });\n  return `${value}`; // return as string, that works with 'undefined'\n}\n\n/**\n * Parses an input value into a string array. The input value can be\n * a string, a comma separated string, or a string array.\n * @param val - The value to parse\n */\nexport function parseValueToStringArray(val: unknown): string[] {\n  if (Array.isArray(val)) {\n    const includesNonString = val.includes(\n      (v: unknown) => typeof v !== \"string\"\n    );\n    if (includesNonString) {\n      throw new ConfigurationError(\n        `Received an array that contains non-string values.`\n      );\n    }\n    return val as string[];\n  }\n\n  if (isString(val)) {\n    // Test for comma separated array\n    if (val.includes(\",\")) {\n      const items = val\n        .split(\",\")\n        .map((v) => v.trim())\n        .filter((v) => v !== \",\" && v !== \"\");\n      return items;\n    }\n\n    // This is just a single string instance, convert to array\n    return [val];\n  }\n\n  throw new ConfigurationError(\n    `Expected type of string, received type '${typeof val}'`\n  );\n}\n\nexport function parseValueToBoolean(val: unknown): boolean {\n  if (isBoolean(val)) {\n    return val;\n  } else if (isString(val)) {\n    if (val.toLowerCase() === \"true\") {\n      return true;\n    } else if (val.toLowerCase() === \"false\") {\n      return false;\n    }\n    throw new ConfigurationError(\n      `Attempted to parse string to boolean, but received ${val} which cannot be parsed.`\n    );\n  }\n  throw new ConfigurationError(\n    `Expected type of boolean, received type '${typeof val}'`\n  );\n}\n", "import { ConfigurationError } from \"../errors\";\nimport { CorsPolicyConfiguration, HttpMethod } from \"../index.worker\";\nimport { parseValueToStringArray } from \"./options-parsing\";\nimport { isBoolean, isNonEmptyString, isNumber, isObject } from \"./types\";\n\n/**\n * This is the parsed values of the Cors configuration. All\n * values in the parsed configuration are in the format that the headers\n * use them (i.e. everything is converted to a string)\n */\nexport interface ParsedCorsPolicyConfiguration {\n  name: string;\n  allowCredentials: string | undefined;\n  maxAge: string | undefined;\n  allowedOrigins: string[];\n  allowedMethods?: string;\n  allowedHeaders?: string;\n  exposeHeaders?: string;\n}\n\n/**\n * Takes in user defined cors policies (i.e. not necessarily valid) and\n * converts them to parsed and valid policies.\n * @param rawCustomPolicies - The user created custom policies\n * @returns Valid cors custom policies\n */\nexport function parseCorsPolicies(\n  rawCustomPolicies: unknown\n): ParsedCorsPolicyConfiguration[] {\n  if (rawCustomPolicies === undefined || rawCustomPolicies === null) {\n    return [];\n  }\n\n  if (!Array.isArray(rawCustomPolicies)) {\n    throw new ConfigurationError(\n      `Invalid corsPolicy configuration. Expected an array of objects, received '${typeof rawCustomPolicies}'`\n    );\n  }\n  const parsedPolicies = rawCustomPolicies.map(\n    (rawPolicy: CorsPolicyConfiguration) => {\n      if (!isObject(rawPolicy)) {\n        throw new ConfigurationError(\n          `Invalid custom cors policy is set. Expected an object, received '${typeof rawPolicy}'`\n        );\n      }\n\n      if (!isNonEmptyString(rawPolicy.name)) {\n        throw new ConfigurationError(\n          `Value of 'name' on custom cors policies must be a non-empty string.`\n        );\n      }\n\n      if (rawPolicy.maxAge !== undefined && !isNumber(rawPolicy.maxAge)) {\n        throw new ConfigurationError(\n          `Value of 'maxAge' on custom cors policies must be a non-empty string. Received type '${typeof rawPolicy.maxAge}'`\n        );\n      }\n\n      if (\n        rawPolicy.allowCredentials !== undefined &&\n        !isBoolean(rawPolicy.allowCredentials)\n      ) {\n        throw new ConfigurationError(\n          `Value of 'allowCredentials' on custom cors policies must be a boolean or not be set. If using an environment variable, check that it is set correctly.`\n        );\n      }\n\n      const allowedHeaders = parseOptionalProperty(rawPolicy, \"allowedHeaders\");\n      const allowedMethods = parseOptionalProperty(\n        rawPolicy,\n        \"allowedMethods\"\n      ) as HttpMethod[] | undefined;\n      const exposeHeaders = parseOptionalProperty(rawPolicy, \"exposeHeaders\");\n\n      let allowedOrigins: string[];\n      try {\n        allowedOrigins = parseValueToStringArray(rawPolicy.allowedOrigins);\n      } catch (err) {\n        throw new ConfigurationError(\n          `Value of 'allowedOrigins' on custom cors policies is invalid. ${err.message} If using an environment variable, check that it is set correctly.`\n        );\n      }\n\n      const parsed: ParsedCorsPolicyConfiguration = {\n        name: rawPolicy.name,\n        allowCredentials:\n          typeof rawPolicy.allowCredentials === \"boolean\"\n            ? String(rawPolicy.allowCredentials)\n            : undefined,\n        allowedOrigins,\n        allowedHeaders: allowedHeaders ? allowedHeaders.join(\", \") : undefined,\n        allowedMethods: allowedMethods ? allowedMethods.join(\", \") : undefined,\n        exposeHeaders: exposeHeaders ? exposeHeaders.join(\", \") : undefined,\n        maxAge:\n          typeof rawPolicy.maxAge === \"number\"\n            ? rawPolicy.maxAge.toString()\n            : undefined,\n      };\n\n      return parsed;\n    }\n  );\n\n  return parsedPolicies;\n}\n\nfunction parseOptionalProperty(\n  rawPolicy: CorsPolicyConfiguration,\n  prop: keyof CorsPolicyConfiguration\n): string[] | undefined {\n  let val: string[] | undefined;\n  if (rawPolicy[prop] !== undefined) {\n    try {\n      val = parseValueToStringArray(rawPolicy[prop]);\n    } catch (err) {\n      throw new ConfigurationError(\n        `Value of '${prop}' on custom cors policies is invalid. ${err.message} If using an environment variable, check that it is set correctly.`\n      );\n    }\n  }\n  return val;\n}\n\n// This function takes a string list of domains, and finds a match against the incoming origin,\n// return 'undefined' if no match found.\nexport const findMatchingOrigin = (\n  allowedOrigins: string[],\n  incomingOrigin: string | null\n): string | undefined => {\n  if (incomingOrigin === null) {\n    return;\n  }\n\n  // a * means 'anything goes'\n  const hasWildcard = allowedOrigins.find((ao) => ao === \"*\");\n  if (hasWildcard) {\n    return incomingOrigin;\n  }\n\n  const originLowered = allowedOrigins.map((s) => s.trim().toLowerCase());\n  const lowerOrigin = incomingOrigin.toLowerCase();\n\n  const matchingDomain = originLowered.find((s) => s === lowerOrigin);\n  return matchingDomain; // either a matching string or undefined\n};\n\nexport const generateCorsHeaders = (\n  corsPolicy: ParsedCorsPolicyConfiguration,\n  actualAllowedOrigin: string\n): Record<string, string> => {\n  const headers: Record<string, string> = {\n    \"access-control-allow-origin\": actualAllowedOrigin,\n  };\n\n  if (corsPolicy.allowedHeaders) {\n    headers[\"access-control-allow-headers\"] = corsPolicy.allowedHeaders;\n  }\n\n  if (corsPolicy.allowedMethods) {\n    headers[\"access-control-allow-methods\"] = corsPolicy.allowedMethods;\n  }\n\n  if (corsPolicy.exposeHeaders) {\n    headers[\"access-control-expose-headers\"] = corsPolicy.exposeHeaders;\n  }\n\n  const allowCredentials = corsPolicy.allowCredentials;\n  if (allowCredentials) {\n    headers[\"access-control-allow-credentials\"] = allowCredentials;\n  }\n\n  const maxAge = corsPolicy.maxAge?.toString() ?? undefined;\n  if (maxAge) {\n    headers[\"access-control-max-age\"] = maxAge;\n  }\n\n  return headers;\n};\n", "import { ConfigurationError } from \"../errors\";\nimport { Gateway } from \"../gateway\";\nimport { Pipeline } from \"../pipeline\";\nimport { HttpProblems } from \"../problem-responses/http-problems\";\nimport { metricsProcessor } from \"../processors/metrics-processor\";\nimport {\n  HttpMethod,\n  RouteConfiguration,\n  SystemRouteName,\n} from \"../router/interfaces\";\nimport { RouteHandler, Router } from \"../router/router\";\nimport { SystemRouteConfiguration } from \"../router/system-route-configuration\";\nimport {\n  ParsedCorsPolicyConfiguration,\n  findMatchingOrigin,\n  generateCorsHeaders,\n} from \"../utils/cors\";\n\n/**\n * @internal\n */\nexport const registerCorsRoute = (router: Router, gateway: Gateway) => {\n  // For CORS, we create a single wildcard OPTIONS route.\n\n  const customPolicies = gateway.routeData.corsPolicies;\n\n  // We then inspect the request headers and map to a route and return appropriately.\n  const optionsHandler: RouteHandler = async (\n    request,\n    context\n  ): Promise<Response> => {\n    const path = new URL(request.url.toString()).pathname;\n\n    const requestedMethod = request.headers.get(\n      \"access-control-request-method\"\n    ) as HttpMethod;\n    const requestedHeaders = request.headers.get(\n      \"access-control-request-headers\"\n    );\n    const requestedOrigin = request.headers.get(\"origin\");\n\n    if (requestedOrigin === null || requestedMethod === null) {\n      return HttpProblems.badRequest(request, context, {\n        detail: `Expect headers origin and access-control-request-method`,\n      });\n    }\n\n    const routeMatch = router.lookup(requestedMethod, path);\n\n    if (!routeMatch) {\n      return HttpProblems.notFound(request, context);\n    }\n\n    const routeConfig = routeMatch.routeConfiguration as RouteConfiguration;\n\n    const corsResult = validateAndBuildResponseHeaders(\n      requestedMethod,\n      requestedHeaders,\n      requestedOrigin,\n      routeConfig,\n      customPolicies\n    );\n\n    if (corsResult.isValid) {\n      const response = new Response(undefined, {\n        status: 200,\n        statusText: \"OK\",\n        headers: corsResult.headers,\n      });\n      return response;\n    }\n\n    if (corsResult.error) {\n      context.log.warn(corsResult.error);\n    }\n    return HttpProblems.notFound(request, context);\n  };\n\n  // The metrics processor runs on CORS handlers - no policy or CORS processor\n  const zPipe = new Pipeline({\n    processors: [metricsProcessor],\n    handler: optionsHandler,\n    gateway,\n  });\n  const corsRouteConfiguration = new SystemRouteConfiguration({\n    label: \"SYSTEM_CORS_ROUTE\",\n    methods: [\"OPTIONS\"],\n    path: \"/(.*)\",\n    systemRouteName: SystemRouteName.CorsPreflight,\n  });\n\n  router.addRoute(corsRouteConfiguration, zPipe.execute);\n};\n\nconst validateAndBuildResponseHeaders = (\n  requestedMethod: string,\n  requestedHeaders: string | null,\n  requestedOrigin: string,\n  route: RouteConfiguration,\n  customPolicies?: ParsedCorsPolicyConfiguration[]\n): { isValid: boolean; error?: string; headers: Record<string, string> } => {\n  const invalidResponse = { isValid: false, headers: {} };\n\n  if (route.corsPolicy === \"anything-goes\") {\n    const anythingGoes: Record<string, string> = {\n      \"access-control-allow-origin\": requestedOrigin,\n      \"access-control-allow-methods\": requestedMethod,\n      \"access-control-allow-headers\": requestedHeaders ?? \"*\",\n      \"access-control-expose-headers\": \"*\",\n      \"access-control-allow-credentials\": \"true\",\n      \"access-control-max-age\": \"600\",\n    };\n    return {\n      isValid: true,\n      headers: anythingGoes,\n    };\n  }\n\n  // could be implicit, but prioritize this check for future\n  // safety in case of code changes\n  if (route.corsPolicy === \"none\") {\n    return {\n      ...invalidResponse,\n      error: `No CORS policy set for the route '${route.pathPattern}'`,\n    };\n  }\n\n  const matchingPolicy = customPolicies?.find(\n    (pol) => pol.name === route.corsPolicy\n  );\n\n  if (!matchingPolicy) {\n    throw new ConfigurationError(\n      `Invalid Configuration - corsPolicy '${route.corsPolicy}' not found in *.oas.json 'corsPolicies' section.`\n    );\n  }\n\n  const matchingOrigin = findMatchingOrigin(\n    matchingPolicy.allowedOrigins,\n    requestedOrigin\n  );\n\n  if (!matchingOrigin) {\n    return {\n      ...invalidResponse,\n      error: `The CORS policy '${matchingPolicy.name}' does not allow the origin '${requestedOrigin}'`,\n    };\n  }\n\n  const newHeaders = generateCorsHeaders(matchingPolicy, matchingOrigin);\n\n  return {\n    isValid: true,\n    headers: newHeaders,\n  };\n};\n", "import { Gateway } from \"../gateway\";\nimport { Pipeline } from \"../pipeline\";\nimport { metricsProcessor } from \"../processors/metrics-processor\";\nimport { SystemRouteName } from \"../router/interfaces\";\nimport { RouteHandler, Router } from \"../router/router\";\nimport { SystemRouteConfiguration } from \"../router/system-route-configuration\";\n\n/**\n * @internal\n */\nexport const registerNoRoutes = (router: Router, gateway: Gateway) => {\n  const noRoutesHandler: RouteHandler = async () => {\n    return new Response(\n      \"You have no routes. Add a route in routes.oas.json to get started\",\n      { status: 200 }\n    );\n  };\n\n  const zPipe = new Pipeline({\n    processors: [metricsProcessor],\n    handler: noRoutesHandler,\n    gateway,\n  });\n  const noRoutesConfiguration = new SystemRouteConfiguration({\n    label: \"SYSTEM_NO_ROUTES\",\n    methods: [\n      \"CONNECT\",\n      \"DELETE\",\n      \"GET\",\n      \"HEAD\",\n      \"OPTIONS\",\n      \"PATCH\",\n      \"POST\",\n      \"PUT\",\n      \"TRACE\",\n    ],\n    path: \"/(.*)\",\n    systemRouteName: SystemRouteName.EmptyGatewayCatchall,\n  });\n\n  router.addRoute(noRoutesConfiguration, zPipe.execute);\n};\n", "import { ZuploContextExtensions } from \"../context\";\nimport { runtimeExtensions } from \"../extensions\";\nimport { Gateway } from \"../gateway\";\nimport { Pipeline } from \"../pipeline\";\nimport { HttpProblems } from \"../problem-responses/http-problems\";\nimport { metricsProcessor } from \"../processors/metrics-processor\";\nimport { SystemRouteName } from \"../router/interfaces\";\nimport { RouteHandler, Router } from \"../router/router\";\nimport { SystemRouteConfiguration } from \"../router/system-route-configuration\";\n\nexport const notFoundRouteConfiguration = new SystemRouteConfiguration({\n  label: \"SYSTEM_NOT_FOUND_ROUTE\",\n  methods: [\n    \"CONNECT\",\n    \"DELETE\",\n    \"GET\",\n    \"HEAD\",\n    \"OPTIONS\",\n    \"PATCH\",\n    \"POST\",\n    \"PUT\",\n    \"TRACE\",\n  ],\n  path: \"/(.*)\",\n  systemRouteName: SystemRouteName.UnmatchedPath,\n});\n\n/**\n * @internal\n */\nexport const registerNotMatchedHandler = (router: Router, gateway: Gateway) => {\n  // If we have a custom notFoundHandler - use it and load additional information\n  // from ZuploContextExtensions\n  const notFoundHandler: RouteHandler = async (request, context) => {\n    const customNfh = runtimeExtensions.value?.notFoundHandler;\n    if (customNfh) {\n      const ext = ZuploContextExtensions.getContextExtensions(context);\n      return customNfh(request, context, {\n        routesMatchedByPathOnly: ext.pathOnlyMatches ?? [],\n      });\n    }\n    return HttpProblems.notFound(request, context);\n  };\n\n  // The metrics processor should run on 404s\n  const zPipe = new Pipeline({\n    processors: [metricsProcessor],\n    handler: notFoundHandler,\n    gateway,\n  });\n\n  router.addRoute(notFoundRouteConfiguration, zPipe.execute);\n};\n", "import { ZuploContext } from \"../context\";\nimport { ConfigurationError, SystemError } from \"../errors\";\nimport { Gateway } from \"../gateway\";\nimport { RequestProcessor } from \"../interfaces\";\nimport { ZuploRequest } from \"../request\";\nimport { RouteConfiguration } from \"../router/interfaces\";\nimport {\n  ParsedCorsPolicyConfiguration,\n  findMatchingOrigin,\n  generateCorsHeaders,\n} from \"../utils/cors\";\n\nconst CORS_HEADERS = [\n  \"access-control-allow-origin\",\n  \"access-control-allow-headers\",\n  \"access-control-expose-headers\",\n  \"access-control-allow-credentials\",\n  \"access-control-max-age\",\n];\n\nconst stripCorsHeaders = (headers: Headers): void => {\n  CORS_HEADERS.forEach((h) => headers.delete(h));\n};\n\nexport const corsProcessor: RequestProcessor = async (\n  request: ZuploRequest,\n  context: ZuploContext,\n  gateway: Gateway,\n  next: (request: ZuploRequest) => Promise<Response>\n): Promise<Response> => {\n  const route = context.route;\n\n  if (!route.corsPolicy || route.corsPolicy === \"none\") {\n    // none means we strip the headers - there is no CORS\n    // supported\n    const response = await next(request);\n    const headers = new Headers(response.headers);\n    // clear existing CORS headers\n    stripCorsHeaders(headers);\n    return new Response(response.body, {\n      status: response.status,\n      statusText: response.statusText,\n      headers,\n      webSocket: response.webSocket,\n    });\n  }\n  const response = await next(request);\n\n  if (response instanceof Response === false) {\n    throw new SystemError(\n      `The CorsProcessor is in the wrong place in the pipeline. It should only receive HttpResponse type but got '${typeof response}'`\n    );\n  }\n\n  const corsPolicy = getCorsPolicy(route, gateway.routeData.corsPolicies);\n\n  const corsHeaders = getCorsHeaders(request, corsPolicy);\n\n  const headers = new Headers(response.headers);\n  stripCorsHeaders(headers);\n\n  Object.entries(corsHeaders).forEach(([key, value]) => {\n    headers.set(key, value);\n  });\n\n  const newResponse = new Response(response.body, {\n    status: response.status,\n    statusText: response.statusText,\n    headers,\n    webSocket: response.webSocket,\n  });\n\n  return newResponse;\n};\n\nconst getCorsPolicy = (\n  route: RouteConfiguration,\n  policies: ParsedCorsPolicyConfiguration[]\n) => {\n  if (route.corsPolicy === \"anything-goes\") {\n    const anythingGoes: ParsedCorsPolicyConfiguration = {\n      name: \"anything-goes\",\n      allowedHeaders: \"*\",\n      allowedOrigins: [\"*\"],\n      allowedMethods: route.methods.join(\", \"),\n      exposeHeaders: \"*\",\n      allowCredentials: \"true\",\n      maxAge: \"600\",\n    };\n\n    return anythingGoes;\n  }\n\n  const corsPolicy = policies?.find((p) => p.name === route.corsPolicy);\n\n  if (corsPolicy === undefined) {\n    throw new ConfigurationError(\n      `Invalid Configuration - no corsPolicy '${route.corsPolicy}' found in *.oas.json`\n    );\n  }\n\n  return corsPolicy;\n};\n\nconst getCorsHeaders = (\n  request: ZuploRequest,\n  policy: ParsedCorsPolicyConfiguration\n): Record<string, string> => {\n  // TODO - filter the domain down\n  const matchingOrigin = findMatchingOrigin(\n    policy.allowedOrigins,\n    request.headers.get(\"origin\")\n  );\n\n  if (!matchingOrigin) {\n    return {}; // no CORS headers\n  }\n\n  const newHeaders = generateCorsHeaders(policy, matchingOrigin);\n\n  return newHeaders;\n};\n", "import { Gateway } from \"../gateway\";\nimport { Pipeline } from \"../pipeline\";\nimport { corsProcessor } from \"../processors/cors-processor\";\nimport { SystemRouteName } from \"../router/interfaces\";\nimport { RouteHandler, Router } from \"../router/router\";\nimport { SystemRouteConfiguration } from \"../router/system-route-configuration\";\n\n/**\n * @internal\n */\nexport const registerPingRoute = (router: Router, gateway: Gateway) => {\n  const pingRouteHandler: RouteHandler = async () => {\n    return new Response(null, { status: 200 });\n  };\n\n  // No metrics on ping route\n  const zPipe = new Pipeline({\n    processors: [corsProcessor],\n    handler: pingRouteHandler,\n    gateway,\n  });\n  const pingRouteConfiguration = new SystemRouteConfiguration({\n    corsPolicy: \"anything-goes\",\n    label: \"SYSTEM_PING_ROUTE\",\n    methods: [\"GET\"],\n    path: \"/__zuplo/ping\",\n    systemRouteName: SystemRouteName.Ping,\n  });\n  router.addRoute(pingRouteConfiguration, zPipe.execute);\n};\n", "/**\n * Zuplo semantic attributes for open telemetry\n * @internal\n */\nexport const SemanticAttributes = {\n  RoutePathPattern: \"zuplo.route.path_pattern\",\n  RouteOperationId: \"zuplo.route.operation_id\",\n  RouteTrace: \"zuplo.route.trace\",\n  RouteSystem: \"zuplo.route.system\",\n  SystemTrace: \"zuplo.system\",\n  PolicyName: \"zuplo.policy.name\",\n  PolicyType: \"zuplo.policy.type\",\n  ZuploBuildId: \"zuplo.build.id\",\n  ZuploBuildVersion: \"zuplo.build.version\",\n  ZuploBuildCompatibilityDate: \"zuplo.build.compatibility_date\",\n  ZuploEnvironmentType: \"zuplo.environment_type\",\n};\n", "/* eslint-disable @typescript-eslint/no-explicit-any */\n\nimport { ZuploContext } from \"./context\";\nimport { RuntimeError } from \"./errors\";\nimport { ZuploRequest } from \"./request\";\nimport { isString } from \"./utils/types\";\n\n/**\n * @public\n * The base class for inbound and outbound policies\n */\nabstract class PolicyBase<TOptions = any> {\n  // TODO: Change this to use NoInfer<TOptions> when we move to use typescript 5.4\n  // to improve type checking when using internal policies\n  options: TOptions;\n  policyName: string;\n  policyType: string;\n\n  /**\n   * @internal\n   * @param options - The configuration options for the policy\n   * @param policyName - The name set on the policy in the configuration\n   */\n  constructor(options: TOptions, policyName: string) {\n    if (!isString(policyName)) {\n      throw new RuntimeError(\n        `The name of a policy must be a string. Received '${policyName}' of type '${typeof policyName}'`\n      );\n    }\n    this.options = options;\n    this.policyName = policyName;\n    this.policyType = Object.getPrototypeOf(this).constructor.name;\n  }\n}\n\n/**\n * @internal\n * The type of the PolicyBase constructor\n */\nexport interface PolicyConstructor<TPolicy> {\n  new (options: unknown, policyName: string): TPolicy;\n}\n\n/**\n * @beta\n * A policy that can modify the incoming HTTP request before it is sent to\n * the handler. If a response is returned, the request is short-circuited and\n * the response is returned to the client. If a Request is returned, policies\n * or a handler that follow are executed.\n */\nexport abstract class InboundPolicy<\n  TOptions = any,\n> extends PolicyBase<TOptions> {\n  /**\n   * The handler that is called each time this policy is invoked\n   *\n   * @param request - The incoming Request\n   * @param context - The current context of the Request\n   * @returns A Response or Request object\n   */\n  abstract handler(\n    request: ZuploRequest,\n    context: ZuploContext\n  ): Promise<ZuploRequest | Response>;\n}\n\n/**\n * @public\n * A policy that can modify the incoming HTTP request before it is sent to\n * the handler. If a response is returned, the request is short-circuited and\n * the response is returned to the client. If a Request is returned, policies\n * or a handler that follow are executed.\n *\n * @param request - The incoming Request\n * @param context - The current context of the Request\n * @param options - The configuration options for the policy\n * @param policyName - The name set on the policy in the configuration\n * @returns A Response or Request object\n */\nexport interface InboundPolicyHandler<TOptions = any> {\n  (\n    request: ZuploRequest,\n    context: ZuploContext,\n    options: TOptions,\n    policyName: string\n  ): Promise<ZuploRequest | Response>;\n}\n\n/**\n * @beta\n * A policy that can modify the outgoing HTTP response before it is returned\n * to the client.\n */\nexport abstract class OutboundPolicy<\n  TOptions = any,\n> extends PolicyBase<TOptions> {\n  /**\n   * The handler that is called each time this policy is invoked\n   *\n   * @param response - The outgoing Response\n   * @param request - The incoming Request\n   * @param context - The current context of the Request\n   */\n  abstract handler(\n    response: Response,\n    request: ZuploRequest,\n    context: ZuploContext\n  ): Promise<ZuploRequest | Response>;\n}\n\n/**\n * @public\n * A policy that can modify the outgoing HTTP response before it is returned\n * to the client.\n *\n * @param response - The outgoing Response\n * @param request - The incoming Request\n * @param context - The current context of the Request\n * @param options - The configuration options for the policy\n * @param policyName - The name set on the policy in the configuration\n * @returns A Response object\n */\nexport interface OutboundPolicyHandler<TOptions = any> {\n  (\n    response: Response,\n    request: ZuploRequest,\n    context: ZuploContext,\n    options: TOptions,\n    policyName: string\n  ): Promise<Response>;\n}\n", "import { SpanStatusCode, trace } from \"@opentelemetry/api\";\nimport { ZuploContext, ZuploContextExtensions } from \"../context\";\nimport { SemanticAttributes } from \"../diagnostics/attributes\";\nimport { ConfigurationError, RuntimeError } from \"../errors\";\nimport type { Gateway } from \"../gateway\";\nimport { RequestProcessor } from \"../interfaces\";\nimport {\n  InboundPolicy,\n  InboundPolicyHandler,\n  OutboundPolicy,\n  OutboundPolicyHandler,\n  PolicyConstructor,\n} from \"../policies\";\nimport { ZuploRequest } from \"../request\";\nimport type {\n  PolicyConfiguration,\n  RouteConfiguration,\n} from \"../router/interfaces\";\nimport { Environment } from \"../utils/environment\";\n\n/**\n * Converts a policy written as only a function to a full policy object\n */\nclass InboundFunctionOnlyPolicy extends InboundPolicy<unknown> {\n  #innerHandler: InboundPolicyHandler<unknown>;\n  constructor(\n    innerHandler: InboundPolicyHandler<unknown>,\n    options: unknown,\n    policyName: string\n  ) {\n    super(options, policyName);\n    this.policyType = innerHandler.name;\n    this.#innerHandler = innerHandler;\n  }\n\n  handler(\n    request: ZuploRequest,\n    context: ZuploContext\n  ): Promise<Response | ZuploRequest> {\n    return this.#innerHandler(request, context, this.options, this.policyName);\n  }\n}\n\n/**\n * Converts a policy written as only a function to a full policy object\n */\nclass OutboundFunctionOnlyPolicy extends OutboundPolicy<unknown> {\n  #innerHandler: OutboundPolicyHandler<unknown>;\n  constructor(\n    innerHandler: OutboundPolicyHandler<unknown>,\n    options: unknown,\n    policyName: string\n  ) {\n    super(options, policyName);\n    this.policyType = innerHandler.name;\n    this.#innerHandler = innerHandler;\n  }\n\n  handler(\n    response: Response,\n    request: ZuploRequest,\n    context: ZuploContext\n  ): Promise<Response | ZuploRequest> {\n    return this.#innerHandler(\n      response,\n      request,\n      context,\n      this.options,\n      this.policyName\n    );\n  }\n}\n\nconst inboundPolicyInstances = new Map<string, InboundPolicy>();\n\nexport function getInboundPolicyInstances(\n  route: RouteConfiguration,\n  policies?: PolicyConfiguration[]\n): InboundPolicy[];\nexport function getInboundPolicyInstances(\n  policyNames: string[],\n  policies?: PolicyConfiguration[]\n): InboundPolicy[];\nexport function getInboundPolicyInstances(\n  routeOrPolicyNames: RouteConfiguration | string[],\n  policies?: PolicyConfiguration[]\n): InboundPolicy[] {\n  let policyNames: string[];\n  let routePath: string | undefined;\n  if (Array.isArray(routeOrPolicyNames)) {\n    policyNames = routeOrPolicyNames;\n  } else {\n    policyNames = routeOrPolicyNames.policies?.inbound ?? [];\n    routePath = routeOrPolicyNames.path;\n  }\n\n  const nonCachedPolicies = policyNames.filter(\n    (p) => !inboundPolicyInstances.has(p)\n  );\n\n  nonCachedPolicies.forEach((name: string) => {\n    const policy = policies?.find((p) => p.name === name);\n    if (!policy) {\n      throw new ConfigurationError(\n        `Invalid state - no Policy with the name '${name}' ${\n          routePath && `on route '${routePath}'`\n        } was found in the policies configuration (check case).`\n      );\n    }\n\n    if (typeof policy.handler?.module !== \"object\") {\n      throw new ConfigurationError(\n        `Invalid state - invalid policy '${name}' on route '${routePath}' (typeof policy '${typeof policy\n          .handler?.module}')`\n      );\n    }\n\n    const policyOrHandler: unknown =\n      policy.handler?.module[policy.handler.export];\n    if (typeof policyOrHandler !== \"function\") {\n      throw new ConfigurationError(\n        `Invalid state - invalid policy '${name}' on route '${routePath}' (typeof module '${typeof policyOrHandler}')`\n      );\n    }\n\n    let innerPolicy: InboundPolicy<unknown>;\n    if (typeof policyOrHandler !== \"function\") {\n      throw new ConfigurationError(\n        `Invalid state - invalid policy '${name}' on route '${routePath}' (typeof module '${typeof policyOrHandler}')`\n      );\n    }\n\n    if (policyOrHandler.prototype instanceof InboundPolicy) {\n      innerPolicy = new (policyOrHandler as PolicyConstructor<InboundPolicy>)(\n        policy.handler.options,\n        policy.name\n      );\n    } else if (typeof policyOrHandler === \"function\") {\n      innerPolicy = new InboundFunctionOnlyPolicy(\n        policyOrHandler as InboundPolicyHandler,\n        policy.handler.options,\n        policy.name\n      );\n    } else {\n      throw new ConfigurationError(\n        `Invalid state - invalid policy '${name}' on route '${routePath}' (typeof policy '${typeof policyOrHandler}')`\n      );\n    }\n\n    if (typeof innerPolicy.handler !== \"function\") {\n      throw new ConfigurationError(\n        `Invalid state - invalid handler on policy '${name}' on route '${routePath}' (typeof handler '${typeof innerPolicy.handler}')`\n      );\n    }\n\n    inboundPolicyInstances.set(policy.name, innerPolicy);\n  });\n\n  return policyNames.map((p) => {\n    const instance = inboundPolicyInstances.get(p);\n    if (instance === undefined) {\n      throw new RuntimeError(\"Internal error. Policy not found in cache.\");\n    }\n    return instance;\n  });\n}\n\nconst outputPolicyInstances = new Map<string, OutboundPolicy>();\n\nfunction getOutboundPolicyInstances(\n  route: RouteConfiguration,\n  policies?: PolicyConfiguration[]\n): OutboundPolicy[] {\n  const policyNames = route.policies?.outbound ?? [];\n\n  const nonCachedPolicies = policyNames.filter(\n    (p) => !outputPolicyInstances.has(p)\n  );\n\n  nonCachedPolicies.forEach((name: string) => {\n    const policy = policies?.find((p) => p.name === name);\n    if (!policy) {\n      throw new ConfigurationError(\n        `Invalid state - no Policy with the name '${name}' on route '${route.path}' was found in the policies configuration (check case).`\n      );\n    }\n\n    if (typeof policy.handler?.module !== \"object\") {\n      throw new ConfigurationError(\n        `Invalid state - invalid policy '${name}' on route '${\n          route.path\n        }' (typeof policy '${typeof policy.handler?.module}')`\n      );\n    }\n\n    const policyOrHandler: unknown =\n      policy.handler?.module[policy.handler.export];\n\n    let innerPolicy: OutboundPolicy;\n    if (typeof policyOrHandler !== \"function\") {\n      throw new ConfigurationError(\n        `Invalid state - invalid policy '${name}' on route '${\n          route.path\n        }' (typeof module '${typeof policyOrHandler}')`\n      );\n    }\n\n    if (policyOrHandler.prototype instanceof OutboundPolicy) {\n      innerPolicy = new (policyOrHandler as PolicyConstructor<OutboundPolicy>)(\n        policy.handler.options ?? {},\n        policy.name\n      );\n    } else if (typeof policyOrHandler === \"function\") {\n      innerPolicy = new OutboundFunctionOnlyPolicy(\n        policyOrHandler as OutboundPolicyHandler,\n        policy.handler.options ?? {},\n        policy.name\n      );\n    } else {\n      throw new ConfigurationError(\n        `Invalid state - invalid policy '${name}' on route '${\n          route.path\n        }' (typeof policy '${typeof policyOrHandler}')`\n      );\n    }\n\n    if (typeof innerPolicy.handler !== \"function\") {\n      throw new ConfigurationError(\n        `Invalid state - invalid handler on policy '${name}' on route '${route.path}'`\n      );\n    }\n\n    outputPolicyInstances.set(policy.name, innerPolicy);\n  });\n\n  return policyNames.map((p) => {\n    const instance = outputPolicyInstances.get(p);\n    if (instance === undefined) {\n      throw new RuntimeError(\"Internal error. Policy not found in cache.\");\n    }\n    return instance;\n  });\n}\n\nexport const toStackedInboundHandler = (policies: InboundPolicy[]) => {\n  return async (request: ZuploRequest, context: ZuploContext) => {\n    const ext = ZuploContextExtensions.getContextExtensions(context);\n    const tracer = trace.getTracer(\"pipeline\");\n    return await tracer.startActiveSpan(\"policies:inbound\", async (span) => {\n      try {\n        const localPolicies = [...policies];\n        let currentRequest: ZuploRequest = request;\n        while (localPolicies.length > 0) {\n          const nextPolicy = localPolicies.shift();\n          if (!nextPolicy) {\n            return currentRequest;\n          }\n\n          const policyResult = await tracer.startActiveSpan(\n            `policy:${nextPolicy.policyName}`,\n            async (localSpan) => {\n              // We are explicitly setting this to unknown because the\n              // handler is user code and we cannot be sure they actually\n              // followed the type.\n              const policyResult: unknown = await nextPolicy.handler(\n                currentRequest,\n                context\n              );\n\n              if (\n                policyResult instanceof Request ||\n                policyResult instanceof ZuploRequest ||\n                policyResult instanceof Response\n              ) {\n                localSpan.end();\n                return policyResult;\n              } else {\n                const error = new ConfigurationError(\n                  `Invalid state - invalid handler on policy '${nextPolicy.policyName}' on route '${context.route.path}. The result of an inbound policy must be a Response or Request.`\n                );\n                localSpan.end();\n                localSpan.setStatus({ code: SpanStatusCode.ERROR });\n                localSpan.recordException(error);\n                throw error;\n              }\n            }\n          );\n\n          if (policyResult instanceof ZuploRequest) {\n            currentRequest = policyResult;\n          } else if (policyResult instanceof Request) {\n            currentRequest = new ZuploRequest(policyResult);\n          } else if (policyResult instanceof Response) {\n            return policyResult;\n          }\n\n          // Save the current request for use with analytics\n          ext.latestRequest = currentRequest;\n        }\n\n        return currentRequest;\n      } finally {\n        span.end();\n      }\n    });\n  };\n};\n\nconst toStackedOutboundHandler = (policies: OutboundPolicy[]) => {\n  return async (\n    response: Response,\n    request: ZuploRequest,\n    context: ZuploContext\n  ) => {\n    const tracer = trace.getTracer(\"pipeline\");\n    return await tracer.startActiveSpan(\"policies:outbound\", async (span) => {\n      try {\n        const localPolicies = [...policies];\n        let currentResponse: Response = response;\n        while (localPolicies.length > 0) {\n          const nextPolicy = localPolicies.shift();\n          if (!nextPolicy) {\n            return currentResponse;\n          }\n\n          const policyResult = await tracer.startActiveSpan(\n            `policy:${nextPolicy.policyName}`,\n            async (localSpan) => {\n              try {\n                localSpan.setAttribute(\n                  SemanticAttributes.PolicyName,\n                  nextPolicy.policyName\n                );\n                localSpan.setAttribute(\n                  SemanticAttributes.PolicyType,\n                  nextPolicy.policyType\n                );\n                // We are explicitly setting this to unknown because the\n                // handler is user code and we cannot be sure they actually\n                // followed the type.\n                const policyResult: unknown = await nextPolicy.handler(\n                  currentResponse,\n                  request,\n                  context\n                );\n                if (policyResult instanceof Response) {\n                  return policyResult;\n                } else {\n                  const error = new ConfigurationError(\n                    `Invalid state - invalid handler on policy '${nextPolicy.policyName}' on route '${context.route.path}. The result of an outbound policy must be a Response.`\n                  );\n                  localSpan.setStatus({ code: SpanStatusCode.ERROR });\n                  localSpan.recordException(error);\n\n                  throw error;\n                }\n              } finally {\n                localSpan.end();\n              }\n            }\n          );\n          currentResponse = policyResult;\n        }\n        return currentResponse;\n      } finally {\n        span.end();\n      }\n    });\n  };\n};\n\n/**\n * @internal\n */\nexport const policyProcessor: RequestProcessor = async (\n  request,\n  context,\n  gateway,\n  next\n): Promise<Response> => {\n  const inboundPolicies = getInboundPolicyInstances(\n    context.route,\n    gateway.routeData.policies\n  );\n\n  const outboundPolicies = getOutboundPolicyInstances(\n    context.route,\n    gateway.routeData.policies\n  );\n\n  return executePolicyProcessor({\n    request,\n    context,\n    inboundPolicies,\n    outboundPolicies,\n    gateway,\n    next,\n  });\n};\n\n/**\n * Creates an internal policy processor with policies that are not\n *  created by the user (i.e. not in policy.json)\n *\n * @returns\n */\nexport function createInternalPolicyProcessor({\n  inboundPolicies = [],\n  outboundPolicies = [],\n}: {\n  // Any because this is internal and we don't need to worry about the type\n  // being wrong\n  inboundPolicies?: InboundPolicy[];\n\n  outboundPolicies?: OutboundPolicy[];\n}) {\n  const policyProcessor: RequestProcessor = async (\n    request,\n    context,\n    gateway,\n    next\n  ): Promise<Response> =>\n    executePolicyProcessor({\n      request,\n      context,\n      inboundPolicies,\n      outboundPolicies,\n      gateway,\n      next,\n    });\n\n  return policyProcessor;\n}\n\n/**\n * Used to run\n * @returns\n */\nasync function executePolicyProcessor({\n  request,\n  context,\n  inboundPolicies,\n  outboundPolicies,\n  gateway,\n  next,\n}: {\n  request: ZuploRequest;\n  context: ZuploContext;\n  inboundPolicies: InboundPolicy<unknown>[];\n  outboundPolicies: OutboundPolicy<unknown>[];\n  gateway: Gateway;\n  next: (request: ZuploRequest) => Promise<Response>;\n}) {\n  const inboundStackedHandler = toStackedInboundHandler(inboundPolicies);\n\n  try {\n    const result = await inboundStackedHandler(request, context);\n\n    if (result instanceof Response) {\n      return result;\n    }\n    // if not a Response, it must be a request\n    const response = await next(result);\n\n    const outboundStackedHandler = toStackedOutboundHandler(outboundPolicies);\n\n    let outboundResponse: Response | Promise<Response>;\n    if (\n      Environment.instance.build.COMPATIBILITY_FLAGS\n        .runOutboundPoliciesOnHandlerOnAllStatuses\n    ) {\n      outboundResponse = outboundStackedHandler(response, request, context);\n    } else {\n      // Legacy behavior only runs outbound policies on responses with an\n      //  OK status. Compatibility dates after 2023-03-14 changed this behavior\n      outboundResponse = response.ok\n        ? outboundStackedHandler(response, request, context)\n        : response;\n    }\n\n    return outboundResponse;\n  } catch (err) {\n    // An error inside polices should be logged to the user logger\n    context.log.error(err);\n    return gateway.errorHandler(request, context, err);\n  }\n}\n", "/*!\n * cookie\n * Copyright(c) 2012-2014 Roman Shtylman\n * Copyright(c) 2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n\"use strict\";\n\n/**\n * Module exports.\n * @public\n */\n\n/**\n * Module variables.\n * @private\n */\n\nconst __toString = Object.prototype.toString;\n\n/**\n * RegExp to match field-content in RFC 7230 sec 3.2\n *\n * field-content = field-vchar [ 1*( SP / HTAB ) field-vchar ]\n * field-vchar   = VCHAR / obs-text\n * obs-text      = %x80-FF\n */\n\nconst fieldContentRegExp = /^[\\u0009\\u0020-\\u007e\\u0080-\\u00ff]+$/;\n\n/**\n * Parse a cookie header.\n *\n * Parse the given cookie header string into an object\n * The object has the various cookies as keys(names) => values\n *\n * @param {string} str\n * @param {object} [options]\n * @return {object}\n * @public\n */\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function parse(str: string, options?: any) {\n  if (typeof str !== \"string\") {\n    throw new TypeError(\"argument str must be a string\");\n  }\n\n  const obj = {};\n  const opt = options || {};\n  const dec = opt.decode || decode;\n\n  let index = 0;\n  while (index < str.length) {\n    const eqIdx = str.indexOf(\"=\", index);\n\n    // no more cookie pairs\n    if (eqIdx === -1) {\n      break;\n    }\n\n    let endIdx = str.indexOf(\";\", index);\n\n    if (endIdx === -1) {\n      endIdx = str.length;\n    } else if (endIdx < eqIdx) {\n      // backtrack on prior semicolon\n      index = str.lastIndexOf(\";\", eqIdx - 1) + 1;\n      continue;\n    }\n\n    const key = str.slice(index, eqIdx).trim();\n\n    // only assign once\n    // @ts-ignore\n    if (undefined === obj[key]) {\n      let val = str.slice(eqIdx + 1, endIdx).trim();\n\n      // quoted values\n      if (val.charCodeAt(0) === 0x22) {\n        val = val.slice(1, -1);\n      }\n      // @ts-ignore\n      obj[key] = tryDecode(val, dec);\n    }\n\n    index = endIdx + 1;\n  }\n\n  return obj;\n}\n\n/**\n * Serialize data into a cookie header.\n *\n * Serialize the a name value pair into a cookie string suitable for\n * http headers. An optional options object specified cookie parameters.\n *\n * serialize('foo', 'bar', { httpOnly: true })\n *   => \"foo=bar; httpOnly\"\n *\n * @param {string} name\n * @param {string} val\n * @param {object} [options]\n * @return {string}\n * @public\n */\n// @ts-ignore\nexport function serialize(name, val, options) {\n  const opt = options || {};\n  const enc = opt.encode || encode;\n\n  if (typeof enc !== \"function\") {\n    throw new TypeError(\"option encode is invalid\");\n  }\n\n  if (!fieldContentRegExp.test(name)) {\n    throw new TypeError(\"argument name is invalid\");\n  }\n\n  const value = enc(val);\n\n  if (value && !fieldContentRegExp.test(value)) {\n    throw new TypeError(\"argument val is invalid\");\n  }\n\n  let str = name + \"=\" + value;\n\n  if (null != opt.maxAge) {\n    const maxAge = opt.maxAge - 0;\n\n    if (isNaN(maxAge) || !isFinite(maxAge)) {\n      throw new TypeError(\"option maxAge is invalid\");\n    }\n\n    str += \"; Max-Age=\" + Math.floor(maxAge);\n  }\n\n  if (opt.domain) {\n    if (!fieldContentRegExp.test(opt.domain)) {\n      throw new TypeError(\"option domain is invalid\");\n    }\n\n    str += \"; Domain=\" + opt.domain;\n  }\n\n  if (opt.path) {\n    if (!fieldContentRegExp.test(opt.path)) {\n      throw new TypeError(\"option path is invalid\");\n    }\n\n    str += \"; Path=\" + opt.path;\n  }\n\n  if (opt.expires) {\n    const expires = opt.expires;\n\n    if (!isDate(expires) || isNaN(expires.valueOf())) {\n      throw new TypeError(\"option expires is invalid\");\n    }\n\n    str += \"; Expires=\" + expires.toUTCString();\n  }\n\n  if (opt.httpOnly) {\n    str += \"; HttpOnly\";\n  }\n\n  if (opt.secure) {\n    str += \"; Secure\";\n  }\n\n  if (opt.priority) {\n    const priority =\n      typeof opt.priority === \"string\"\n        ? opt.priority.toLowerCase()\n        : opt.priority;\n\n    switch (priority) {\n      case \"low\":\n        str += \"; Priority=Low\";\n        break;\n      case \"medium\":\n        str += \"; Priority=Medium\";\n        break;\n      case \"high\":\n        str += \"; Priority=High\";\n        break;\n      default:\n        throw new TypeError(\"option priority is invalid\");\n    }\n  }\n\n  if (opt.sameSite) {\n    const sameSite =\n      typeof opt.sameSite === \"string\"\n        ? opt.sameSite.toLowerCase()\n        : opt.sameSite;\n\n    switch (sameSite) {\n      case true:\n        str += \"; SameSite=Strict\";\n        break;\n      case \"lax\":\n        str += \"; SameSite=Lax\";\n        break;\n      case \"strict\":\n        str += \"; SameSite=Strict\";\n        break;\n      case \"none\":\n        str += \"; SameSite=None\";\n        break;\n      default:\n        throw new TypeError(\"option sameSite is invalid\");\n    }\n  }\n\n  return str;\n}\n\n/**\n * URL-decode string value. Optimized to skip native call when no %.\n *\n * @param {string} str\n * @returns {string}\n */\n\nfunction decode(str: string) {\n  return str.indexOf(\"%\") !== -1 ? decodeURIComponent(str) : str;\n}\n\n/**\n * URL-encode value.\n *\n * @param {string} str\n * @returns {string}\n */\n\nfunction encode(val: string | number | boolean) {\n  return encodeURIComponent(val);\n}\n\n/**\n * Determine if value is a Date.\n *\n * @param {*} val\n * @private\n */\n//@ts-ignore\nfunction isDate(val) {\n  return __toString.call(val) === \"[object Date]\" || val instanceof Date;\n}\n\n/**\n * Try decoding a string using a decoding function.\n *\n * @param {string} str\n * @param {function} decode\n * @private\n */\n// @ts-ignore\nfunction tryDecode(str, decode) {\n  try {\n    return decode(str);\n  } catch (e) {\n    return str;\n  }\n}\n", "import { parse } from \"./cookie\";\n\nexport function devPortalBaseURL(\n  defaultBaseURL: string,\n  headers: Headers\n): string {\n  try {\n    const validDevPortalVersion = /v\\d+(-\\d+)?/g;\n    const cookie: { \"zp-dev-portal\"?: string } = parse(\n      headers.get(\"Cookie\") || \"\"\n    );\n    const cookieValue = cookie[\"zp-dev-portal\"];\n    if (\n      cookieValue !== null &&\n      cookieValue &&\n      validDevPortalVersion.test(cookieValue)\n    ) {\n      return `https://dev-portal-${cookieValue}.zuplo.com`;\n    }\n    return defaultBaseURL;\n  } catch (e) {\n    // ignore\n  }\n\n  return defaultBaseURL;\n}\n", "import { Gateway } from \"../gateway\";\nimport { HttpProblems, SystemRouteName, ZuploContext } from \"../index.worker\";\nimport internals from \"../internals\";\nimport { Pipeline } from \"../pipeline\";\nimport { metricsProcessor } from \"../processors/metrics-processor\";\nimport { policyProcessor } from \"../processors/policy-processor\";\nimport { ZuploRequest } from \"../request\";\nimport { RouteHandler, Router } from \"../router/router\";\nimport { SystemRouteConfiguration } from \"../router/system-route-configuration\";\nimport { devPortalBaseURL } from \"../utils/dev-portal\";\nimport { Environment } from \"../utils/environment\";\n\nconst DEV_PORTAL_LEGACY_PATHNAME = \"/__zuplo/dev-portal\";\nconst DEV_PORTAL_ID_HEADER = \"dev-portal-id\";\nconst DEV_PORTAL_ZUPLO_HOST_HEADER = \"dev-portal-host\";\nconst ZUPLO_ACCOUNT_HEADER = \"zp-account\";\nconst ZUPLO_PROJECT_HEADER = \"zp-project\";\nconst DEV_PORTAL_ZUPLO_BUILD_ID_HEADER = \"dev-portal-build\";\n\nconst localDevelopmentDevPortalBanner = `\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Developer Portal Preview</title>\n</head>\n<body>\n    <p>Previewing your Developer Portal is not supported (yet) in local development.</p>\n    <p>For now, create a project on <a href=\"https://portal.zuplo.com\">portal.zuplo.com</a>.</p>\n    <p>For more information, see <a href=\"https://zuplo.com/docs/articles/developer-portal\">https://zuplo.com/docs/articles/developer-portal</a>.</p>\n</body>\n</html>\n`;\n\n/**\n * @internal\n * We proxy all requests to the deployed vercel app, with the `deploymentName`\n * determining which assets the vercel app fetches.\n */\nexport const registerDevPortalV3Route = (router: Router, gateway: Gateway) => {\n  const { sitePathname } = gateway.runtimeSettings.developerPortal;\n  const devPortalId = Environment.instance.deploymentName;\n  const devPortalBaseUrl = Environment.instance.devPortalBaseUrl;\n  const devPortalRoute: RouteHandler = async (\n    request: ZuploRequest,\n    context: ZuploContext\n  ) => {\n    if (Environment.instance.isLocalDevelopment) {\n      return new Response(localDevelopmentDevPortalBanner, {\n        headers: { \"content-type\": \"text/html\" },\n      });\n    }\n\n    if (!devPortalId) {\n      return HttpProblems.internalServerError(request, context, {\n        detail:\n          \"Unable to retrieve deployment name. Please contact support for assistance.\",\n      });\n    }\n    const requestUrl = new URL(request.url);\n    const baseUrl = devPortalBaseURL(devPortalBaseUrl, request.headers);\n    const url = new URL(`${requestUrl.pathname}${requestUrl.search}`, baseUrl);\n    const { headers, method, body } = request;\n    if (Environment.instance.build.ACCOUNT_NAME) {\n      headers.set(\n        ZUPLO_ACCOUNT_HEADER,\n        Environment.instance.build.ACCOUNT_NAME\n      );\n    }\n    if (Environment.instance.build.PROJECT_NAME) {\n      headers.set(\n        ZUPLO_PROJECT_HEADER,\n        Environment.instance.build.PROJECT_NAME\n      );\n    }\n    headers.set(DEV_PORTAL_ID_HEADER, devPortalId);\n    // Vercel does not preserve the host header, so we set a custom header here\n    headers.set(DEV_PORTAL_ZUPLO_HOST_HEADER, requestUrl.host);\n    headers.set(\n      DEV_PORTAL_ZUPLO_BUILD_ID_HEADER,\n      Environment.instance.build.BUILD_ID\n    );\n    return await internals.fetch(url.toString(), {\n      headers,\n      method,\n      body,\n      redirect: \"manual\",\n    });\n  };\n\n  const zPipe = new Pipeline({\n    processors: [metricsProcessor, policyProcessor],\n    handler: devPortalRoute,\n    gateway,\n  });\n\n  const devPortalV3RouteConfiguration = new SystemRouteConfiguration({\n    label: \"SYSTEM_API_DOCS_V3_ROUTE\",\n    methods: [\"GET\", \"PUT\", \"POST\", \"DELETE\", \"PATCH\", \"HEAD\"],\n    path: `(${sitePathname}|/_next)(.*)`,\n    systemRouteName: SystemRouteName.DeveloperPortal,\n  });\n\n  router.addRoute(devPortalV3RouteConfiguration, zPipe.execute);\n};\n\n/**\n * @internal\n */\nexport const registerDevPortalLegacyRedirectRoute = (\n  router: Router,\n  gateway: Gateway\n) => {\n  const { sitePathname } = gateway.runtimeSettings.developerPortal;\n\n  const devPortalRedirectRoute: RouteHandler = async (\n    request: ZuploRequest\n  ) => {\n    const url = new URL(request.url);\n    url.pathname = `${sitePathname}${url.pathname.substring(\n      DEV_PORTAL_LEGACY_PATHNAME.length\n    )}`;\n\n    return Response.redirect(url.toString(), 302);\n  };\n\n  const zPipe = new Pipeline({\n    processors: [metricsProcessor],\n    handler: devPortalRedirectRoute,\n    gateway,\n  });\n  const devPortalLegacyRouteConfiguration = new SystemRouteConfiguration({\n    label: \"SYSTEM_API_DOCS_REDIRECT_ROUTE\",\n    methods: [\"GET\"],\n    path: `${DEV_PORTAL_LEGACY_PATHNAME}(.*)`,\n    systemRouteName: SystemRouteName.DeveloperPortalLegacy,\n  });\n\n  router.addRoute(devPortalLegacyRouteConfiguration, zPipe.execute);\n};\n", "import { LogLevel } from \"../interfaces\";\nimport {\n  LogEntry,\n  LogOwnerType,\n  LogSourceType,\n  LogTransport,\n} from \"./interfaces\";\nimport type { LoggingContext } from \"./logging-context\";\n\n/**\n * Counter for log order in an instance\n */\nlet vectorClock = 0;\n\n/**\n * @internal\n */\nexport class CoreLogger {\n  constructor(\n    level: LogLevel,\n    logOwner: LogOwnerType,\n    loggingId: string | undefined,\n    buildId: string,\n    transports: LogTransport[]\n  ) {\n    this.#logOwner = logOwner;\n    this.#loggingId = loggingId ?? \"local\";\n    this.#buildId = buildId;\n    this.#transports = transports;\n\n    this.#setupMethods(level);\n  }\n\n  #setupMethods = (logLevel: LogLevel) => {\n    const levelsInReverseOrder = [\"error\", \"warn\", \"info\", \"debug\"];\n    let hasHitSetLevel = false;\n\n    const emptyFunction = () => {\n      return; //logging disabled\n    };\n\n    const pushFunction = (entry: LogEntry, context: LoggingContext) => {\n      this.#transports.forEach((transport) => {\n        transport.log(entry, context);\n      });\n    };\n\n    levelsInReverseOrder.forEach((level) => {\n      this.#methods[level] = hasHitSetLevel ? emptyFunction : pushFunction;\n      if (level == logLevel) {\n        hasHitSetLevel = true;\n      }\n    });\n  };\n\n  readonly #methods: {\n    [key: string]: (entry: LogEntry, context: LoggingContext) => void;\n  } = {};\n  readonly #logOwner: LogOwnerType;\n  readonly #loggingId: string;\n  readonly #buildId: string;\n  readonly #transports: LogTransport[];\n\n  log(\n    level: LogLevel,\n    logSource: LogSourceType,\n    requestId: string,\n    rayId: string | null,\n    messages: unknown[],\n    context: LoggingContext\n  ): void {\n    if (vectorClock >= Number.MAX_SAFE_INTEGER) {\n      vectorClock = 0;\n    }\n\n    const entry: LogEntry = {\n      requestId,\n      rayId,\n      level,\n      logSource: logSource,\n      messages,\n      timestamp: new Date(),\n      logOwner: this.#logOwner,\n      loggingId: this.#loggingId,\n      buildId: this.#buildId,\n      vectorClock: vectorClock++,\n    };\n\n    this.#methods[level](entry, context);\n  }\n}\n", "import { RuntimePlugin } from \"../../plugins/plugins\";\nimport { LogTransport } from \"./interfaces\";\n\nexport abstract class LogPlugin extends RuntimePlugin {\n  /**\n   * @internal\n   */\n  abstract getTransport(): LogTransport;\n}\n", "import { ZuploEventContext } from \"../../interfaces\";\n\n/**\n * @internal\n */\nexport class LoggingContext {\n  constructor(\n    event: ZuploEventContext,\n    custom: Record<string, unknown>,\n    originalRequest: Request\n  ) {\n    this.#event = event;\n    this.custom = custom;\n    this.originalRequest = originalRequest;\n  }\n\n  readonly #event: ZuploEventContext;\n  readonly custom: Record<string, unknown>;\n  readonly originalRequest: Request;\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  waitUntil = (promise: Promise<any>) => {\n    this.#event.waitUntil(promise);\n  };\n}\n", "import { Logger } from \"../interfaces\";\nimport type { CoreLogger } from \"./core-logger\";\nimport type { LoggingContext } from \"./logging-context\";\n\n/**\n * @internal\n */\nexport class RequestLogger implements Logger {\n  constructor(\n    requestId: string,\n    rayId: string | null,\n    coreLogger: CoreLogger,\n    context: LoggingContext\n  ) {\n    this.#requestId = requestId;\n    this.#rayId = rayId;\n    this.#coreLogger = coreLogger;\n    this.#context = context;\n  }\n\n  readonly #logType = \"request\";\n  readonly #requestId: string;\n  readonly #rayId: string | null;\n  readonly #coreLogger: CoreLogger;\n  readonly #context: LoggingContext;\n\n  debug = (...messages: unknown[]): void => {\n    this.#coreLogger.log(\n      \"debug\",\n      this.#logType,\n      this.#requestId,\n      this.#rayId,\n      messages,\n      this.#context\n    );\n  };\n\n  info = (...messages: unknown[]): void => {\n    this.#coreLogger.log(\n      \"info\",\n      this.#logType,\n      this.#requestId,\n      this.#rayId,\n      messages,\n      this.#context\n    );\n  };\n\n  log = (...messages: unknown[]): void => {\n    this.#coreLogger.log(\n      \"info\",\n      this.#logType,\n      this.#requestId,\n      this.#rayId,\n      messages,\n      this.#context\n    );\n  };\n\n  warn = (...messages: unknown[]): void => {\n    this.#coreLogger.log(\n      \"warn\",\n      this.#logType,\n      this.#requestId,\n      this.#rayId,\n      messages,\n      this.#context\n    );\n  };\n\n  error = (...messages: unknown[]): void => {\n    this.#coreLogger.log(\n      \"error\",\n      this.#logType,\n      this.#requestId,\n      this.#rayId,\n      messages,\n      this.#context\n    );\n  };\n}\n", "/* eslint-disable tsdoc/syntax */\n/* eslint-disable @typescript-eslint/no-explicit-any */\n/* eslint-disable @typescript-eslint/ban-ts-comment */\nimport { isErrorLike } from \"./types\";\n\n// Source: https://github.com/sindresorhus/serialize-error\n// MIT License\n// Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (https://sindresorhus.com)\n\ninterface Options {\n  /**\n\tThe maximum depth of properties to preserve when serializing/deserializing.\n\n\t@default Number.POSITIVE_INFINITY\n\n\t@example\n\t```\n\timport {serializeError} from 'serialize-error';\n\n\tconst error = new Error('\uD83E\uDD84');\n\terror.one = {two: {three: {}}};\n\n\tconsole.log(serializeError(error, {maxDepth: 1}));\n\t//=> {name: 'Error', message: '\u2026', one: {}}\n\n\tconsole.log(serializeError(error, {maxDepth: 2}));\n\t//=> {name: 'Error', message: '\u2026', one: { two: {}}}\n\t```\n\t*/\n  readonly maxDepth?: number;\n\n  /**\n\tIndicate whether to use a `.toJSON()` method if encountered in the object. This is useful when a custom error implements its own serialization logic via `.toJSON()` but you prefer to not use it.\n\n\t@default true\n\t*/\n  readonly useToJSON?: boolean;\n}\n\nconst list: any = [\n  // Native ES errors https://262.ecma-international.org/12.0/#sec-well-known-intrinsic-objects\n  EvalError,\n  RangeError,\n  ReferenceError,\n  SyntaxError,\n  TypeError,\n  URIError,\n]\n  // Non-native Errors are used with `globalThis` because they might be missing. This filter drops them when undefined.\n  .filter(Boolean)\n  .map((constructor) => [constructor.name, constructor]);\n\nconst errorConstructors = new Map(list);\n\nexport class NonError extends Error {\n  override name = \"NonError\";\n\n  constructor(message: string) {\n    super(NonError._prepareSuperMessage(message));\n  }\n\n  static _prepareSuperMessage(message: string) {\n    try {\n      return JSON.stringify(message);\n    } catch {\n      return String(message);\n    }\n  }\n}\n\nconst commonProperties = [\n  {\n    property: \"name\",\n    enumerable: false,\n  },\n  {\n    property: \"message\",\n    enumerable: false,\n  },\n  {\n    property: \"stack\",\n    enumerable: false,\n  },\n  {\n    property: \"code\",\n    enumerable: true,\n  },\n  {\n    property: \"cause\",\n    enumerable: false,\n  },\n];\n\nconst toJsonWasCalled = Symbol(\".toJSON was called\");\n\nconst toJSON = (from: any) => {\n  from[toJsonWasCalled] = true;\n  const json = from.toJSON();\n  delete from[toJsonWasCalled];\n  return json;\n};\n\nconst getErrorConstructor = (name: string) =>\n  errorConstructors.get(name) ?? Error;\n\n// eslint-disable-next-line complexity\nconst destroyCircular = ({\n  from,\n  seen,\n  to,\n  forceEnumerable,\n  maxDepth,\n  depth,\n  useToJSON,\n  serialize,\n}: any) => {\n  if (!to) {\n    if (Array.isArray(from)) {\n      to = [];\n    } else if (!serialize && isErrorLike(from)) {\n      const Error = getErrorConstructor(from.name);\n      // @ts-ignore\n      to = new Error();\n    } else {\n      to = {};\n    }\n  }\n\n  seen.push(from);\n\n  if (depth >= maxDepth) {\n    return to;\n  }\n\n  if (\n    useToJSON &&\n    typeof from.toJSON === \"function\" &&\n    from[toJsonWasCalled] !== true\n  ) {\n    return toJSON(from);\n  }\n\n  const continueDestroyCircular = (value: any) =>\n    destroyCircular({\n      from: value,\n      seen: [...seen],\n      forceEnumerable,\n      maxDepth,\n      depth,\n      useToJSON,\n      serialize,\n    });\n\n  for (const [key, value] of Object.entries(from)) {\n    // eslint-disable-next-line node/prefer-global/buffer\n    if (typeof Buffer === \"function\" && Buffer.isBuffer(value)) {\n      to[key] = \"[object Buffer]\";\n      continue;\n    }\n\n    // TODO: Use `stream.isReadable()` when targeting Node.js 18.\n    if (\n      value !== null &&\n      typeof value === \"object\" &&\n      // @ts-ignore\n      typeof value.pipe === \"function\"\n    ) {\n      to[key] = \"[object Stream]\";\n      continue;\n    }\n\n    if (typeof value === \"function\") {\n      continue;\n    }\n\n    if (!value || typeof value !== \"object\") {\n      to[key] = value;\n      continue;\n    }\n\n    if (!seen.includes(from[key])) {\n      depth++;\n      to[key] = continueDestroyCircular(from[key]);\n\n      continue;\n    }\n\n    to[key] = \"[Circular]\";\n  }\n\n  for (const { property, enumerable } of commonProperties) {\n    if (typeof from[property] !== \"undefined\" && from[property] !== null) {\n      Object.defineProperty(to, property, {\n        value: isErrorLike(from[property])\n          ? continueDestroyCircular(from[property])\n          : from[property],\n        enumerable: forceEnumerable ? true : enumerable,\n        configurable: true,\n        writable: true,\n      });\n    }\n  }\n\n  return to;\n};\n\nexport function serializeError(value: unknown, options?: Options) {\n  const maxDepth = options?.maxDepth ?? Number.POSITIVE_INFINITY;\n  const useToJSON = options?.useToJSON ?? true;\n\n  if (typeof value === \"object\" && value !== null) {\n    return destroyCircular({\n      from: value,\n      seen: [],\n      forceEnumerable: true,\n      maxDepth,\n      depth: 0,\n      useToJSON,\n      serialize: true,\n    });\n  }\n\n  // People sometimes throw things besides Error objects\u2026\n  if (typeof value === \"function\") {\n    // `JSON.stringify()` discards functions. We do too, unless a function is thrown directly.\n    return `[Function: ${value.name ?? \"anonymous\"}]`;\n  }\n\n  return value;\n}\n\nconst filePathRegEx = /file:\\/\\/\\/(.*?)\\/dist\\//g;\nconst denoSourceEx = /\\(https:\\/\\/raw\\.githubusercontent\\.com\\/.*?\\)/g;\nconst eventString = \"at async Event.respondWith\";\n\nexport function cleanStack(value: any) {\n  if (typeof value !== \"string\") {\n    return value;\n  }\n\n  return value\n    .split(\"\\n\")\n    .filter((line) => !line.trim().startsWith(\"at async file\"))\n    .map((line, index) => {\n      const value = line\n        .replaceAll(filePathRegEx, \"\")\n        .replaceAll(denoSourceEx, \"\")\n        .replaceAll(eventString, \"\")\n        .trim();\n      if (index === 0 || value.length === 0) {\n        return value;\n      }\n      return `    ${value}`;\n    })\n    .filter((line) => line.length > 0)\n    .join(\"\\n\");\n}\n", "// Source: https://github.com/yeoman/stringify-object/blob/main/index.js\n\n/**\nCopyright (c) 2015, Yeoman team\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n1. Redistributions of source code must retain the above copyright notice, this\n   list of conditions and the following disclaimer.\n2. Redistributions in binary form must reproduce the above copyright notice,\n   this list of conditions and the following disclaimer in the documentation\n   and/or other materials provided with the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\nANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nimport { getOwnEnumerableKeys, isObject, isRegexp } from \"./types\";\n\ninterface Options {\n  indent?: string;\n  inlineCharacterLimit?: number;\n  maxDepth?: number;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  filter?: (input: any, element: string | symbol) => unknown;\n  transform?: (\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    input: any,\n    element: string | symbol | number,\n    value: string\n  ) => string;\n  singleQuotes?: boolean;\n}\n\nexport default function stringifyObject(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  input: any,\n  options?: Options,\n  pad = \"\"\n): string {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const seen: any[] = [];\n  const maxDepth = options?.maxDepth ?? 3;\n\n  return (function stringify(\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    input: any,\n    options: Options = {},\n    pad: string,\n    depth: number\n  ): string {\n    const indent = options.indent || \"  \";\n\n    let tokens: {\n      newline: string;\n      newlineOrSpace: string;\n      pad: string;\n      indent: string;\n    };\n    if (options.inlineCharacterLimit === undefined) {\n      tokens = {\n        newline: \"\\n\",\n        newlineOrSpace: \"\\n\",\n        pad,\n        indent: pad + indent,\n      };\n    } else {\n      tokens = {\n        newline: \"@@__STRINGIFY_OBJECT_NEW_LINE__@@\",\n        newlineOrSpace: \"@@__STRINGIFY_OBJECT_NEW_LINE_OR_SPACE__@@\",\n        pad: \"@@__STRINGIFY_OBJECT_PAD__@@\",\n        indent: \"@@__STRINGIFY_OBJECT_INDENT__@@\",\n      };\n    }\n\n    const expandWhiteSpace = (string: string) => {\n      if (options.inlineCharacterLimit === undefined) {\n        return string;\n      }\n\n      const oneLined = string\n        .replace(new RegExp(tokens.newline, \"g\"), \"\")\n        .replace(new RegExp(tokens.newlineOrSpace, \"g\"), \" \")\n        .replace(new RegExp(tokens.pad + \"|\" + tokens.indent, \"g\"), \"\");\n\n      if (oneLined.length <= options.inlineCharacterLimit) {\n        return oneLined;\n      }\n\n      return string\n        .replace(\n          new RegExp(tokens.newline + \"|\" + tokens.newlineOrSpace, \"g\"),\n          \"\\n\"\n        )\n        .replace(new RegExp(tokens.pad, \"g\"), pad)\n        .replace(new RegExp(tokens.indent, \"g\"), pad + indent);\n    };\n\n    if (seen.includes(input)) {\n      return '\"[Circular]\"';\n    }\n\n    if (\n      input === null ||\n      input === undefined ||\n      typeof input === \"number\" ||\n      typeof input === \"boolean\" ||\n      typeof input === \"function\" ||\n      typeof input === \"symbol\" ||\n      isRegexp(input)\n    ) {\n      return String(input);\n    }\n\n    if (input instanceof Date) {\n      return `new Date('${input.toISOString()}')`;\n    }\n\n    // Don't continue to serialize objects past the max depth\n    if (depth > maxDepth) {\n      return \"...\";\n    }\n\n    if (Array.isArray(input)) {\n      if (input.length === 0) {\n        return \"[]\";\n      }\n\n      seen.push(input);\n\n      const returnValue =\n        \"[\" +\n        tokens.newline +\n        input\n          .map((element, i) => {\n            const eol =\n              input.length - 1 === i\n                ? tokens.newline\n                : \",\" + tokens.newlineOrSpace;\n\n            let value = stringify(element, options, pad + indent, depth + 1);\n            if (options.transform) {\n              value = options.transform(input, i, value);\n            }\n\n            return tokens.indent + value + eol;\n          })\n          .join(\"\") +\n        tokens.pad +\n        \"]\";\n\n      seen.pop();\n\n      return expandWhiteSpace(returnValue);\n    }\n\n    if (isObject(input)) {\n      let objectKeys = getOwnEnumerableKeys(input);\n\n      if (options.filter) {\n        // eslint-disable-next-line unicorn/no-array-callback-reference, unicorn/no-array-method-this-argument\n        objectKeys = objectKeys.filter(\n          (element) => options.filter?.(input, element)\n        );\n      }\n\n      if (objectKeys.length === 0) {\n        return \"{}\";\n      }\n\n      seen.push(input);\n\n      const returnValue =\n        \"{\" +\n        tokens.newline +\n        objectKeys\n          .map((element, index) => {\n            const eol =\n              objectKeys.length - 1 === index\n                ? tokens.newline\n                : \",\" + tokens.newlineOrSpace;\n            const isSymbol = typeof element === \"symbol\";\n            const isClassic = !isSymbol && /^[a-z$_][$\\w]*$/i.test(element);\n            const key =\n              isSymbol || isClassic\n                ? element\n                : stringify(element, options, \"\", depth + 1);\n\n            let value = stringify(\n              input[element],\n              options,\n              pad + indent,\n              depth + 1\n            );\n            if (options.transform) {\n              value = options.transform(input, element, value);\n            }\n\n            return tokens.indent + String(key) + \": \" + value + eol;\n          })\n          .join(\"\") +\n        tokens.pad +\n        \"}\";\n\n      seen.pop();\n\n      return expandWhiteSpace(returnValue);\n    }\n\n    input = input.replace(/\\\\/g, \"\\\\\\\\\");\n    input = String(input).replace(/[\\r\\n]/g, (x) =>\n      x === \"\\n\" ? \"\\\\n\" : \"\\\\r\"\n    );\n\n    if (options.singleQuotes === false) {\n      input = input.replace(/\"/g, '\\\\\"');\n      return `\"${input}\"`;\n    }\n\n    input = input.replace(/'/g, \"\\\\'\");\n    return `'${input}'`;\n  })(input, options, pad, 0);\n}\n", "import { serializeError } from \"../../utils/serialize-error\";\nimport stringifyObject from \"../../utils/stringify-object\";\nimport { isErrorLike, toString } from \"../../utils/types\";\n\n/**\n * @internal\n * @param messages - The log messages\n * @returns\n * Takes an array of objects and checks to see if any are\n * an Error, if so it transforms that into an object that serializes into\n * JSON nicely (but is no longer an Error) - used for logging\n */\nexport function makeErrorsSerializable(messages: unknown[]) {\n  return messages.map((m) => serializeError(m));\n}\n\n/**\n *\n * @param messages - the log messages\n * @internal\n * Takes the first message and gives a best effort at extracting a sensible message\n * for use in the default message logs\n */\nexport function extractBestMessage(messages: unknown[]): string {\n  // this should never happen, checked up stream but just in case\n  // we never throw errors in logging though, so just set a default to\n  // warn the log consumer\n  if (messages.length === 0) {\n    return \"<no data provided to log>\";\n  }\n\n  const first = messages[0];\n\n  if (typeof first === \"string\") {\n    return first;\n  }\n\n  if (first instanceof Error) {\n    return first.message;\n  }\n\n  return stringifyNonString(serializeError(first));\n}\n\nexport function messagesToMultilineText(messages: unknown[]): string {\n  const text: string[] = [];\n  messages.forEach((message) => {\n    if (typeof message === \"string\") {\n      text.push(message);\n    } else if (isErrorLike(message)) {\n      if (message.stack) {\n        text.push(message.stack);\n      } else {\n        const serialized = stringifyObject(serializeError(message));\n        text.push(serialized);\n      }\n    } else if (typeof message === \"object\") {\n      const serialized = stringifyObject(message);\n      text.push(serialized);\n    } else {\n      const serialized = stringifyNonStringToText(message);\n      text.push(serialized);\n    }\n  });\n\n  return text.join(\"\\n\");\n}\n\n/**\n * Any object that isn't already a string will be stringified to a\n * JSON string\n */\nexport function stringifyNonString(value: unknown): string {\n  if (typeof value === \"string\") {\n    return value;\n  }\n  return JSON.stringify(value);\n}\n\n/**\n * Any object that isn't already a string will be stringified to a\n * flat string (non-JSON)\n */\nexport function stringifyNonStringToText(value: unknown): string {\n  if (typeof value === \"string\") {\n    return value;\n  }\n\n  if (value === null) {\n    return \"null\";\n  }\n\n  if (typeof value === \"undefined\") {\n    return \"undefined\";\n  }\n\n  if (\n    typeof value === \"number\" ||\n    typeof value === \"boolean\" ||\n    typeof value === \"bigint\" ||\n    typeof value === \"symbol\"\n  ) {\n    return value.toString();\n  }\n\n  if (typeof value === \"function\") {\n    return `[function ${value.name}]`;\n  }\n\n  if (typeof value === \"object\" && Array.isArray(value)) {\n    return `[array ${value.length}]`;\n  }\n\n  if (value instanceof Error) {\n    return `${value.name ?? \"Error\"}: ${value.message ?? \"unknown\"}`;\n  }\n\n  if (typeof value === \"object\") {\n    return toString(value);\n  }\n\n  return \"unknown\";\n}\n", "export default crypto;\nexport const isCryptoKey = (key) => key instanceof CryptoKey;\n", "import crypto from './webcrypto.js';\nconst digest = async (algorithm, data) => {\n    const subtleDigest = `SHA-${algorithm.slice(-3)}`;\n    return new Uint8Array(await crypto.subtle.digest(subtleDigest, data));\n};\nexport default digest;\n", "import digest from '../runtime/digest.js';\nexport const encoder = new TextEncoder();\nexport const decoder = new TextDecoder();\nconst MAX_INT32 = 2 ** 32;\nexport function concat(...buffers) {\n    const size = buffers.reduce((acc, { length }) => acc + length, 0);\n    const buf = new Uint8Array(size);\n    let i = 0;\n    buffers.forEach((buffer) => {\n        buf.set(buffer, i);\n        i += buffer.length;\n    });\n    return buf;\n}\nexport function p2s(alg, p2sInput) {\n    return concat(encoder.encode(alg), new Uint8Array([0]), p2sInput);\n}\nfunction writeUInt32BE(buf, value, offset) {\n    if (value < 0 || value >= MAX_INT32) {\n        throw new RangeError(`value must be >= 0 and <= ${MAX_INT32 - 1}. Received ${value}`);\n    }\n    buf.set([value >>> 24, value >>> 16, value >>> 8, value & 0xff], offset);\n}\nexport function uint64be(value) {\n    const high = Math.floor(value / MAX_INT32);\n    const low = value % MAX_INT32;\n    const buf = new Uint8Array(8);\n    writeUInt32BE(buf, high, 0);\n    writeUInt32BE(buf, low, 4);\n    return buf;\n}\nexport function uint32be(value) {\n    const buf = new Uint8Array(4);\n    writeUInt32BE(buf, value);\n    return buf;\n}\nexport function lengthAndInput(input) {\n    return concat(uint32be(input.length), input);\n}\nexport async function concatKdf(secret, bits, value) {\n    const iterations = Math.ceil((bits >> 3) / 32);\n    const res = new Uint8Array(iterations * 32);\n    for (let iter = 0; iter < iterations; iter++) {\n        const buf = new Uint8Array(4 + secret.length + value.length);\n        buf.set(uint32be(iter + 1));\n        buf.set(secret, 4);\n        buf.set(value, 4 + secret.length);\n        res.set(await digest('sha256', buf), iter * 32);\n    }\n    return res.slice(0, bits >> 3);\n}\n", "import { encoder, decoder } from '../lib/buffer_utils.js';\nexport const encodeBase64 = (input) => {\n    let unencoded = input;\n    if (typeof unencoded === 'string') {\n        unencoded = encoder.encode(unencoded);\n    }\n    const CHUNK_SIZE = 0x8000;\n    const arr = [];\n    for (let i = 0; i < unencoded.length; i += CHUNK_SIZE) {\n        arr.push(String.fromCharCode.apply(null, unencoded.subarray(i, i + CHUNK_SIZE)));\n    }\n    return btoa(arr.join(''));\n};\nexport const encode = (input) => {\n    return encodeBase64(input).replace(/=/g, '').replace(/\\+/g, '-').replace(/\\//g, '_');\n};\nexport const decodeBase64 = (encoded) => {\n    const binary = atob(encoded);\n    const bytes = new Uint8Array(binary.length);\n    for (let i = 0; i < binary.length; i++) {\n        bytes[i] = binary.charCodeAt(i);\n    }\n    return bytes;\n};\nexport const decode = (input) => {\n    let encoded = input;\n    if (encoded instanceof Uint8Array) {\n        encoded = decoder.decode(encoded);\n    }\n    encoded = encoded.replace(/-/g, '+').replace(/_/g, '/').replace(/\\s/g, '');\n    try {\n        return decodeBase64(encoded);\n    }\n    catch (_a) {\n        throw new TypeError('The input to be decoded is not correctly encoded.');\n    }\n};\n", "export class JOSEError extends Error {\n    static get code() {\n        return 'ERR_JOSE_GENERIC';\n    }\n    constructor(message) {\n        var _a;\n        super(message);\n        this.code = 'ERR_JOSE_GENERIC';\n        this.name = this.constructor.name;\n        (_a = Error.captureStackTrace) === null || _a === void 0 ? void 0 : _a.call(Error, this, this.constructor);\n    }\n}\nexport class JWTClaimValidationFailed extends JOSEError {\n    static get code() {\n        return 'ERR_JWT_CLAIM_VALIDATION_FAILED';\n    }\n    constructor(message, claim = 'unspecified', reason = 'unspecified') {\n        super(message);\n        this.code = 'ERR_JWT_CLAIM_VALIDATION_FAILED';\n        this.claim = claim;\n        this.reason = reason;\n    }\n}\nexport class JWTExpired extends JOSEError {\n    static get code() {\n        return 'ERR_JWT_EXPIRED';\n    }\n    constructor(message, claim = 'unspecified', reason = 'unspecified') {\n        super(message);\n        this.code = 'ERR_JWT_EXPIRED';\n        this.claim = claim;\n        this.reason = reason;\n    }\n}\nexport class JOSEAlgNotAllowed extends JOSEError {\n    constructor() {\n        super(...arguments);\n        this.code = 'ERR_JOSE_ALG_NOT_ALLOWED';\n    }\n    static get code() {\n        return 'ERR_JOSE_ALG_NOT_ALLOWED';\n    }\n}\nexport class JOSENotSupported extends JOSEError {\n    constructor() {\n        super(...arguments);\n        this.code = 'ERR_JOSE_NOT_SUPPORTED';\n    }\n    static get code() {\n        return 'ERR_JOSE_NOT_SUPPORTED';\n    }\n}\nexport class JWEDecryptionFailed extends JOSEError {\n    constructor() {\n        super(...arguments);\n        this.code = 'ERR_JWE_DECRYPTION_FAILED';\n        this.message = 'decryption operation failed';\n    }\n    static get code() {\n        return 'ERR_JWE_DECRYPTION_FAILED';\n    }\n}\nexport class JWEInvalid extends JOSEError {\n    constructor() {\n        super(...arguments);\n        this.code = 'ERR_JWE_INVALID';\n    }\n    static get code() {\n        return 'ERR_JWE_INVALID';\n    }\n}\nexport class JWSInvalid extends JOSEError {\n    constructor() {\n        super(...arguments);\n        this.code = 'ERR_JWS_INVALID';\n    }\n    static get code() {\n        return 'ERR_JWS_INVALID';\n    }\n}\nexport class JWTInvalid extends JOSEError {\n    constructor() {\n        super(...arguments);\n        this.code = 'ERR_JWT_INVALID';\n    }\n    static get code() {\n        return 'ERR_JWT_INVALID';\n    }\n}\nexport class JWKInvalid extends JOSEError {\n    constructor() {\n        super(...arguments);\n        this.code = 'ERR_JWK_INVALID';\n    }\n    static get code() {\n        return 'ERR_JWK_INVALID';\n    }\n}\nexport class JWKSInvalid extends JOSEError {\n    constructor() {\n        super(...arguments);\n        this.code = 'ERR_JWKS_INVALID';\n    }\n    static get code() {\n        return 'ERR_JWKS_INVALID';\n    }\n}\nexport class JWKSNoMatchingKey extends JOSEError {\n    constructor() {\n        super(...arguments);\n        this.code = 'ERR_JWKS_NO_MATCHING_KEY';\n        this.message = 'no applicable key found in the JSON Web Key Set';\n    }\n    static get code() {\n        return 'ERR_JWKS_NO_MATCHING_KEY';\n    }\n}\nexport class JWKSMultipleMatchingKeys extends JOSEError {\n    constructor() {\n        super(...arguments);\n        this.code = 'ERR_JWKS_MULTIPLE_MATCHING_KEYS';\n        this.message = 'multiple matching keys found in the JSON Web Key Set';\n    }\n    static get code() {\n        return 'ERR_JWKS_MULTIPLE_MATCHING_KEYS';\n    }\n}\nSymbol.asyncIterator;\nexport class JWKSTimeout extends JOSEError {\n    constructor() {\n        super(...arguments);\n        this.code = 'ERR_JWKS_TIMEOUT';\n        this.message = 'request timed out';\n    }\n    static get code() {\n        return 'ERR_JWKS_TIMEOUT';\n    }\n}\nexport class JWSSignatureVerificationFailed extends JOSEError {\n    constructor() {\n        super(...arguments);\n        this.code = 'ERR_JWS_SIGNATURE_VERIFICATION_FAILED';\n        this.message = 'signature verification failed';\n    }\n    static get code() {\n        return 'ERR_JWS_SIGNATURE_VERIFICATION_FAILED';\n    }\n}\n", "import crypto from './webcrypto.js';\nexport default crypto.getRandomValues.bind(crypto);\n", "import { JOSENotSupported } from '../util/errors.js';\nimport random from '../runtime/random.js';\nexport function bitLength(alg) {\n    switch (alg) {\n        case 'A128GCM':\n        case 'A128GCMKW':\n        case 'A192GCM':\n        case 'A192GCMKW':\n        case 'A256GCM':\n        case 'A256GCMKW':\n            return 96;\n        case 'A128CBC-HS256':\n        case 'A192CBC-HS384':\n        case 'A256CBC-HS512':\n            return 128;\n        default:\n            throw new JOSENotSupported(`Unsupported JWE Algorithm: ${alg}`);\n    }\n}\nexport default (alg) => random(new Uint8Array(bitLength(alg) >> 3));\n", "import { JWEInvalid } from '../util/errors.js';\nimport { bitLength } from './iv.js';\nconst checkIvLength = (enc, iv) => {\n    if (iv.length << 3 !== bitLength(enc)) {\n        throw new JWEInvalid('Invalid Initialization Vector length');\n    }\n};\nexport default checkIvLength;\n", "import { JWEInvalid } from '../util/errors.js';\nconst checkCekLength = (cek, expected) => {\n    const actual = cek.byteLength << 3;\n    if (actual !== expected) {\n        throw new JWEInvalid(`Invalid Content Encryption Key length. Expected ${expected} bits, got ${actual} bits`);\n    }\n};\nexport default checkCekLength;\n", "const timingSafeEqual = (a, b) => {\n    if (!(a instanceof Uint8Array)) {\n        throw new TypeError('First argument must be a buffer');\n    }\n    if (!(b instanceof Uint8Array)) {\n        throw new TypeError('Second argument must be a buffer');\n    }\n    if (a.length !== b.length) {\n        throw new TypeError('Input buffers must have the same length');\n    }\n    const len = a.length;\n    let out = 0;\n    let i = -1;\n    while (++i < len) {\n        out |= a[i] ^ b[i];\n    }\n    return out === 0;\n};\nexport default timingSafeEqual;\n", "function unusable(name, prop = 'algorithm.name') {\n    return new TypeError(`CryptoKey does not support this operation, its ${prop} must be ${name}`);\n}\nfunction isAlgorithm(algorithm, name) {\n    return algorithm.name === name;\n}\nfunction getHashLength(hash) {\n    return parseInt(hash.name.slice(4), 10);\n}\nfunction getNamedCurve(alg) {\n    switch (alg) {\n        case 'ES256':\n            return 'P-256';\n        case 'ES384':\n            return 'P-384';\n        case 'ES512':\n            return 'P-521';\n        default:\n            throw new Error('unreachable');\n    }\n}\nfunction checkUsage(key, usages) {\n    if (usages.length && !usages.some((expected) => key.usages.includes(expected))) {\n        let msg = 'CryptoKey does not support this operation, its usages must include ';\n        if (usages.length > 2) {\n            const last = usages.pop();\n            msg += `one of ${usages.join(', ')}, or ${last}.`;\n        }\n        else if (usages.length === 2) {\n            msg += `one of ${usages[0]} or ${usages[1]}.`;\n        }\n        else {\n            msg += `${usages[0]}.`;\n        }\n        throw new TypeError(msg);\n    }\n}\nexport function checkSigCryptoKey(key, alg, ...usages) {\n    switch (alg) {\n        case 'HS256':\n        case 'HS384':\n        case 'HS512': {\n            if (!isAlgorithm(key.algorithm, 'HMAC'))\n                throw unusable('HMAC');\n            const expected = parseInt(alg.slice(2), 10);\n            const actual = getHashLength(key.algorithm.hash);\n            if (actual !== expected)\n                throw unusable(`SHA-${expected}`, 'algorithm.hash');\n            break;\n        }\n        case 'RS256':\n        case 'RS384':\n        case 'RS512': {\n            if (!isAlgorithm(key.algorithm, 'RSASSA-PKCS1-v1_5'))\n                throw unusable('RSASSA-PKCS1-v1_5');\n            const expected = parseInt(alg.slice(2), 10);\n            const actual = getHashLength(key.algorithm.hash);\n            if (actual !== expected)\n                throw unusable(`SHA-${expected}`, 'algorithm.hash');\n            break;\n        }\n        case 'PS256':\n        case 'PS384':\n        case 'PS512': {\n            if (!isAlgorithm(key.algorithm, 'RSA-PSS'))\n                throw unusable('RSA-PSS');\n            const expected = parseInt(alg.slice(2), 10);\n            const actual = getHashLength(key.algorithm.hash);\n            if (actual !== expected)\n                throw unusable(`SHA-${expected}`, 'algorithm.hash');\n            break;\n        }\n        case 'EdDSA': {\n            if (key.algorithm.name !== 'Ed25519' && key.algorithm.name !== 'Ed448') {\n                throw unusable('Ed25519 or Ed448');\n            }\n            break;\n        }\n        case 'ES256':\n        case 'ES384':\n        case 'ES512': {\n            if (!isAlgorithm(key.algorithm, 'ECDSA'))\n                throw unusable('ECDSA');\n            const expected = getNamedCurve(alg);\n            const actual = key.algorithm.namedCurve;\n            if (actual !== expected)\n                throw unusable(expected, 'algorithm.namedCurve');\n            break;\n        }\n        default:\n            throw new TypeError('CryptoKey does not support this operation');\n    }\n    checkUsage(key, usages);\n}\nexport function checkEncCryptoKey(key, alg, ...usages) {\n    switch (alg) {\n        case 'A128GCM':\n        case 'A192GCM':\n        case 'A256GCM': {\n            if (!isAlgorithm(key.algorithm, 'AES-GCM'))\n                throw unusable('AES-GCM');\n            const expected = parseInt(alg.slice(1, 4), 10);\n            const actual = key.algorithm.length;\n            if (actual !== expected)\n                throw unusable(expected, 'algorithm.length');\n            break;\n        }\n        case 'A128KW':\n        case 'A192KW':\n        case 'A256KW': {\n            if (!isAlgorithm(key.algorithm, 'AES-KW'))\n                throw unusable('AES-KW');\n            const expected = parseInt(alg.slice(1, 4), 10);\n            const actual = key.algorithm.length;\n            if (actual !== expected)\n                throw unusable(expected, 'algorithm.length');\n            break;\n        }\n        case 'ECDH': {\n            switch (key.algorithm.name) {\n                case 'ECDH':\n                case 'X25519':\n                case 'X448':\n                    break;\n                default:\n                    throw unusable('ECDH, X25519, or X448');\n            }\n            break;\n        }\n        case 'PBES2-HS256+A128KW':\n        case 'PBES2-HS384+A192KW':\n        case 'PBES2-HS512+A256KW':\n            if (!isAlgorithm(key.algorithm, 'PBKDF2'))\n                throw unusable('PBKDF2');\n            break;\n        case 'RSA-OAEP':\n        case 'RSA-OAEP-256':\n        case 'RSA-OAEP-384':\n        case 'RSA-OAEP-512': {\n            if (!isAlgorithm(key.algorithm, 'RSA-OAEP'))\n                throw unusable('RSA-OAEP');\n            const expected = parseInt(alg.slice(9), 10) || 1;\n            const actual = getHashLength(key.algorithm.hash);\n            if (actual !== expected)\n                throw unusable(`SHA-${expected}`, 'algorithm.hash');\n            break;\n        }\n        default:\n            throw new TypeError('CryptoKey does not support this operation');\n    }\n    checkUsage(key, usages);\n}\n", "function message(msg, actual, ...types) {\n    if (types.length > 2) {\n        const last = types.pop();\n        msg += `one of type ${types.join(', ')}, or ${last}.`;\n    }\n    else if (types.length === 2) {\n        msg += `one of type ${types[0]} or ${types[1]}.`;\n    }\n    else {\n        msg += `of type ${types[0]}.`;\n    }\n    if (actual == null) {\n        msg += ` Received ${actual}`;\n    }\n    else if (typeof actual === 'function' && actual.name) {\n        msg += ` Received function ${actual.name}`;\n    }\n    else if (typeof actual === 'object' && actual != null) {\n        if (actual.constructor && actual.constructor.name) {\n            msg += ` Received an instance of ${actual.constructor.name}`;\n        }\n    }\n    return msg;\n}\nexport default (actual, ...types) => {\n    return message('Key must be ', actual, ...types);\n};\nexport function withAlg(alg, actual, ...types) {\n    return message(`Key for the ${alg} algorithm must be `, actual, ...types);\n}\n", "import { isCryptoKey } from './webcrypto.js';\nexport default (key) => {\n    return isCryptoKey(key);\n};\nexport const types = ['CryptoKey'];\n", "import { concat, uint64be } from '../lib/buffer_utils.js';\nimport checkIvLength from '../lib/check_iv_length.js';\nimport checkCekLength from './check_cek_length.js';\nimport timingSafeEqual from './timing_safe_equal.js';\nimport { JOSENotSupported, JWEDecryptionFailed } from '../util/errors.js';\nimport crypto, { isCryptoKey } from './webcrypto.js';\nimport { checkEncCryptoKey } from '../lib/crypto_key.js';\nimport invalidKeyInput from '../lib/invalid_key_input.js';\nimport { types } from './is_key_like.js';\nasync function cbcDecrypt(enc, cek, ciphertext, iv, tag, aad) {\n    if (!(cek instanceof Uint8Array)) {\n        throw new TypeError(invalidKeyInput(cek, 'Uint8Array'));\n    }\n    const keySize = parseInt(enc.slice(1, 4), 10);\n    const encKey = await crypto.subtle.importKey('raw', cek.subarray(keySize >> 3), 'AES-CBC', false, ['decrypt']);\n    const macKey = await crypto.subtle.importKey('raw', cek.subarray(0, keySize >> 3), {\n        hash: `SHA-${keySize << 1}`,\n        name: 'HMAC',\n    }, false, ['sign']);\n    const macData = concat(aad, iv, ciphertext, uint64be(aad.length << 3));\n    const expectedTag = new Uint8Array((await crypto.subtle.sign('HMAC', macKey, macData)).slice(0, keySize >> 3));\n    let macCheckPassed;\n    try {\n        macCheckPassed = timingSafeEqual(tag, expectedTag);\n    }\n    catch (_a) {\n    }\n    if (!macCheckPassed) {\n        throw new JWEDecryptionFailed();\n    }\n    let plaintext;\n    try {\n        plaintext = new Uint8Array(await crypto.subtle.decrypt({ iv, name: 'AES-CBC' }, encKey, ciphertext));\n    }\n    catch (_b) {\n    }\n    if (!plaintext) {\n        throw new JWEDecryptionFailed();\n    }\n    return plaintext;\n}\nasync function gcmDecrypt(enc, cek, ciphertext, iv, tag, aad) {\n    let encKey;\n    if (cek instanceof Uint8Array) {\n        encKey = await crypto.subtle.importKey('raw', cek, 'AES-GCM', false, ['decrypt']);\n    }\n    else {\n        checkEncCryptoKey(cek, enc, 'decrypt');\n        encKey = cek;\n    }\n    try {\n        return new Uint8Array(await crypto.subtle.decrypt({\n            additionalData: aad,\n            iv,\n            name: 'AES-GCM',\n            tagLength: 128,\n        }, encKey, concat(ciphertext, tag)));\n    }\n    catch (_a) {\n        throw new JWEDecryptionFailed();\n    }\n}\nconst decrypt = async (enc, cek, ciphertext, iv, tag, aad) => {\n    if (!isCryptoKey(cek) && !(cek instanceof Uint8Array)) {\n        throw new TypeError(invalidKeyInput(cek, ...types, 'Uint8Array'));\n    }\n    checkIvLength(enc, iv);\n    switch (enc) {\n        case 'A128CBC-HS256':\n        case 'A192CBC-HS384':\n        case 'A256CBC-HS512':\n            if (cek instanceof Uint8Array)\n                checkCekLength(cek, parseInt(enc.slice(-3), 10));\n            return cbcDecrypt(enc, cek, ciphertext, iv, tag, aad);\n        case 'A128GCM':\n        case 'A192GCM':\n        case 'A256GCM':\n            if (cek instanceof Uint8Array)\n                checkCekLength(cek, parseInt(enc.slice(1, 4), 10));\n            return gcmDecrypt(enc, cek, ciphertext, iv, tag, aad);\n        default:\n            throw new JOSENotSupported('Unsupported JWE Content Encryption Algorithm');\n    }\n};\nexport default decrypt;\n", "import { JOSENotSupported } from '../util/errors.js';\nexport const inflate = async () => {\n    throw new JOSENotSupported('JWE \"zip\" (Compression Algorithm) Header Parameter is not supported by your javascript runtime. You need to use the `inflateRaw` decrypt option to provide Inflate Raw implementation.');\n};\nexport const deflate = async () => {\n    throw new JOSENotSupported('JWE \"zip\" (Compression Algorithm) Header Parameter is not supported by your javascript runtime. You need to use the `deflateRaw` encrypt option to provide Deflate Raw implementation.');\n};\n", "const isDisjoint = (...headers) => {\n    const sources = headers.filter(Boolean);\n    if (sources.length === 0 || sources.length === 1) {\n        return true;\n    }\n    let acc;\n    for (const header of sources) {\n        const parameters = Object.keys(header);\n        if (!acc || acc.size === 0) {\n            acc = new Set(parameters);\n            continue;\n        }\n        for (const parameter of parameters) {\n            if (acc.has(parameter)) {\n                return false;\n            }\n            acc.add(parameter);\n        }\n    }\n    return true;\n};\nexport default isDisjoint;\n", "function isObjectLike(value) {\n    return typeof value === 'object' && value !== null;\n}\nexport default function isObject(input) {\n    if (!isObjectLike(input) || Object.prototype.toString.call(input) !== '[object Object]') {\n        return false;\n    }\n    if (Object.getPrototypeOf(input) === null) {\n        return true;\n    }\n    let proto = input;\n    while (Object.getPrototypeOf(proto) !== null) {\n        proto = Object.getPrototypeOf(proto);\n    }\n    return Object.getPrototypeOf(input) === proto;\n}\n", "const bogusWebCrypto = [\n    { hash: 'SHA-256', name: 'HMAC' },\n    true,\n    ['sign'],\n];\nexport default bogusWebCrypto;\n", "import bogusWebCrypto from './bogus.js';\nimport crypto, { isCryptoKey } from './webcrypto.js';\nimport { checkEncCryptoKey } from '../lib/crypto_key.js';\nimport invalidKeyInput from '../lib/invalid_key_input.js';\nimport { types } from './is_key_like.js';\nfunction checkKeySize(key, alg) {\n    if (key.algorithm.length !== parseInt(alg.slice(1, 4), 10)) {\n        throw new TypeError(`Invalid key size for alg: ${alg}`);\n    }\n}\nfunction getCryptoKey(key, alg, usage) {\n    if (isCryptoKey(key)) {\n        checkEncCryptoKey(key, alg, usage);\n        return key;\n    }\n    if (key instanceof Uint8Array) {\n        return crypto.subtle.importKey('raw', key, 'AES-KW', true, [usage]);\n    }\n    throw new TypeError(invalidKeyInput(key, ...types, 'Uint8Array'));\n}\nexport const wrap = async (alg, key, cek) => {\n    const cryptoKey = await getCryptoKey(key, alg, 'wrapKey');\n    checkKeySize(cryptoKey, alg);\n    const cryptoKeyCek = await crypto.subtle.importKey('raw', cek, ...bogusWebCrypto);\n    return new Uint8Array(await crypto.subtle.wrapKey('raw', cryptoKeyCek, cryptoKey, 'AES-KW'));\n};\nexport const unwrap = async (alg, key, encryptedKey) => {\n    const cryptoKey = await getCryptoKey(key, alg, 'unwrapKey');\n    checkKeySize(cryptoKey, alg);\n    const cryptoKeyCek = await crypto.subtle.unwrapKey('raw', encryptedKey, cryptoKey, 'AES-KW', ...bogusWebCrypto);\n    return new Uint8Array(await crypto.subtle.exportKey('raw', cryptoKeyCek));\n};\n", "import { encoder, concat, uint32be, lengthAndInput, concatKdf } from '../lib/buffer_utils.js';\nimport crypto, { isCryptoKey } from './webcrypto.js';\nimport { checkEncCryptoKey } from '../lib/crypto_key.js';\nimport invalidKeyInput from '../lib/invalid_key_input.js';\nimport { types } from './is_key_like.js';\nexport async function deriveKey(publicKey, privateKey, algorithm, keyLength, apu = new Uint8Array(0), apv = new Uint8Array(0)) {\n    if (!isCryptoKey(publicKey)) {\n        throw new TypeError(invalidKeyInput(publicKey, ...types));\n    }\n    checkEncCryptoKey(publicKey, 'ECDH');\n    if (!isCryptoKey(privateKey)) {\n        throw new TypeError(invalidKeyInput(privateKey, ...types));\n    }\n    checkEncCryptoKey(privateKey, 'ECDH', 'deriveBits');\n    const value = concat(lengthAndInput(encoder.encode(algorithm)), lengthAndInput(apu), lengthAndInput(apv), uint32be(keyLength));\n    let length;\n    if (publicKey.algorithm.name === 'X25519') {\n        length = 256;\n    }\n    else if (publicKey.algorithm.name === 'X448') {\n        length = 448;\n    }\n    else {\n        length =\n            Math.ceil(parseInt(publicKey.algorithm.namedCurve.substr(-3), 10) / 8) << 3;\n    }\n    const sharedSecret = new Uint8Array(await crypto.subtle.deriveBits({\n        name: publicKey.algorithm.name,\n        public: publicKey,\n    }, privateKey, length));\n    return concatKdf(sharedSecret, keyLength, value);\n}\nexport async function generateEpk(key) {\n    if (!isCryptoKey(key)) {\n        throw new TypeError(invalidKeyInput(key, ...types));\n    }\n    return crypto.subtle.generateKey(key.algorithm, true, ['deriveBits']);\n}\nexport function ecdhAllowed(key) {\n    if (!isCryptoKey(key)) {\n        throw new TypeError(invalidKeyInput(key, ...types));\n    }\n    return (['P-256', 'P-384', 'P-521'].includes(key.algorithm.namedCurve) ||\n        key.algorithm.name === 'X25519' ||\n        key.algorithm.name === 'X448');\n}\n", "import { JWEInvalid } from '../util/errors.js';\nexport default function checkP2s(p2s) {\n    if (!(p2s instanceof Uint8Array) || p2s.length < 8) {\n        throw new JWEInvalid('PBES2 Salt Input must be 8 or more octets');\n    }\n}\n", "import random from './random.js';\nimport { p2s as concatSalt } from '../lib/buffer_utils.js';\nimport { encode as base64url } from './base64url.js';\nimport { wrap, unwrap } from './aeskw.js';\nimport checkP2s from '../lib/check_p2s.js';\nimport crypto, { isCryptoKey } from './webcrypto.js';\nimport { checkEncCryptoKey } from '../lib/crypto_key.js';\nimport invalidKeyInput from '../lib/invalid_key_input.js';\nimport { types } from './is_key_like.js';\nfunction getCryptoKey(key, alg) {\n    if (key instanceof Uint8Array) {\n        return crypto.subtle.importKey('raw', key, 'PBKDF2', false, ['deriveBits']);\n    }\n    if (isCryptoKey(key)) {\n        checkEncCryptoKey(key, alg, 'deriveBits', 'deriveKey');\n        return key;\n    }\n    throw new TypeError(invalidKeyInput(key, ...types, 'Uint8Array'));\n}\nasync function deriveKey(p2s, alg, p2c, key) {\n    checkP2s(p2s);\n    const salt = concatSalt(alg, p2s);\n    const keylen = parseInt(alg.slice(13, 16), 10);\n    const subtleAlg = {\n        hash: `SHA-${alg.slice(8, 11)}`,\n        iterations: p2c,\n        name: 'PBKDF2',\n        salt,\n    };\n    const wrapAlg = {\n        length: keylen,\n        name: 'AES-KW',\n    };\n    const cryptoKey = await getCryptoKey(key, alg);\n    if (cryptoKey.usages.includes('deriveBits')) {\n        return new Uint8Array(await crypto.subtle.deriveBits(subtleAlg, cryptoKey, keylen));\n    }\n    if (cryptoKey.usages.includes('deriveKey')) {\n        return crypto.subtle.deriveKey(subtleAlg, cryptoKey, wrapAlg, false, ['wrapKey', 'unwrapKey']);\n    }\n    throw new TypeError('PBKDF2 key \"usages\" must include \"deriveBits\" or \"deriveKey\"');\n}\nexport const encrypt = async (alg, key, cek, p2c = 2048, p2s = random(new Uint8Array(16))) => {\n    const derived = await deriveKey(p2s, alg, p2c, key);\n    const encryptedKey = await wrap(alg.slice(-6), derived, cek);\n    return { encryptedKey, p2c, p2s: base64url(p2s) };\n};\nexport const decrypt = async (alg, key, encryptedKey, p2c, p2s) => {\n    const derived = await deriveKey(p2s, alg, p2c, key);\n    return unwrap(alg.slice(-6), derived, encryptedKey);\n};\n", "import { JOSENotSupported } from '../util/errors.js';\nexport default function subtleRsaEs(alg) {\n    switch (alg) {\n        case 'RSA-OAEP':\n        case 'RSA-OAEP-256':\n        case 'RSA-OAEP-384':\n        case 'RSA-OAEP-512':\n            return 'RSA-OAEP';\n        default:\n            throw new JOSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`);\n    }\n}\n", "export default (alg, key) => {\n    if (alg.startsWith('RS') || alg.startsWith('PS')) {\n        const { modulusLength } = key.algorithm;\n        if (typeof modulusLength !== 'number' || modulusLength < 2048) {\n            throw new TypeError(`${alg} requires key modulusLength to be 2048 bits or larger`);\n        }\n    }\n};\n", "import subtleAlgorithm from './subtle_rsaes.js';\nimport bogusWebCrypto from './bogus.js';\nimport crypto, { isCryptoKey } from './webcrypto.js';\nimport { checkEncCryptoKey } from '../lib/crypto_key.js';\nimport checkKeyLength from './check_key_length.js';\nimport invalidKeyInput from '../lib/invalid_key_input.js';\nimport { types } from './is_key_like.js';\nexport const encrypt = async (alg, key, cek) => {\n    if (!isCryptoKey(key)) {\n        throw new TypeError(invalidKeyInput(key, ...types));\n    }\n    checkEncCryptoKey(key, alg, 'encrypt', 'wrapKey');\n    checkKeyLength(alg, key);\n    if (key.usages.includes('encrypt')) {\n        return new Uint8Array(await crypto.subtle.encrypt(subtleAlgorithm(alg), key, cek));\n    }\n    if (key.usages.includes('wrapKey')) {\n        const cryptoKeyCek = await crypto.subtle.importKey('raw', cek, ...bogusWebCrypto);\n        return new Uint8Array(await crypto.subtle.wrapKey('raw', cryptoKeyCek, key, subtleAlgorithm(alg)));\n    }\n    throw new TypeError('RSA-OAEP key \"usages\" must include \"encrypt\" or \"wrapKey\" for this operation');\n};\nexport const decrypt = async (alg, key, encryptedKey) => {\n    if (!isCryptoKey(key)) {\n        throw new TypeError(invalidKeyInput(key, ...types));\n    }\n    checkEncCryptoKey(key, alg, 'decrypt', 'unwrapKey');\n    checkKeyLength(alg, key);\n    if (key.usages.includes('decrypt')) {\n        return new Uint8Array(await crypto.subtle.decrypt(subtleAlgorithm(alg), key, encryptedKey));\n    }\n    if (key.usages.includes('unwrapKey')) {\n        const cryptoKeyCek = await crypto.subtle.unwrapKey('raw', encryptedKey, key, subtleAlgorithm(alg), ...bogusWebCrypto);\n        return new Uint8Array(await crypto.subtle.exportKey('raw', cryptoKeyCek));\n    }\n    throw new TypeError('RSA-OAEP key \"usages\" must include \"decrypt\" or \"unwrapKey\" for this operation');\n};\n", "import { JOSENotSupported } from '../util/errors.js';\nimport random from '../runtime/random.js';\nexport function bitLength(alg) {\n    switch (alg) {\n        case 'A128GCM':\n            return 128;\n        case 'A192GCM':\n            return 192;\n        case 'A256GCM':\n        case 'A128CBC-HS256':\n            return 256;\n        case 'A192CBC-HS384':\n            return 384;\n        case 'A256CBC-HS512':\n            return 512;\n        default:\n            throw new JOSENotSupported(`Unsupported JWE Algorithm: ${alg}`);\n    }\n}\nexport default (alg) => random(new Uint8Array(bitLength(alg) >> 3));\n", "export default (b64, descriptor) => {\n    const newlined = (b64.match(/.{1,64}/g) || []).join('\\n');\n    return `-----BEGIN ${descriptor}-----\\n${newlined}\\n-----END ${descriptor}-----`;\n};\n", "import crypto, { isCryptoKey } from './webcrypto.js';\nimport invalidKeyInput from '../lib/invalid_key_input.js';\nimport { encodeBase64, decodeBase64 } from './base64url.js';\nimport formatPEM from '../lib/format_pem.js';\nimport { JOSENotSupported } from '../util/errors.js';\nimport { types } from './is_key_like.js';\nconst genericExport = async (keyType, keyFormat, key) => {\n    if (!isCryptoKey(key)) {\n        throw new TypeError(invalidKeyInput(key, ...types));\n    }\n    if (!key.extractable) {\n        throw new TypeError('CryptoKey is not extractable');\n    }\n    if (key.type !== keyType) {\n        throw new TypeError(`key is not a ${keyType} key`);\n    }\n    return formatPEM(encodeBase64(new Uint8Array(await crypto.subtle.exportKey(keyFormat, key))), `${keyType.toUpperCase()} KEY`);\n};\nexport const toSPKI = (key) => {\n    return genericExport('public', 'spki', key);\n};\nexport const toPKCS8 = (key) => {\n    return genericExport('private', 'pkcs8', key);\n};\nconst findOid = (keyData, oid, from = 0) => {\n    if (from === 0) {\n        oid.unshift(oid.length);\n        oid.unshift(0x06);\n    }\n    let i = keyData.indexOf(oid[0], from);\n    if (i === -1)\n        return false;\n    const sub = keyData.subarray(i, i + oid.length);\n    if (sub.length !== oid.length)\n        return false;\n    return sub.every((value, index) => value === oid[index]) || findOid(keyData, oid, i + 1);\n};\nconst getNamedCurve = (keyData) => {\n    switch (true) {\n        case findOid(keyData, [0x2a, 0x86, 0x48, 0xce, 0x3d, 0x03, 0x01, 0x07]):\n            return 'P-256';\n        case findOid(keyData, [0x2b, 0x81, 0x04, 0x00, 0x22]):\n            return 'P-384';\n        case findOid(keyData, [0x2b, 0x81, 0x04, 0x00, 0x23]):\n            return 'P-521';\n        case findOid(keyData, [0x2b, 0x65, 0x6e]):\n            return 'X25519';\n        case findOid(keyData, [0x2b, 0x65, 0x6f]):\n            return 'X448';\n        case findOid(keyData, [0x2b, 0x65, 0x70]):\n            return 'Ed25519';\n        case findOid(keyData, [0x2b, 0x65, 0x71]):\n            return 'Ed448';\n        default:\n            throw new JOSENotSupported('Invalid or unsupported EC Key Curve or OKP Key Sub Type');\n    }\n};\nconst genericImport = async (replace, keyFormat, pem, alg, options) => {\n    var _a;\n    let algorithm;\n    let keyUsages;\n    const keyData = new Uint8Array(atob(pem.replace(replace, ''))\n        .split('')\n        .map((c) => c.charCodeAt(0)));\n    const isPublic = keyFormat === 'spki';\n    switch (alg) {\n        case 'PS256':\n        case 'PS384':\n        case 'PS512':\n            algorithm = { name: 'RSA-PSS', hash: `SHA-${alg.slice(-3)}` };\n            keyUsages = isPublic ? ['verify'] : ['sign'];\n            break;\n        case 'RS256':\n        case 'RS384':\n        case 'RS512':\n            algorithm = { name: 'RSASSA-PKCS1-v1_5', hash: `SHA-${alg.slice(-3)}` };\n            keyUsages = isPublic ? ['verify'] : ['sign'];\n            break;\n        case 'RSA-OAEP':\n        case 'RSA-OAEP-256':\n        case 'RSA-OAEP-384':\n        case 'RSA-OAEP-512':\n            algorithm = {\n                name: 'RSA-OAEP',\n                hash: `SHA-${parseInt(alg.slice(-3), 10) || 1}`,\n            };\n            keyUsages = isPublic ? ['encrypt', 'wrapKey'] : ['decrypt', 'unwrapKey'];\n            break;\n        case 'ES256':\n            algorithm = { name: 'ECDSA', namedCurve: 'P-256' };\n            keyUsages = isPublic ? ['verify'] : ['sign'];\n            break;\n        case 'ES384':\n            algorithm = { name: 'ECDSA', namedCurve: 'P-384' };\n            keyUsages = isPublic ? ['verify'] : ['sign'];\n            break;\n        case 'ES512':\n            algorithm = { name: 'ECDSA', namedCurve: 'P-521' };\n            keyUsages = isPublic ? ['verify'] : ['sign'];\n            break;\n        case 'ECDH-ES':\n        case 'ECDH-ES+A128KW':\n        case 'ECDH-ES+A192KW':\n        case 'ECDH-ES+A256KW': {\n            const namedCurve = getNamedCurve(keyData);\n            algorithm = namedCurve.startsWith('P-') ? { name: 'ECDH', namedCurve } : { name: namedCurve };\n            keyUsages = isPublic ? [] : ['deriveBits'];\n            break;\n        }\n        case 'EdDSA':\n            algorithm = { name: getNamedCurve(keyData) };\n            keyUsages = isPublic ? ['verify'] : ['sign'];\n            break;\n        default:\n            throw new JOSENotSupported('Invalid or unsupported \"alg\" (Algorithm) value');\n    }\n    return crypto.subtle.importKey(keyFormat, keyData, algorithm, (_a = options === null || options === void 0 ? void 0 : options.extractable) !== null && _a !== void 0 ? _a : false, keyUsages);\n};\nexport const fromPKCS8 = (pem, alg, options) => {\n    return genericImport(/(?:-----(?:BEGIN|END) PRIVATE KEY-----|\\s)/g, 'pkcs8', pem, alg, options);\n};\nexport const fromSPKI = (pem, alg, options) => {\n    return genericImport(/(?:-----(?:BEGIN|END) PUBLIC KEY-----|\\s)/g, 'spki', pem, alg, options);\n};\nfunction getElement(seq) {\n    let result = [];\n    let next = 0;\n    while (next < seq.length) {\n        let nextPart = parseElement(seq.subarray(next));\n        result.push(nextPart);\n        next += nextPart.byteLength;\n    }\n    return result;\n}\nfunction parseElement(bytes) {\n    let position = 0;\n    let tag = bytes[0] & 0x1f;\n    position++;\n    if (tag === 0x1f) {\n        tag = 0;\n        while (bytes[position] >= 0x80) {\n            tag = tag * 128 + bytes[position] - 0x80;\n            position++;\n        }\n        tag = tag * 128 + bytes[position] - 0x80;\n        position++;\n    }\n    let length = 0;\n    if (bytes[position] < 0x80) {\n        length = bytes[position];\n        position++;\n    }\n    else if (length === 0x80) {\n        length = 0;\n        while (bytes[position + length] !== 0 || bytes[position + length + 1] !== 0) {\n            if (length > bytes.byteLength) {\n                throw new TypeError('invalid indefinite form length');\n            }\n            length++;\n        }\n        const byteLength = position + length + 2;\n        return {\n            byteLength,\n            contents: bytes.subarray(position, position + length),\n            raw: bytes.subarray(0, byteLength),\n        };\n    }\n    else {\n        let numberOfDigits = bytes[position] & 0x7f;\n        position++;\n        length = 0;\n        for (let i = 0; i < numberOfDigits; i++) {\n            length = length * 256 + bytes[position];\n            position++;\n        }\n    }\n    const byteLength = position + length;\n    return {\n        byteLength,\n        contents: bytes.subarray(position, byteLength),\n        raw: bytes.subarray(0, byteLength),\n    };\n}\nfunction spkiFromX509(buf) {\n    const tbsCertificate = getElement(getElement(parseElement(buf).contents)[0].contents);\n    return encodeBase64(tbsCertificate[tbsCertificate[0].raw[0] === 0xa0 ? 6 : 5].raw);\n}\nfunction getSPKI(x509) {\n    const pem = x509.replace(/(?:-----(?:BEGIN|END) CERTIFICATE-----|\\s)/g, '');\n    const raw = decodeBase64(pem);\n    return formatPEM(spkiFromX509(raw), 'PUBLIC KEY');\n}\nexport const fromX509 = (pem, alg, options) => {\n    let spki;\n    try {\n        spki = getSPKI(pem);\n    }\n    catch (cause) {\n        throw new TypeError('failed to parse the X.509 certificate', { cause });\n    }\n    return fromSPKI(spki, alg, options);\n};\n", "import crypto from './webcrypto.js';\nimport { JOSENotSupported } from '../util/errors.js';\nimport { decode as base64url } from './base64url.js';\nfunction subtleMapping(jwk) {\n    let algorithm;\n    let keyUsages;\n    switch (jwk.kty) {\n        case 'oct': {\n            switch (jwk.alg) {\n                case 'HS256':\n                case 'HS384':\n                case 'HS512':\n                    algorithm = { name: 'HMAC', hash: `SHA-${jwk.alg.slice(-3)}` };\n                    keyUsages = ['sign', 'verify'];\n                    break;\n                case 'A128CBC-HS256':\n                case 'A192CBC-HS384':\n                case 'A256CBC-HS512':\n                    throw new JOSENotSupported(`${jwk.alg} keys cannot be imported as CryptoKey instances`);\n                case 'A128GCM':\n                case 'A192GCM':\n                case 'A256GCM':\n                case 'A128GCMKW':\n                case 'A192GCMKW':\n                case 'A256GCMKW':\n                    algorithm = { name: 'AES-GCM' };\n                    keyUsages = ['encrypt', 'decrypt'];\n                    break;\n                case 'A128KW':\n                case 'A192KW':\n                case 'A256KW':\n                    algorithm = { name: 'AES-KW' };\n                    keyUsages = ['wrapKey', 'unwrapKey'];\n                    break;\n                case 'PBES2-HS256+A128KW':\n                case 'PBES2-HS384+A192KW':\n                case 'PBES2-HS512+A256KW':\n                    algorithm = { name: 'PBKDF2' };\n                    keyUsages = ['deriveBits'];\n                    break;\n                default:\n                    throw new JOSENotSupported('Invalid or unsupported JWK \"alg\" (Algorithm) Parameter value');\n            }\n            break;\n        }\n        case 'RSA': {\n            switch (jwk.alg) {\n                case 'PS256':\n                case 'PS384':\n                case 'PS512':\n                    algorithm = { name: 'RSA-PSS', hash: `SHA-${jwk.alg.slice(-3)}` };\n                    keyUsages = jwk.d ? ['sign'] : ['verify'];\n                    break;\n                case 'RS256':\n                case 'RS384':\n                case 'RS512':\n                    algorithm = { name: 'RSASSA-PKCS1-v1_5', hash: `SHA-${jwk.alg.slice(-3)}` };\n                    keyUsages = jwk.d ? ['sign'] : ['verify'];\n                    break;\n                case 'RSA-OAEP':\n                case 'RSA-OAEP-256':\n                case 'RSA-OAEP-384':\n                case 'RSA-OAEP-512':\n                    algorithm = {\n                        name: 'RSA-OAEP',\n                        hash: `SHA-${parseInt(jwk.alg.slice(-3), 10) || 1}`,\n                    };\n                    keyUsages = jwk.d ? ['decrypt', 'unwrapKey'] : ['encrypt', 'wrapKey'];\n                    break;\n                default:\n                    throw new JOSENotSupported('Invalid or unsupported JWK \"alg\" (Algorithm) Parameter value');\n            }\n            break;\n        }\n        case 'EC': {\n            switch (jwk.alg) {\n                case 'ES256':\n                    algorithm = { name: 'ECDSA', namedCurve: 'P-256' };\n                    keyUsages = jwk.d ? ['sign'] : ['verify'];\n                    break;\n                case 'ES384':\n                    algorithm = { name: 'ECDSA', namedCurve: 'P-384' };\n                    keyUsages = jwk.d ? ['sign'] : ['verify'];\n                    break;\n                case 'ES512':\n                    algorithm = { name: 'ECDSA', namedCurve: 'P-521' };\n                    keyUsages = jwk.d ? ['sign'] : ['verify'];\n                    break;\n                case 'ECDH-ES':\n                case 'ECDH-ES+A128KW':\n                case 'ECDH-ES+A192KW':\n                case 'ECDH-ES+A256KW':\n                    algorithm = { name: 'ECDH', namedCurve: jwk.crv };\n                    keyUsages = jwk.d ? ['deriveBits'] : [];\n                    break;\n                default:\n                    throw new JOSENotSupported('Invalid or unsupported JWK \"alg\" (Algorithm) Parameter value');\n            }\n            break;\n        }\n        case 'OKP': {\n            switch (jwk.alg) {\n                case 'EdDSA':\n                    algorithm = { name: jwk.crv };\n                    keyUsages = jwk.d ? ['sign'] : ['verify'];\n                    break;\n                case 'ECDH-ES':\n                case 'ECDH-ES+A128KW':\n                case 'ECDH-ES+A192KW':\n                case 'ECDH-ES+A256KW':\n                    algorithm = { name: jwk.crv };\n                    keyUsages = jwk.d ? ['deriveBits'] : [];\n                    break;\n                default:\n                    throw new JOSENotSupported('Invalid or unsupported JWK \"alg\" (Algorithm) Parameter value');\n            }\n            break;\n        }\n        default:\n            throw new JOSENotSupported('Invalid or unsupported JWK \"kty\" (Key Type) Parameter value');\n    }\n    return { algorithm, keyUsages };\n}\nconst parse = async (jwk) => {\n    var _a, _b;\n    if (!jwk.alg) {\n        throw new TypeError('\"alg\" argument is required when \"jwk.alg\" is not present');\n    }\n    const { algorithm, keyUsages } = subtleMapping(jwk);\n    const rest = [\n        algorithm,\n        (_a = jwk.ext) !== null && _a !== void 0 ? _a : false,\n        (_b = jwk.key_ops) !== null && _b !== void 0 ? _b : keyUsages,\n    ];\n    if (algorithm.name === 'PBKDF2') {\n        return crypto.subtle.importKey('raw', base64url(jwk.k), ...rest);\n    }\n    const keyData = { ...jwk };\n    delete keyData.alg;\n    delete keyData.use;\n    return crypto.subtle.importKey('jwk', keyData, ...rest);\n};\nexport default parse;\n", "import { decode as decodeBase64URL } from '../runtime/base64url.js';\nimport { fromSPKI, fromPKCS8, fromX509 } from '../runtime/asn1.js';\nimport asKeyObject from '../runtime/jwk_to_key.js';\nimport { JOSENotSupported } from '../util/errors.js';\nimport isObject from '../lib/is_object.js';\nexport async function importSPKI(spki, alg, options) {\n    if (typeof spki !== 'string' || spki.indexOf('-----BEGIN PUBLIC KEY-----') !== 0) {\n        throw new TypeError('\"spki\" must be SPKI formatted string');\n    }\n    return fromSPKI(spki, alg, options);\n}\nexport async function importX509(x509, alg, options) {\n    if (typeof x509 !== 'string' || x509.indexOf('-----BEGIN CERTIFICATE-----') !== 0) {\n        throw new TypeError('\"x509\" must be X.509 formatted string');\n    }\n    return fromX509(x509, alg, options);\n}\nexport async function importPKCS8(pkcs8, alg, options) {\n    if (typeof pkcs8 !== 'string' || pkcs8.indexOf('-----BEGIN PRIVATE KEY-----') !== 0) {\n        throw new TypeError('\"pkcs8\" must be PKCS#8 formatted string');\n    }\n    return fromPKCS8(pkcs8, alg, options);\n}\nexport async function importJWK(jwk, alg, octAsKeyObject) {\n    var _a;\n    if (!isObject(jwk)) {\n        throw new TypeError('JWK must be an object');\n    }\n    alg || (alg = jwk.alg);\n    switch (jwk.kty) {\n        case 'oct':\n            if (typeof jwk.k !== 'string' || !jwk.k) {\n                throw new TypeError('missing \"k\" (Key Value) Parameter value');\n            }\n            octAsKeyObject !== null && octAsKeyObject !== void 0 ? octAsKeyObject : (octAsKeyObject = jwk.ext !== true);\n            if (octAsKeyObject) {\n                return asKeyObject({ ...jwk, alg, ext: (_a = jwk.ext) !== null && _a !== void 0 ? _a : false });\n            }\n            return decodeBase64URL(jwk.k);\n        case 'RSA':\n            if (jwk.oth !== undefined) {\n                throw new JOSENotSupported('RSA JWK \"oth\" (Other Primes Info) Parameter value is not supported');\n            }\n        case 'EC':\n        case 'OKP':\n            return asKeyObject({ ...jwk, alg });\n        default:\n            throw new JOSENotSupported('Unsupported \"kty\" (Key Type) Parameter value');\n    }\n}\n", "import { withAlg as invalidKeyInput } from './invalid_key_input.js';\nimport isKeyLike, { types } from '../runtime/is_key_like.js';\nconst symmetricTypeCheck = (alg, key) => {\n    if (key instanceof Uint8Array)\n        return;\n    if (!isKeyLike(key)) {\n        throw new TypeError(invalidKeyInput(alg, key, ...types, 'Uint8Array'));\n    }\n    if (key.type !== 'secret') {\n        throw new TypeError(`${types.join(' or ')} instances for symmetric algorithms must be of type \"secret\"`);\n    }\n};\nconst asymmetricTypeCheck = (alg, key, usage) => {\n    if (!isKeyLike(key)) {\n        throw new TypeError(invalidKeyInput(alg, key, ...types));\n    }\n    if (key.type === 'secret') {\n        throw new TypeError(`${types.join(' or ')} instances for asymmetric algorithms must not be of type \"secret\"`);\n    }\n    if (usage === 'sign' && key.type === 'public') {\n        throw new TypeError(`${types.join(' or ')} instances for asymmetric algorithm signing must be of type \"private\"`);\n    }\n    if (usage === 'decrypt' && key.type === 'public') {\n        throw new TypeError(`${types.join(' or ')} instances for asymmetric algorithm decryption must be of type \"private\"`);\n    }\n    if (key.algorithm && usage === 'verify' && key.type === 'private') {\n        throw new TypeError(`${types.join(' or ')} instances for asymmetric algorithm verifying must be of type \"public\"`);\n    }\n    if (key.algorithm && usage === 'encrypt' && key.type === 'private') {\n        throw new TypeError(`${types.join(' or ')} instances for asymmetric algorithm encryption must be of type \"public\"`);\n    }\n};\nconst checkKeyType = (alg, key, usage) => {\n    const symmetric = alg.startsWith('HS') ||\n        alg === 'dir' ||\n        alg.startsWith('PBES2') ||\n        /^A\\d{3}(?:GCM)?KW$/.test(alg);\n    if (symmetric) {\n        symmetricTypeCheck(alg, key);\n    }\n    else {\n        asymmetricTypeCheck(alg, key, usage);\n    }\n};\nexport default checkKeyType;\n", "import { concat, uint64be } from '../lib/buffer_utils.js';\nimport checkIvLength from '../lib/check_iv_length.js';\nimport checkCekLength from './check_cek_length.js';\nimport crypto, { isCryptoKey } from './webcrypto.js';\nimport { checkEncCryptoKey } from '../lib/crypto_key.js';\nimport invalidKeyInput from '../lib/invalid_key_input.js';\nimport { JOSENotSupported } from '../util/errors.js';\nimport { types } from './is_key_like.js';\nasync function cbcEncrypt(enc, plaintext, cek, iv, aad) {\n    if (!(cek instanceof Uint8Array)) {\n        throw new TypeError(invalidKeyInput(cek, 'Uint8Array'));\n    }\n    const keySize = parseInt(enc.slice(1, 4), 10);\n    const encKey = await crypto.subtle.importKey('raw', cek.subarray(keySize >> 3), 'AES-CBC', false, ['encrypt']);\n    const macKey = await crypto.subtle.importKey('raw', cek.subarray(0, keySize >> 3), {\n        hash: `SHA-${keySize << 1}`,\n        name: 'HMAC',\n    }, false, ['sign']);\n    const ciphertext = new Uint8Array(await crypto.subtle.encrypt({\n        iv,\n        name: 'AES-CBC',\n    }, encKey, plaintext));\n    const macData = concat(aad, iv, ciphertext, uint64be(aad.length << 3));\n    const tag = new Uint8Array((await crypto.subtle.sign('HMAC', macKey, macData)).slice(0, keySize >> 3));\n    return { ciphertext, tag };\n}\nasync function gcmEncrypt(enc, plaintext, cek, iv, aad) {\n    let encKey;\n    if (cek instanceof Uint8Array) {\n        encKey = await crypto.subtle.importKey('raw', cek, 'AES-GCM', false, ['encrypt']);\n    }\n    else {\n        checkEncCryptoKey(cek, enc, 'encrypt');\n        encKey = cek;\n    }\n    const encrypted = new Uint8Array(await crypto.subtle.encrypt({\n        additionalData: aad,\n        iv,\n        name: 'AES-GCM',\n        tagLength: 128,\n    }, encKey, plaintext));\n    const tag = encrypted.slice(-16);\n    const ciphertext = encrypted.slice(0, -16);\n    return { ciphertext, tag };\n}\nconst encrypt = async (enc, plaintext, cek, iv, aad) => {\n    if (!isCryptoKey(cek) && !(cek instanceof Uint8Array)) {\n        throw new TypeError(invalidKeyInput(cek, ...types, 'Uint8Array'));\n    }\n    checkIvLength(enc, iv);\n    switch (enc) {\n        case 'A128CBC-HS256':\n        case 'A192CBC-HS384':\n        case 'A256CBC-HS512':\n            if (cek instanceof Uint8Array)\n                checkCekLength(cek, parseInt(enc.slice(-3), 10));\n            return cbcEncrypt(enc, plaintext, cek, iv, aad);\n        case 'A128GCM':\n        case 'A192GCM':\n        case 'A256GCM':\n            if (cek instanceof Uint8Array)\n                checkCekLength(cek, parseInt(enc.slice(1, 4), 10));\n            return gcmEncrypt(enc, plaintext, cek, iv, aad);\n        default:\n            throw new JOSENotSupported('Unsupported JWE Content Encryption Algorithm');\n    }\n};\nexport default encrypt;\n", "import encrypt from '../runtime/encrypt.js';\nimport decrypt from '../runtime/decrypt.js';\nimport generateIv from './iv.js';\nimport { encode as base64url } from '../runtime/base64url.js';\nexport async function wrap(alg, key, cek, iv) {\n    const jweAlgorithm = alg.slice(0, 7);\n    iv || (iv = generateIv(jweAlgorithm));\n    const { ciphertext: encryptedKey, tag } = await encrypt(jweAlgorithm, cek, key, iv, new Uint8Array(0));\n    return { encryptedKey, iv: base64url(iv), tag: base64url(tag) };\n}\nexport async function unwrap(alg, key, encryptedKey, iv, tag) {\n    const jweAlgorithm = alg.slice(0, 7);\n    return decrypt(jweAlgorithm, key, encryptedKey, iv, tag, new Uint8Array(0));\n}\n", "import { unwrap as aesKw } from '../runtime/aeskw.js';\nimport * as ECDH from '../runtime/ecdhes.js';\nimport { decrypt as pbes2Kw } from '../runtime/pbes2kw.js';\nimport { decrypt as rsaEs } from '../runtime/rsaes.js';\nimport { decode as base64url } from '../runtime/base64url.js';\nimport { JOSENotSupported, JWEInvalid } from '../util/errors.js';\nimport { bitLength as cekLength } from '../lib/cek.js';\nimport { importJWK } from '../key/import.js';\nimport checkKeyType from './check_key_type.js';\nimport isObject from './is_object.js';\nimport { unwrap as aesGcmKw } from './aesgcmkw.js';\nasync function decryptKeyManagement(alg, key, encryptedKey, joseHeader, options) {\n    checkKeyType(alg, key, 'decrypt');\n    switch (alg) {\n        case 'dir': {\n            if (encryptedKey !== undefined)\n                throw new JWEInvalid('Encountered unexpected JWE Encrypted Key');\n            return key;\n        }\n        case 'ECDH-ES':\n            if (encryptedKey !== undefined)\n                throw new JWEInvalid('Encountered unexpected JWE Encrypted Key');\n        case 'ECDH-ES+A128KW':\n        case 'ECDH-ES+A192KW':\n        case 'ECDH-ES+A256KW': {\n            if (!isObject(joseHeader.epk))\n                throw new JWEInvalid(`JOSE Header \"epk\" (Ephemeral Public Key) missing or invalid`);\n            if (!ECDH.ecdhAllowed(key))\n                throw new JOSENotSupported('ECDH with the provided key is not allowed or not supported by your javascript runtime');\n            const epk = await importJWK(joseHeader.epk, alg);\n            let partyUInfo;\n            let partyVInfo;\n            if (joseHeader.apu !== undefined) {\n                if (typeof joseHeader.apu !== 'string')\n                    throw new JWEInvalid(`JOSE Header \"apu\" (Agreement PartyUInfo) invalid`);\n                partyUInfo = base64url(joseHeader.apu);\n            }\n            if (joseHeader.apv !== undefined) {\n                if (typeof joseHeader.apv !== 'string')\n                    throw new JWEInvalid(`JOSE Header \"apv\" (Agreement PartyVInfo) invalid`);\n                partyVInfo = base64url(joseHeader.apv);\n            }\n            const sharedSecret = await ECDH.deriveKey(epk, key, alg === 'ECDH-ES' ? joseHeader.enc : alg, alg === 'ECDH-ES' ? cekLength(joseHeader.enc) : parseInt(alg.slice(-5, -2), 10), partyUInfo, partyVInfo);\n            if (alg === 'ECDH-ES')\n                return sharedSecret;\n            if (encryptedKey === undefined)\n                throw new JWEInvalid('JWE Encrypted Key missing');\n            return aesKw(alg.slice(-6), sharedSecret, encryptedKey);\n        }\n        case 'RSA1_5':\n        case 'RSA-OAEP':\n        case 'RSA-OAEP-256':\n        case 'RSA-OAEP-384':\n        case 'RSA-OAEP-512': {\n            if (encryptedKey === undefined)\n                throw new JWEInvalid('JWE Encrypted Key missing');\n            return rsaEs(alg, key, encryptedKey);\n        }\n        case 'PBES2-HS256+A128KW':\n        case 'PBES2-HS384+A192KW':\n        case 'PBES2-HS512+A256KW': {\n            if (encryptedKey === undefined)\n                throw new JWEInvalid('JWE Encrypted Key missing');\n            if (typeof joseHeader.p2c !== 'number')\n                throw new JWEInvalid(`JOSE Header \"p2c\" (PBES2 Count) missing or invalid`);\n            const p2cLimit = (options === null || options === void 0 ? void 0 : options.maxPBES2Count) || 10000;\n            if (joseHeader.p2c > p2cLimit)\n                throw new JWEInvalid(`JOSE Header \"p2c\" (PBES2 Count) out is of acceptable bounds`);\n            if (typeof joseHeader.p2s !== 'string')\n                throw new JWEInvalid(`JOSE Header \"p2s\" (PBES2 Salt) missing or invalid`);\n            return pbes2Kw(alg, key, encryptedKey, joseHeader.p2c, base64url(joseHeader.p2s));\n        }\n        case 'A128KW':\n        case 'A192KW':\n        case 'A256KW': {\n            if (encryptedKey === undefined)\n                throw new JWEInvalid('JWE Encrypted Key missing');\n            return aesKw(alg, key, encryptedKey);\n        }\n        case 'A128GCMKW':\n        case 'A192GCMKW':\n        case 'A256GCMKW': {\n            if (encryptedKey === undefined)\n                throw new JWEInvalid('JWE Encrypted Key missing');\n            if (typeof joseHeader.iv !== 'string')\n                throw new JWEInvalid(`JOSE Header \"iv\" (Initialization Vector) missing or invalid`);\n            if (typeof joseHeader.tag !== 'string')\n                throw new JWEInvalid(`JOSE Header \"tag\" (Authentication Tag) missing or invalid`);\n            const iv = base64url(joseHeader.iv);\n            const tag = base64url(joseHeader.tag);\n            return aesGcmKw(alg, key, encryptedKey, iv, tag);\n        }\n        default: {\n            throw new JOSENotSupported('Invalid or unsupported \"alg\" (JWE Algorithm) header value');\n        }\n    }\n}\nexport default decryptKeyManagement;\n", "import { JOSENotSupported } from '../util/errors.js';\nfunction validateCrit(Err, recognizedDefault, recognizedOption, protectedHeader, joseHeader) {\n    if (joseHeader.crit !== undefined && protectedHeader.crit === undefined) {\n        throw new Err('\"crit\" (Critical) Header Parameter MUST be integrity protected');\n    }\n    if (!protectedHeader || protectedHeader.crit === undefined) {\n        return new Set();\n    }\n    if (!Array.isArray(protectedHeader.crit) ||\n        protectedHeader.crit.length === 0 ||\n        protectedHeader.crit.some((input) => typeof input !== 'string' || input.length === 0)) {\n        throw new Err('\"crit\" (Critical) Header Parameter MUST be an array of non-empty strings when present');\n    }\n    let recognized;\n    if (recognizedOption !== undefined) {\n        recognized = new Map([...Object.entries(recognizedOption), ...recognizedDefault.entries()]);\n    }\n    else {\n        recognized = recognizedDefault;\n    }\n    for (const parameter of protectedHeader.crit) {\n        if (!recognized.has(parameter)) {\n            throw new JOSENotSupported(`Extension Header Parameter \"${parameter}\" is not recognized`);\n        }\n        if (joseHeader[parameter] === undefined) {\n            throw new Err(`Extension Header Parameter \"${parameter}\" is missing`);\n        }\n        else if (recognized.get(parameter) && protectedHeader[parameter] === undefined) {\n            throw new Err(`Extension Header Parameter \"${parameter}\" MUST be integrity protected`);\n        }\n    }\n    return new Set(protectedHeader.crit);\n}\nexport default validateCrit;\n", "const validateAlgorithms = (option, algorithms) => {\n    if (algorithms !== undefined &&\n        (!Array.isArray(algorithms) || algorithms.some((s) => typeof s !== 'string'))) {\n        throw new TypeError(`\"${option}\" option must be an array of strings`);\n    }\n    if (!algorithms) {\n        return undefined;\n    }\n    return new Set(algorithms);\n};\nexport default validateAlgorithms;\n", "import { decode as base64url } from '../../runtime/base64url.js';\nimport decrypt from '../../runtime/decrypt.js';\nimport { inflate } from '../../runtime/zlib.js';\nimport { JOSEAlgNotAllowed, JOSENotSupported, JWEInvalid } from '../../util/errors.js';\nimport isDisjoint from '../../lib/is_disjoint.js';\nimport isObject from '../../lib/is_object.js';\nimport decryptKeyManagement from '../../lib/decrypt_key_management.js';\nimport { encoder, decoder, concat } from '../../lib/buffer_utils.js';\nimport generateCek from '../../lib/cek.js';\nimport validateCrit from '../../lib/validate_crit.js';\nimport validateAlgorithms from '../../lib/validate_algorithms.js';\nexport async function flattenedDecrypt(jwe, key, options) {\n    var _a;\n    if (!isObject(jwe)) {\n        throw new JWEInvalid('Flattened JWE must be an object');\n    }\n    if (jwe.protected === undefined && jwe.header === undefined && jwe.unprotected === undefined) {\n        throw new JWEInvalid('JOSE Header missing');\n    }\n    if (typeof jwe.iv !== 'string') {\n        throw new JWEInvalid('JWE Initialization Vector missing or incorrect type');\n    }\n    if (typeof jwe.ciphertext !== 'string') {\n        throw new JWEInvalid('JWE Ciphertext missing or incorrect type');\n    }\n    if (typeof jwe.tag !== 'string') {\n        throw new JWEInvalid('JWE Authentication Tag missing or incorrect type');\n    }\n    if (jwe.protected !== undefined && typeof jwe.protected !== 'string') {\n        throw new JWEInvalid('JWE Protected Header incorrect type');\n    }\n    if (jwe.encrypted_key !== undefined && typeof jwe.encrypted_key !== 'string') {\n        throw new JWEInvalid('JWE Encrypted Key incorrect type');\n    }\n    if (jwe.aad !== undefined && typeof jwe.aad !== 'string') {\n        throw new JWEInvalid('JWE AAD incorrect type');\n    }\n    if (jwe.header !== undefined && !isObject(jwe.header)) {\n        throw new JWEInvalid('JWE Shared Unprotected Header incorrect type');\n    }\n    if (jwe.unprotected !== undefined && !isObject(jwe.unprotected)) {\n        throw new JWEInvalid('JWE Per-Recipient Unprotected Header incorrect type');\n    }\n    let parsedProt;\n    if (jwe.protected) {\n        try {\n            const protectedHeader = base64url(jwe.protected);\n            parsedProt = JSON.parse(decoder.decode(protectedHeader));\n        }\n        catch (_b) {\n            throw new JWEInvalid('JWE Protected Header is invalid');\n        }\n    }\n    if (!isDisjoint(parsedProt, jwe.header, jwe.unprotected)) {\n        throw new JWEInvalid('JWE Protected, JWE Unprotected Header, and JWE Per-Recipient Unprotected Header Parameter names must be disjoint');\n    }\n    const joseHeader = {\n        ...parsedProt,\n        ...jwe.header,\n        ...jwe.unprotected,\n    };\n    validateCrit(JWEInvalid, new Map(), options === null || options === void 0 ? void 0 : options.crit, parsedProt, joseHeader);\n    if (joseHeader.zip !== undefined) {\n        if (!parsedProt || !parsedProt.zip) {\n            throw new JWEInvalid('JWE \"zip\" (Compression Algorithm) Header MUST be integrity protected');\n        }\n        if (joseHeader.zip !== 'DEF') {\n            throw new JOSENotSupported('Unsupported JWE \"zip\" (Compression Algorithm) Header Parameter value');\n        }\n    }\n    const { alg, enc } = joseHeader;\n    if (typeof alg !== 'string' || !alg) {\n        throw new JWEInvalid('missing JWE Algorithm (alg) in JWE Header');\n    }\n    if (typeof enc !== 'string' || !enc) {\n        throw new JWEInvalid('missing JWE Encryption Algorithm (enc) in JWE Header');\n    }\n    const keyManagementAlgorithms = options && validateAlgorithms('keyManagementAlgorithms', options.keyManagementAlgorithms);\n    const contentEncryptionAlgorithms = options &&\n        validateAlgorithms('contentEncryptionAlgorithms', options.contentEncryptionAlgorithms);\n    if (keyManagementAlgorithms && !keyManagementAlgorithms.has(alg)) {\n        throw new JOSEAlgNotAllowed('\"alg\" (Algorithm) Header Parameter not allowed');\n    }\n    if (contentEncryptionAlgorithms && !contentEncryptionAlgorithms.has(enc)) {\n        throw new JOSEAlgNotAllowed('\"enc\" (Encryption Algorithm) Header Parameter not allowed');\n    }\n    let encryptedKey;\n    if (jwe.encrypted_key !== undefined) {\n        encryptedKey = base64url(jwe.encrypted_key);\n    }\n    let resolvedKey = false;\n    if (typeof key === 'function') {\n        key = await key(parsedProt, jwe);\n        resolvedKey = true;\n    }\n    let cek;\n    try {\n        cek = await decryptKeyManagement(alg, key, encryptedKey, joseHeader, options);\n    }\n    catch (err) {\n        if (err instanceof TypeError || err instanceof JWEInvalid || err instanceof JOSENotSupported) {\n            throw err;\n        }\n        cek = generateCek(enc);\n    }\n    const iv = base64url(jwe.iv);\n    const tag = base64url(jwe.tag);\n    const protectedHeader = encoder.encode((_a = jwe.protected) !== null && _a !== void 0 ? _a : '');\n    let additionalData;\n    if (jwe.aad !== undefined) {\n        additionalData = concat(protectedHeader, encoder.encode('.'), encoder.encode(jwe.aad));\n    }\n    else {\n        additionalData = protectedHeader;\n    }\n    let plaintext = await decrypt(enc, cek, base64url(jwe.ciphertext), iv, tag, additionalData);\n    if (joseHeader.zip === 'DEF') {\n        plaintext = await ((options === null || options === void 0 ? void 0 : options.inflateRaw) || inflate)(plaintext);\n    }\n    const result = { plaintext };\n    if (jwe.protected !== undefined) {\n        result.protectedHeader = parsedProt;\n    }\n    if (jwe.aad !== undefined) {\n        result.additionalAuthenticatedData = base64url(jwe.aad);\n    }\n    if (jwe.unprotected !== undefined) {\n        result.sharedUnprotectedHeader = jwe.unprotected;\n    }\n    if (jwe.header !== undefined) {\n        result.unprotectedHeader = jwe.header;\n    }\n    if (resolvedKey) {\n        return { ...result, key };\n    }\n    return result;\n}\n", "import { flattenedDecrypt } from '../flattened/decrypt.js';\nimport { JWEInvalid } from '../../util/errors.js';\nimport { decoder } from '../../lib/buffer_utils.js';\nexport async function compactDecrypt(jwe, key, options) {\n    if (jwe instanceof Uint8Array) {\n        jwe = decoder.decode(jwe);\n    }\n    if (typeof jwe !== 'string') {\n        throw new JWEInvalid('Compact JWE must be a string or Uint8Array');\n    }\n    const { 0: protectedHeader, 1: encryptedKey, 2: iv, 3: ciphertext, 4: tag, length, } = jwe.split('.');\n    if (length !== 5) {\n        throw new JWEInvalid('Invalid Compact JWE');\n    }\n    const decrypted = await flattenedDecrypt({\n        ciphertext,\n        iv: (iv || undefined),\n        protected: protectedHeader || undefined,\n        tag: (tag || undefined),\n        encrypted_key: encryptedKey || undefined,\n    }, key, options);\n    const result = { plaintext: decrypted.plaintext, protectedHeader: decrypted.protectedHeader };\n    if (typeof key === 'function') {\n        return { ...result, key: decrypted.key };\n    }\n    return result;\n}\n", "import { flattenedDecrypt } from '../flattened/decrypt.js';\nimport { JWEDecryptionFailed, JWEInvalid } from '../../util/errors.js';\nimport isObject from '../../lib/is_object.js';\nexport async function generalDecrypt(jwe, key, options) {\n    if (!isObject(jwe)) {\n        throw new JWEInvalid('General JWE must be an object');\n    }\n    if (!Array.isArray(jwe.recipients) || !jwe.recipients.every(isObject)) {\n        throw new JWEInvalid('JWE Recipients missing or incorrect type');\n    }\n    if (!jwe.recipients.length) {\n        throw new JWEInvalid('JWE Recipients has no members');\n    }\n    for (const recipient of jwe.recipients) {\n        try {\n            return await flattenedDecrypt({\n                aad: jwe.aad,\n                ciphertext: jwe.ciphertext,\n                encrypted_key: recipient.encrypted_key,\n                header: recipient.header,\n                iv: jwe.iv,\n                protected: jwe.protected,\n                tag: jwe.tag,\n                unprotected: jwe.unprotected,\n            }, key, options);\n        }\n        catch (_a) {\n        }\n    }\n    throw new JWEDecryptionFailed();\n}\n", "import crypto, { isCryptoKey } from './webcrypto.js';\nimport invalidKeyInput from '../lib/invalid_key_input.js';\nimport { encode as base64url } from './base64url.js';\nimport { types } from './is_key_like.js';\nconst keyToJWK = async (key) => {\n    if (key instanceof Uint8Array) {\n        return {\n            kty: 'oct',\n            k: base64url(key),\n        };\n    }\n    if (!isCryptoKey(key)) {\n        throw new TypeError(invalidKeyInput(key, ...types, 'Uint8Array'));\n    }\n    if (!key.extractable) {\n        throw new TypeError('non-extractable CryptoKey cannot be exported as a JWK');\n    }\n    const { ext, key_ops, alg, use, ...jwk } = await crypto.subtle.exportKey('jwk', key);\n    return jwk;\n};\nexport default keyToJWK;\n", "import { toSPKI as exportPublic } from '../runtime/asn1.js';\nimport { toPKCS8 as exportPrivate } from '../runtime/asn1.js';\nimport keyToJWK from '../runtime/key_to_jwk.js';\nexport async function exportSPKI(key) {\n    return exportPublic(key);\n}\nexport async function exportPKCS8(key) {\n    return exportPrivate(key);\n}\nexport async function exportJWK(key) {\n    return keyToJWK(key);\n}\n", "import { wrap as aesKw } from '../runtime/aeskw.js';\nimport * as ECDH from '../runtime/ecdhes.js';\nimport { encrypt as pbes2Kw } from '../runtime/pbes2kw.js';\nimport { encrypt as rsaEs } from '../runtime/rsaes.js';\nimport { encode as base64url } from '../runtime/base64url.js';\nimport generateCek, { bitLength as cekLength } from '../lib/cek.js';\nimport { JOSENotSupported } from '../util/errors.js';\nimport { exportJWK } from '../key/export.js';\nimport checkKeyType from './check_key_type.js';\nimport { wrap as aesGcmKw } from './aesgcmkw.js';\nasync function encryptKeyManagement(alg, enc, key, providedCek, providedParameters = {}) {\n    let encryptedKey;\n    let parameters;\n    let cek;\n    checkKeyType(alg, key, 'encrypt');\n    switch (alg) {\n        case 'dir': {\n            cek = key;\n            break;\n        }\n        case 'ECDH-ES':\n        case 'ECDH-ES+A128KW':\n        case 'ECDH-ES+A192KW':\n        case 'ECDH-ES+A256KW': {\n            if (!ECDH.ecdhAllowed(key)) {\n                throw new JOSENotSupported('ECDH with the provided key is not allowed or not supported by your javascript runtime');\n            }\n            const { apu, apv } = providedParameters;\n            let { epk: ephemeralKey } = providedParameters;\n            ephemeralKey || (ephemeralKey = (await ECDH.generateEpk(key)).privateKey);\n            const { x, y, crv, kty } = await exportJWK(ephemeralKey);\n            const sharedSecret = await ECDH.deriveKey(key, ephemeralKey, alg === 'ECDH-ES' ? enc : alg, alg === 'ECDH-ES' ? cekLength(enc) : parseInt(alg.slice(-5, -2), 10), apu, apv);\n            parameters = { epk: { x, crv, kty } };\n            if (kty === 'EC')\n                parameters.epk.y = y;\n            if (apu)\n                parameters.apu = base64url(apu);\n            if (apv)\n                parameters.apv = base64url(apv);\n            if (alg === 'ECDH-ES') {\n                cek = sharedSecret;\n                break;\n            }\n            cek = providedCek || generateCek(enc);\n            const kwAlg = alg.slice(-6);\n            encryptedKey = await aesKw(kwAlg, sharedSecret, cek);\n            break;\n        }\n        case 'RSA1_5':\n        case 'RSA-OAEP':\n        case 'RSA-OAEP-256':\n        case 'RSA-OAEP-384':\n        case 'RSA-OAEP-512': {\n            cek = providedCek || generateCek(enc);\n            encryptedKey = await rsaEs(alg, key, cek);\n            break;\n        }\n        case 'PBES2-HS256+A128KW':\n        case 'PBES2-HS384+A192KW':\n        case 'PBES2-HS512+A256KW': {\n            cek = providedCek || generateCek(enc);\n            const { p2c, p2s } = providedParameters;\n            ({ encryptedKey, ...parameters } = await pbes2Kw(alg, key, cek, p2c, p2s));\n            break;\n        }\n        case 'A128KW':\n        case 'A192KW':\n        case 'A256KW': {\n            cek = providedCek || generateCek(enc);\n            encryptedKey = await aesKw(alg, key, cek);\n            break;\n        }\n        case 'A128GCMKW':\n        case 'A192GCMKW':\n        case 'A256GCMKW': {\n            cek = providedCek || generateCek(enc);\n            const { iv } = providedParameters;\n            ({ encryptedKey, ...parameters } = await aesGcmKw(alg, key, cek, iv));\n            break;\n        }\n        default: {\n            throw new JOSENotSupported('Invalid or unsupported \"alg\" (JWE Algorithm) header value');\n        }\n    }\n    return { cek, encryptedKey, parameters };\n}\nexport default encryptKeyManagement;\n", "import { encode as base64url } from '../../runtime/base64url.js';\nimport encrypt from '../../runtime/encrypt.js';\nimport { deflate } from '../../runtime/zlib.js';\nimport generateIv from '../../lib/iv.js';\nimport encryptKeyManagement from '../../lib/encrypt_key_management.js';\nimport { JOSENotSupported, JWEInvalid } from '../../util/errors.js';\nimport isDisjoint from '../../lib/is_disjoint.js';\nimport { encoder, decoder, concat } from '../../lib/buffer_utils.js';\nimport validateCrit from '../../lib/validate_crit.js';\nexport const unprotected = Symbol();\nexport class FlattenedEncrypt {\n    constructor(plaintext) {\n        if (!(plaintext instanceof Uint8Array)) {\n            throw new TypeError('plaintext must be an instance of Uint8Array');\n        }\n        this._plaintext = plaintext;\n    }\n    setKeyManagementParameters(parameters) {\n        if (this._keyManagementParameters) {\n            throw new TypeError('setKeyManagementParameters can only be called once');\n        }\n        this._keyManagementParameters = parameters;\n        return this;\n    }\n    setProtectedHeader(protectedHeader) {\n        if (this._protectedHeader) {\n            throw new TypeError('setProtectedHeader can only be called once');\n        }\n        this._protectedHeader = protectedHeader;\n        return this;\n    }\n    setSharedUnprotectedHeader(sharedUnprotectedHeader) {\n        if (this._sharedUnprotectedHeader) {\n            throw new TypeError('setSharedUnprotectedHeader can only be called once');\n        }\n        this._sharedUnprotectedHeader = sharedUnprotectedHeader;\n        return this;\n    }\n    setUnprotectedHeader(unprotectedHeader) {\n        if (this._unprotectedHeader) {\n            throw new TypeError('setUnprotectedHeader can only be called once');\n        }\n        this._unprotectedHeader = unprotectedHeader;\n        return this;\n    }\n    setAdditionalAuthenticatedData(aad) {\n        this._aad = aad;\n        return this;\n    }\n    setContentEncryptionKey(cek) {\n        if (this._cek) {\n            throw new TypeError('setContentEncryptionKey can only be called once');\n        }\n        this._cek = cek;\n        return this;\n    }\n    setInitializationVector(iv) {\n        if (this._iv) {\n            throw new TypeError('setInitializationVector can only be called once');\n        }\n        this._iv = iv;\n        return this;\n    }\n    async encrypt(key, options) {\n        if (!this._protectedHeader && !this._unprotectedHeader && !this._sharedUnprotectedHeader) {\n            throw new JWEInvalid('either setProtectedHeader, setUnprotectedHeader, or sharedUnprotectedHeader must be called before #encrypt()');\n        }\n        if (!isDisjoint(this._protectedHeader, this._unprotectedHeader, this._sharedUnprotectedHeader)) {\n            throw new JWEInvalid('JWE Protected, JWE Shared Unprotected and JWE Per-Recipient Header Parameter names must be disjoint');\n        }\n        const joseHeader = {\n            ...this._protectedHeader,\n            ...this._unprotectedHeader,\n            ...this._sharedUnprotectedHeader,\n        };\n        validateCrit(JWEInvalid, new Map(), options === null || options === void 0 ? void 0 : options.crit, this._protectedHeader, joseHeader);\n        if (joseHeader.zip !== undefined) {\n            if (!this._protectedHeader || !this._protectedHeader.zip) {\n                throw new JWEInvalid('JWE \"zip\" (Compression Algorithm) Header MUST be integrity protected');\n            }\n            if (joseHeader.zip !== 'DEF') {\n                throw new JOSENotSupported('Unsupported JWE \"zip\" (Compression Algorithm) Header Parameter value');\n            }\n        }\n        const { alg, enc } = joseHeader;\n        if (typeof alg !== 'string' || !alg) {\n            throw new JWEInvalid('JWE \"alg\" (Algorithm) Header Parameter missing or invalid');\n        }\n        if (typeof enc !== 'string' || !enc) {\n            throw new JWEInvalid('JWE \"enc\" (Encryption Algorithm) Header Parameter missing or invalid');\n        }\n        let encryptedKey;\n        if (alg === 'dir') {\n            if (this._cek) {\n                throw new TypeError('setContentEncryptionKey cannot be called when using Direct Encryption');\n            }\n        }\n        else if (alg === 'ECDH-ES') {\n            if (this._cek) {\n                throw new TypeError('setContentEncryptionKey cannot be called when using Direct Key Agreement');\n            }\n        }\n        let cek;\n        {\n            let parameters;\n            ({ cek, encryptedKey, parameters } = await encryptKeyManagement(alg, enc, key, this._cek, this._keyManagementParameters));\n            if (parameters) {\n                if (options && unprotected in options) {\n                    if (!this._unprotectedHeader) {\n                        this.setUnprotectedHeader(parameters);\n                    }\n                    else {\n                        this._unprotectedHeader = { ...this._unprotectedHeader, ...parameters };\n                    }\n                }\n                else {\n                    if (!this._protectedHeader) {\n                        this.setProtectedHeader(parameters);\n                    }\n                    else {\n                        this._protectedHeader = { ...this._protectedHeader, ...parameters };\n                    }\n                }\n            }\n        }\n        this._iv || (this._iv = generateIv(enc));\n        let additionalData;\n        let protectedHeader;\n        let aadMember;\n        if (this._protectedHeader) {\n            protectedHeader = encoder.encode(base64url(JSON.stringify(this._protectedHeader)));\n        }\n        else {\n            protectedHeader = encoder.encode('');\n        }\n        if (this._aad) {\n            aadMember = base64url(this._aad);\n            additionalData = concat(protectedHeader, encoder.encode('.'), encoder.encode(aadMember));\n        }\n        else {\n            additionalData = protectedHeader;\n        }\n        let ciphertext;\n        let tag;\n        if (joseHeader.zip === 'DEF') {\n            const deflated = await ((options === null || options === void 0 ? void 0 : options.deflateRaw) || deflate)(this._plaintext);\n            ({ ciphertext, tag } = await encrypt(enc, deflated, cek, this._iv, additionalData));\n        }\n        else {\n            ;\n            ({ ciphertext, tag } = await encrypt(enc, this._plaintext, cek, this._iv, additionalData));\n        }\n        const jwe = {\n            ciphertext: base64url(ciphertext),\n            iv: base64url(this._iv),\n            tag: base64url(tag),\n        };\n        if (encryptedKey) {\n            jwe.encrypted_key = base64url(encryptedKey);\n        }\n        if (aadMember) {\n            jwe.aad = aadMember;\n        }\n        if (this._protectedHeader) {\n            jwe.protected = decoder.decode(protectedHeader);\n        }\n        if (this._sharedUnprotectedHeader) {\n            jwe.unprotected = this._sharedUnprotectedHeader;\n        }\n        if (this._unprotectedHeader) {\n            jwe.header = this._unprotectedHeader;\n        }\n        return jwe;\n    }\n}\n", "import { FlattenedEncrypt, unprotected } from '../flattened/encrypt.js';\nimport { JWEInvalid } from '../../util/errors.js';\nimport generateCek from '../../lib/cek.js';\nimport isDisjoint from '../../lib/is_disjoint.js';\nimport encryptKeyManagement from '../../lib/encrypt_key_management.js';\nimport { encode as base64url } from '../../runtime/base64url.js';\nimport validateCrit from '../../lib/validate_crit.js';\nclass IndividualRecipient {\n    constructor(enc, key, options) {\n        this.parent = enc;\n        this.key = key;\n        this.options = options;\n    }\n    setUnprotectedHeader(unprotectedHeader) {\n        if (this.unprotectedHeader) {\n            throw new TypeError('setUnprotectedHeader can only be called once');\n        }\n        this.unprotectedHeader = unprotectedHeader;\n        return this;\n    }\n    addRecipient(...args) {\n        return this.parent.addRecipient(...args);\n    }\n    encrypt(...args) {\n        return this.parent.encrypt(...args);\n    }\n    done() {\n        return this.parent;\n    }\n}\nexport class GeneralEncrypt {\n    constructor(plaintext) {\n        this._recipients = [];\n        this._plaintext = plaintext;\n    }\n    addRecipient(key, options) {\n        const recipient = new IndividualRecipient(this, key, { crit: options === null || options === void 0 ? void 0 : options.crit });\n        this._recipients.push(recipient);\n        return recipient;\n    }\n    setProtectedHeader(protectedHeader) {\n        if (this._protectedHeader) {\n            throw new TypeError('setProtectedHeader can only be called once');\n        }\n        this._protectedHeader = protectedHeader;\n        return this;\n    }\n    setSharedUnprotectedHeader(sharedUnprotectedHeader) {\n        if (this._unprotectedHeader) {\n            throw new TypeError('setSharedUnprotectedHeader can only be called once');\n        }\n        this._unprotectedHeader = sharedUnprotectedHeader;\n        return this;\n    }\n    setAdditionalAuthenticatedData(aad) {\n        this._aad = aad;\n        return this;\n    }\n    async encrypt(options) {\n        var _a, _b, _c;\n        if (!this._recipients.length) {\n            throw new JWEInvalid('at least one recipient must be added');\n        }\n        options = { deflateRaw: options === null || options === void 0 ? void 0 : options.deflateRaw };\n        if (this._recipients.length === 1) {\n            const [recipient] = this._recipients;\n            const flattened = await new FlattenedEncrypt(this._plaintext)\n                .setAdditionalAuthenticatedData(this._aad)\n                .setProtectedHeader(this._protectedHeader)\n                .setSharedUnprotectedHeader(this._unprotectedHeader)\n                .setUnprotectedHeader(recipient.unprotectedHeader)\n                .encrypt(recipient.key, { ...recipient.options, ...options });\n            let jwe = {\n                ciphertext: flattened.ciphertext,\n                iv: flattened.iv,\n                recipients: [{}],\n                tag: flattened.tag,\n            };\n            if (flattened.aad)\n                jwe.aad = flattened.aad;\n            if (flattened.protected)\n                jwe.protected = flattened.protected;\n            if (flattened.unprotected)\n                jwe.unprotected = flattened.unprotected;\n            if (flattened.encrypted_key)\n                jwe.recipients[0].encrypted_key = flattened.encrypted_key;\n            if (flattened.header)\n                jwe.recipients[0].header = flattened.header;\n            return jwe;\n        }\n        let enc;\n        for (let i = 0; i < this._recipients.length; i++) {\n            const recipient = this._recipients[i];\n            if (!isDisjoint(this._protectedHeader, this._unprotectedHeader, recipient.unprotectedHeader)) {\n                throw new JWEInvalid('JWE Protected, JWE Shared Unprotected and JWE Per-Recipient Header Parameter names must be disjoint');\n            }\n            const joseHeader = {\n                ...this._protectedHeader,\n                ...this._unprotectedHeader,\n                ...recipient.unprotectedHeader,\n            };\n            const { alg } = joseHeader;\n            if (typeof alg !== 'string' || !alg) {\n                throw new JWEInvalid('JWE \"alg\" (Algorithm) Header Parameter missing or invalid');\n            }\n            if (alg === 'dir' || alg === 'ECDH-ES') {\n                throw new JWEInvalid('\"dir\" and \"ECDH-ES\" alg may only be used with a single recipient');\n            }\n            if (typeof joseHeader.enc !== 'string' || !joseHeader.enc) {\n                throw new JWEInvalid('JWE \"enc\" (Encryption Algorithm) Header Parameter missing or invalid');\n            }\n            if (!enc) {\n                enc = joseHeader.enc;\n            }\n            else if (enc !== joseHeader.enc) {\n                throw new JWEInvalid('JWE \"enc\" (Encryption Algorithm) Header Parameter must be the same for all recipients');\n            }\n            validateCrit(JWEInvalid, new Map(), recipient.options.crit, this._protectedHeader, joseHeader);\n            if (joseHeader.zip !== undefined) {\n                if (!this._protectedHeader || !this._protectedHeader.zip) {\n                    throw new JWEInvalid('JWE \"zip\" (Compression Algorithm) Header MUST be integrity protected');\n                }\n            }\n        }\n        const cek = generateCek(enc);\n        let jwe = {\n            ciphertext: '',\n            iv: '',\n            recipients: [],\n            tag: '',\n        };\n        for (let i = 0; i < this._recipients.length; i++) {\n            const recipient = this._recipients[i];\n            const target = {};\n            jwe.recipients.push(target);\n            const joseHeader = {\n                ...this._protectedHeader,\n                ...this._unprotectedHeader,\n                ...recipient.unprotectedHeader,\n            };\n            const p2c = joseHeader.alg.startsWith('PBES2') ? 2048 + i : undefined;\n            if (i === 0) {\n                const flattened = await new FlattenedEncrypt(this._plaintext)\n                    .setAdditionalAuthenticatedData(this._aad)\n                    .setContentEncryptionKey(cek)\n                    .setProtectedHeader(this._protectedHeader)\n                    .setSharedUnprotectedHeader(this._unprotectedHeader)\n                    .setUnprotectedHeader(recipient.unprotectedHeader)\n                    .setKeyManagementParameters({ p2c })\n                    .encrypt(recipient.key, {\n                    ...recipient.options,\n                    ...options,\n                    [unprotected]: true,\n                });\n                jwe.ciphertext = flattened.ciphertext;\n                jwe.iv = flattened.iv;\n                jwe.tag = flattened.tag;\n                if (flattened.aad)\n                    jwe.aad = flattened.aad;\n                if (flattened.protected)\n                    jwe.protected = flattened.protected;\n                if (flattened.unprotected)\n                    jwe.unprotected = flattened.unprotected;\n                target.encrypted_key = flattened.encrypted_key;\n                if (flattened.header)\n                    target.header = flattened.header;\n                continue;\n            }\n            const { encryptedKey, parameters } = await encryptKeyManagement(((_a = recipient.unprotectedHeader) === null || _a === void 0 ? void 0 : _a.alg) ||\n                ((_b = this._protectedHeader) === null || _b === void 0 ? void 0 : _b.alg) ||\n                ((_c = this._unprotectedHeader) === null || _c === void 0 ? void 0 : _c.alg), enc, recipient.key, cek, { p2c });\n            target.encrypted_key = base64url(encryptedKey);\n            if (recipient.unprotectedHeader || parameters)\n                target.header = { ...recipient.unprotectedHeader, ...parameters };\n        }\n        return jwe;\n    }\n}\n", "import { JOSENotSupported } from '../util/errors.js';\nexport default function subtleDsa(alg, algorithm) {\n    const hash = `SHA-${alg.slice(-3)}`;\n    switch (alg) {\n        case 'HS256':\n        case 'HS384':\n        case 'HS512':\n            return { hash, name: 'HMAC' };\n        case 'PS256':\n        case 'PS384':\n        case 'PS512':\n            return { hash, name: 'RSA-PSS', saltLength: alg.slice(-3) >> 3 };\n        case 'RS256':\n        case 'RS384':\n        case 'RS512':\n            return { hash, name: 'RSASSA-PKCS1-v1_5' };\n        case 'ES256':\n        case 'ES384':\n        case 'ES512':\n            return { hash, name: 'ECDSA', namedCurve: algorithm.namedCurve };\n        case 'EdDSA':\n            return { name: algorithm.name };\n        default:\n            throw new JOSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`);\n    }\n}\n", "import crypto, { isCryptoKey } from './webcrypto.js';\nimport { checkSigCryptoKey } from '../lib/crypto_key.js';\nimport invalidKeyInput from '../lib/invalid_key_input.js';\nimport { types } from './is_key_like.js';\nexport default function getCryptoKey(alg, key, usage) {\n    if (isCryptoKey(key)) {\n        checkSigCryptoKey(key, alg, usage);\n        return key;\n    }\n    if (key instanceof Uint8Array) {\n        if (!alg.startsWith('HS')) {\n            throw new TypeError(invalidKeyInput(key, ...types));\n        }\n        return crypto.subtle.importKey('raw', key, { hash: `SHA-${alg.slice(-3)}`, name: 'HMAC' }, false, [usage]);\n    }\n    throw new TypeError(invalidKeyInput(key, ...types, 'Uint8Array'));\n}\n", "import subtleAlgorithm from './subtle_dsa.js';\nimport crypto from './webcrypto.js';\nimport checkKeyLength from './check_key_length.js';\nimport getVerifyKey from './get_sign_verify_key.js';\nconst verify = async (alg, key, signature, data) => {\n    const cryptoKey = await getVerifyKey(alg, key, 'verify');\n    checkKeyLength(alg, cryptoKey);\n    const algorithm = subtleAlgorithm(alg, cryptoKey.algorithm);\n    try {\n        return await crypto.subtle.verify(algorithm, cryptoKey, signature, data);\n    }\n    catch (_a) {\n        return false;\n    }\n};\nexport default verify;\n", "import { decode as base64url } from '../../runtime/base64url.js';\nimport verify from '../../runtime/verify.js';\nimport { JOSEAlgNotAllowed, JWSInvalid, JWSSignatureVerificationFailed } from '../../util/errors.js';\nimport { concat, encoder, decoder } from '../../lib/buffer_utils.js';\nimport isDisjoint from '../../lib/is_disjoint.js';\nimport isObject from '../../lib/is_object.js';\nimport checkKeyType from '../../lib/check_key_type.js';\nimport validateCrit from '../../lib/validate_crit.js';\nimport validateAlgorithms from '../../lib/validate_algorithms.js';\nexport async function flattenedVerify(jws, key, options) {\n    var _a;\n    if (!isObject(jws)) {\n        throw new JWSInvalid('Flattened JWS must be an object');\n    }\n    if (jws.protected === undefined && jws.header === undefined) {\n        throw new JWSInvalid('Flattened JWS must have either of the \"protected\" or \"header\" members');\n    }\n    if (jws.protected !== undefined && typeof jws.protected !== 'string') {\n        throw new JWSInvalid('JWS Protected Header incorrect type');\n    }\n    if (jws.payload === undefined) {\n        throw new JWSInvalid('JWS Payload missing');\n    }\n    if (typeof jws.signature !== 'string') {\n        throw new JWSInvalid('JWS Signature missing or incorrect type');\n    }\n    if (jws.header !== undefined && !isObject(jws.header)) {\n        throw new JWSInvalid('JWS Unprotected Header incorrect type');\n    }\n    let parsedProt = {};\n    if (jws.protected) {\n        try {\n            const protectedHeader = base64url(jws.protected);\n            parsedProt = JSON.parse(decoder.decode(protectedHeader));\n        }\n        catch (_b) {\n            throw new JWSInvalid('JWS Protected Header is invalid');\n        }\n    }\n    if (!isDisjoint(parsedProt, jws.header)) {\n        throw new JWSInvalid('JWS Protected and JWS Unprotected Header Parameter names must be disjoint');\n    }\n    const joseHeader = {\n        ...parsedProt,\n        ...jws.header,\n    };\n    const extensions = validateCrit(JWSInvalid, new Map([['b64', true]]), options === null || options === void 0 ? void 0 : options.crit, parsedProt, joseHeader);\n    let b64 = true;\n    if (extensions.has('b64')) {\n        b64 = parsedProt.b64;\n        if (typeof b64 !== 'boolean') {\n            throw new JWSInvalid('The \"b64\" (base64url-encode payload) Header Parameter must be a boolean');\n        }\n    }\n    const { alg } = joseHeader;\n    if (typeof alg !== 'string' || !alg) {\n        throw new JWSInvalid('JWS \"alg\" (Algorithm) Header Parameter missing or invalid');\n    }\n    const algorithms = options && validateAlgorithms('algorithms', options.algorithms);\n    if (algorithms && !algorithms.has(alg)) {\n        throw new JOSEAlgNotAllowed('\"alg\" (Algorithm) Header Parameter not allowed');\n    }\n    if (b64) {\n        if (typeof jws.payload !== 'string') {\n            throw new JWSInvalid('JWS Payload must be a string');\n        }\n    }\n    else if (typeof jws.payload !== 'string' && !(jws.payload instanceof Uint8Array)) {\n        throw new JWSInvalid('JWS Payload must be a string or an Uint8Array instance');\n    }\n    let resolvedKey = false;\n    if (typeof key === 'function') {\n        key = await key(parsedProt, jws);\n        resolvedKey = true;\n    }\n    checkKeyType(alg, key, 'verify');\n    const data = concat(encoder.encode((_a = jws.protected) !== null && _a !== void 0 ? _a : ''), encoder.encode('.'), typeof jws.payload === 'string' ? encoder.encode(jws.payload) : jws.payload);\n    const signature = base64url(jws.signature);\n    const verified = await verify(alg, key, signature, data);\n    if (!verified) {\n        throw new JWSSignatureVerificationFailed();\n    }\n    let payload;\n    if (b64) {\n        payload = base64url(jws.payload);\n    }\n    else if (typeof jws.payload === 'string') {\n        payload = encoder.encode(jws.payload);\n    }\n    else {\n        payload = jws.payload;\n    }\n    const result = { payload };\n    if (jws.protected !== undefined) {\n        result.protectedHeader = parsedProt;\n    }\n    if (jws.header !== undefined) {\n        result.unprotectedHeader = jws.header;\n    }\n    if (resolvedKey) {\n        return { ...result, key };\n    }\n    return result;\n}\n", "import { flattenedVerify } from '../flattened/verify.js';\nimport { JWSInvalid } from '../../util/errors.js';\nimport { decoder } from '../../lib/buffer_utils.js';\nexport async function compactVerify(jws, key, options) {\n    if (jws instanceof Uint8Array) {\n        jws = decoder.decode(jws);\n    }\n    if (typeof jws !== 'string') {\n        throw new JWSInvalid('Compact JWS must be a string or Uint8Array');\n    }\n    const { 0: protectedHeader, 1: payload, 2: signature, length } = jws.split('.');\n    if (length !== 3) {\n        throw new JWSInvalid('Invalid Compact JWS');\n    }\n    const verified = await flattenedVerify({ payload, protected: protectedHeader, signature }, key, options);\n    const result = { payload: verified.payload, protectedHeader: verified.protectedHeader };\n    if (typeof key === 'function') {\n        return { ...result, key: verified.key };\n    }\n    return result;\n}\n", "import { flattenedVerify } from '../flattened/verify.js';\nimport { JWSInvalid, JWSSignatureVerificationFailed } from '../../util/errors.js';\nimport isObject from '../../lib/is_object.js';\nexport async function generalVerify(jws, key, options) {\n    if (!isObject(jws)) {\n        throw new JWSInvalid('General JWS must be an object');\n    }\n    if (!Array.isArray(jws.signatures) || !jws.signatures.every(isObject)) {\n        throw new JWSInvalid('JWS Signatures missing or incorrect type');\n    }\n    for (const signature of jws.signatures) {\n        try {\n            return await flattenedVerify({\n                header: signature.header,\n                payload: jws.payload,\n                protected: signature.protected,\n                signature: signature.signature,\n            }, key, options);\n        }\n        catch (_a) {\n        }\n    }\n    throw new JWSSignatureVerificationFailed();\n}\n", "export default (date) => Math.floor(date.getTime() / 1000);\n", "const minute = 60;\nconst hour = minute * 60;\nconst day = hour * 24;\nconst week = day * 7;\nconst year = day * 365.25;\nconst REGEX = /^(\\d+|\\d+\\.\\d+) ?(seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)$/i;\nexport default (str) => {\n    const matched = REGEX.exec(str);\n    if (!matched) {\n        throw new TypeError('Invalid time period format');\n    }\n    const value = parseFloat(matched[1]);\n    const unit = matched[2].toLowerCase();\n    switch (unit) {\n        case 'sec':\n        case 'secs':\n        case 'second':\n        case 'seconds':\n        case 's':\n            return Math.round(value);\n        case 'minute':\n        case 'minutes':\n        case 'min':\n        case 'mins':\n        case 'm':\n            return Math.round(value * minute);\n        case 'hour':\n        case 'hours':\n        case 'hr':\n        case 'hrs':\n        case 'h':\n            return Math.round(value * hour);\n        case 'day':\n        case 'days':\n        case 'd':\n            return Math.round(value * day);\n        case 'week':\n        case 'weeks':\n        case 'w':\n            return Math.round(value * week);\n        default:\n            return Math.round(value * year);\n    }\n};\n", "import { JWTClaimValidationFailed, JWTExpired, JWTInvalid } from '../util/errors.js';\nimport { decoder } from './buffer_utils.js';\nimport epoch from './epoch.js';\nimport secs from './secs.js';\nimport isObject from './is_object.js';\nconst normalizeTyp = (value) => value.toLowerCase().replace(/^application\\//, '');\nconst checkAudiencePresence = (audPayload, audOption) => {\n    if (typeof audPayload === 'string') {\n        return audOption.includes(audPayload);\n    }\n    if (Array.isArray(audPayload)) {\n        return audOption.some(Set.prototype.has.bind(new Set(audPayload)));\n    }\n    return false;\n};\nexport default (protectedHeader, encodedPayload, options = {}) => {\n    const { typ } = options;\n    if (typ &&\n        (typeof protectedHeader.typ !== 'string' ||\n            normalizeTyp(protectedHeader.typ) !== normalizeTyp(typ))) {\n        throw new JWTClaimValidationFailed('unexpected \"typ\" JWT header value', 'typ', 'check_failed');\n    }\n    let payload;\n    try {\n        payload = JSON.parse(decoder.decode(encodedPayload));\n    }\n    catch (_a) {\n    }\n    if (!isObject(payload)) {\n        throw new JWTInvalid('JWT Claims Set must be a top-level JSON object');\n    }\n    const { requiredClaims = [], issuer, subject, audience, maxTokenAge } = options;\n    if (maxTokenAge !== undefined)\n        requiredClaims.push('iat');\n    if (audience !== undefined)\n        requiredClaims.push('aud');\n    if (subject !== undefined)\n        requiredClaims.push('sub');\n    if (issuer !== undefined)\n        requiredClaims.push('iss');\n    for (const claim of new Set(requiredClaims.reverse())) {\n        if (!(claim in payload)) {\n            throw new JWTClaimValidationFailed(`missing required \"${claim}\" claim`, claim, 'missing');\n        }\n    }\n    if (issuer && !(Array.isArray(issuer) ? issuer : [issuer]).includes(payload.iss)) {\n        throw new JWTClaimValidationFailed('unexpected \"iss\" claim value', 'iss', 'check_failed');\n    }\n    if (subject && payload.sub !== subject) {\n        throw new JWTClaimValidationFailed('unexpected \"sub\" claim value', 'sub', 'check_failed');\n    }\n    if (audience &&\n        !checkAudiencePresence(payload.aud, typeof audience === 'string' ? [audience] : audience)) {\n        throw new JWTClaimValidationFailed('unexpected \"aud\" claim value', 'aud', 'check_failed');\n    }\n    let tolerance;\n    switch (typeof options.clockTolerance) {\n        case 'string':\n            tolerance = secs(options.clockTolerance);\n            break;\n        case 'number':\n            tolerance = options.clockTolerance;\n            break;\n        case 'undefined':\n            tolerance = 0;\n            break;\n        default:\n            throw new TypeError('Invalid clockTolerance option type');\n    }\n    const { currentDate } = options;\n    const now = epoch(currentDate || new Date());\n    if ((payload.iat !== undefined || maxTokenAge) && typeof payload.iat !== 'number') {\n        throw new JWTClaimValidationFailed('\"iat\" claim must be a number', 'iat', 'invalid');\n    }\n    if (payload.nbf !== undefined) {\n        if (typeof payload.nbf !== 'number') {\n            throw new JWTClaimValidationFailed('\"nbf\" claim must be a number', 'nbf', 'invalid');\n        }\n        if (payload.nbf > now + tolerance) {\n            throw new JWTClaimValidationFailed('\"nbf\" claim timestamp check failed', 'nbf', 'check_failed');\n        }\n    }\n    if (payload.exp !== undefined) {\n        if (typeof payload.exp !== 'number') {\n            throw new JWTClaimValidationFailed('\"exp\" claim must be a number', 'exp', 'invalid');\n        }\n        if (payload.exp <= now - tolerance) {\n            throw new JWTExpired('\"exp\" claim timestamp check failed', 'exp', 'check_failed');\n        }\n    }\n    if (maxTokenAge) {\n        const age = now - payload.iat;\n        const max = typeof maxTokenAge === 'number' ? maxTokenAge : secs(maxTokenAge);\n        if (age - tolerance > max) {\n            throw new JWTExpired('\"iat\" claim timestamp check failed (too far in the past)', 'iat', 'check_failed');\n        }\n        if (age < 0 - tolerance) {\n            throw new JWTClaimValidationFailed('\"iat\" claim timestamp check failed (it should be in the past)', 'iat', 'check_failed');\n        }\n    }\n    return payload;\n};\n", "import { compactVerify } from '../jws/compact/verify.js';\nimport jwtPayload from '../lib/jwt_claims_set.js';\nimport { JWTInvalid } from '../util/errors.js';\nexport async function jwtVerify(jwt, key, options) {\n    var _a;\n    const verified = await compactVerify(jwt, key, options);\n    if (((_a = verified.protectedHeader.crit) === null || _a === void 0 ? void 0 : _a.includes('b64')) && verified.protectedHeader.b64 === false) {\n        throw new JWTInvalid('JWTs MUST NOT use unencoded payload');\n    }\n    const payload = jwtPayload(verified.protectedHeader, verified.payload, options);\n    const result = { payload, protectedHeader: verified.protectedHeader };\n    if (typeof key === 'function') {\n        return { ...result, key: verified.key };\n    }\n    return result;\n}\n", "import { compactDecrypt } from '../jwe/compact/decrypt.js';\nimport jwtPayload from '../lib/jwt_claims_set.js';\nimport { JWTClaimValidationFailed } from '../util/errors.js';\nexport async function jwtDecrypt(jwt, key, options) {\n    const decrypted = await compactDecrypt(jwt, key, options);\n    const payload = jwtPayload(decrypted.protectedHeader, decrypted.plaintext, options);\n    const { protectedHeader } = decrypted;\n    if (protectedHeader.iss !== undefined && protectedHeader.iss !== payload.iss) {\n        throw new JWTClaimValidationFailed('replicated \"iss\" claim header parameter mismatch', 'iss', 'mismatch');\n    }\n    if (protectedHeader.sub !== undefined && protectedHeader.sub !== payload.sub) {\n        throw new JWTClaimValidationFailed('replicated \"sub\" claim header parameter mismatch', 'sub', 'mismatch');\n    }\n    if (protectedHeader.aud !== undefined &&\n        JSON.stringify(protectedHeader.aud) !== JSON.stringify(payload.aud)) {\n        throw new JWTClaimValidationFailed('replicated \"aud\" claim header parameter mismatch', 'aud', 'mismatch');\n    }\n    const result = { payload, protectedHeader };\n    if (typeof key === 'function') {\n        return { ...result, key: decrypted.key };\n    }\n    return result;\n}\n", "import { FlattenedEncrypt } from '../flattened/encrypt.js';\nexport class CompactEncrypt {\n    constructor(plaintext) {\n        this._flattened = new FlattenedEncrypt(plaintext);\n    }\n    setContentEncryptionKey(cek) {\n        this._flattened.setContentEncryptionKey(cek);\n        return this;\n    }\n    setInitializationVector(iv) {\n        this._flattened.setInitializationVector(iv);\n        return this;\n    }\n    setProtectedHeader(protectedHeader) {\n        this._flattened.setProtectedHeader(protectedHeader);\n        return this;\n    }\n    setKeyManagementParameters(parameters) {\n        this._flattened.setKeyManagementParameters(parameters);\n        return this;\n    }\n    async encrypt(key, options) {\n        const jwe = await this._flattened.encrypt(key, options);\n        return [jwe.protected, jwe.encrypted_key, jwe.iv, jwe.ciphertext, jwe.tag].join('.');\n    }\n}\n", "import subtleAlgorithm from './subtle_dsa.js';\nimport crypto from './webcrypto.js';\nimport checkKeyLength from './check_key_length.js';\nimport getSignKey from './get_sign_verify_key.js';\nconst sign = async (alg, key, data) => {\n    const cryptoKey = await getSignKey(alg, key, 'sign');\n    checkKeyLength(alg, cryptoKey);\n    const signature = await crypto.subtle.sign(subtleAlgorithm(alg, cryptoKey.algorithm), cryptoKey, data);\n    return new Uint8Array(signature);\n};\nexport default sign;\n", "import { encode as base64url } from '../../runtime/base64url.js';\nimport sign from '../../runtime/sign.js';\nimport isDisjoint from '../../lib/is_disjoint.js';\nimport { JWSInvalid } from '../../util/errors.js';\nimport { encoder, decoder, concat } from '../../lib/buffer_utils.js';\nimport checkKeyType from '../../lib/check_key_type.js';\nimport validateCrit from '../../lib/validate_crit.js';\nexport class FlattenedSign {\n    constructor(payload) {\n        if (!(payload instanceof Uint8Array)) {\n            throw new TypeError('payload must be an instance of Uint8Array');\n        }\n        this._payload = payload;\n    }\n    setProtectedHeader(protectedHeader) {\n        if (this._protectedHeader) {\n            throw new TypeError('setProtectedHeader can only be called once');\n        }\n        this._protectedHeader = protectedHeader;\n        return this;\n    }\n    setUnprotectedHeader(unprotectedHeader) {\n        if (this._unprotectedHeader) {\n            throw new TypeError('setUnprotectedHeader can only be called once');\n        }\n        this._unprotectedHeader = unprotectedHeader;\n        return this;\n    }\n    async sign(key, options) {\n        if (!this._protectedHeader && !this._unprotectedHeader) {\n            throw new JWSInvalid('either setProtectedHeader or setUnprotectedHeader must be called before #sign()');\n        }\n        if (!isDisjoint(this._protectedHeader, this._unprotectedHeader)) {\n            throw new JWSInvalid('JWS Protected and JWS Unprotected Header Parameter names must be disjoint');\n        }\n        const joseHeader = {\n            ...this._protectedHeader,\n            ...this._unprotectedHeader,\n        };\n        const extensions = validateCrit(JWSInvalid, new Map([['b64', true]]), options === null || options === void 0 ? void 0 : options.crit, this._protectedHeader, joseHeader);\n        let b64 = true;\n        if (extensions.has('b64')) {\n            b64 = this._protectedHeader.b64;\n            if (typeof b64 !== 'boolean') {\n                throw new JWSInvalid('The \"b64\" (base64url-encode payload) Header Parameter must be a boolean');\n            }\n        }\n        const { alg } = joseHeader;\n        if (typeof alg !== 'string' || !alg) {\n            throw new JWSInvalid('JWS \"alg\" (Algorithm) Header Parameter missing or invalid');\n        }\n        checkKeyType(alg, key, 'sign');\n        let payload = this._payload;\n        if (b64) {\n            payload = encoder.encode(base64url(payload));\n        }\n        let protectedHeader;\n        if (this._protectedHeader) {\n            protectedHeader = encoder.encode(base64url(JSON.stringify(this._protectedHeader)));\n        }\n        else {\n            protectedHeader = encoder.encode('');\n        }\n        const data = concat(protectedHeader, encoder.encode('.'), payload);\n        const signature = await sign(alg, key, data);\n        const jws = {\n            signature: base64url(signature),\n            payload: '',\n        };\n        if (b64) {\n            jws.payload = decoder.decode(payload);\n        }\n        if (this._unprotectedHeader) {\n            jws.header = this._unprotectedHeader;\n        }\n        if (this._protectedHeader) {\n            jws.protected = decoder.decode(protectedHeader);\n        }\n        return jws;\n    }\n}\n", "import { FlattenedSign } from '../flattened/sign.js';\nexport class CompactSign {\n    constructor(payload) {\n        this._flattened = new FlattenedSign(payload);\n    }\n    setProtectedHeader(protectedHeader) {\n        this._flattened.setProtectedHeader(protectedHeader);\n        return this;\n    }\n    async sign(key, options) {\n        const jws = await this._flattened.sign(key, options);\n        if (jws.payload === undefined) {\n            throw new TypeError('use the flattened module for creating JWS with b64: false');\n        }\n        return `${jws.protected}.${jws.payload}.${jws.signature}`;\n    }\n}\n", "import { FlattenedSign } from '../flattened/sign.js';\nimport { JWSInvalid } from '../../util/errors.js';\nclass IndividualSignature {\n    constructor(sig, key, options) {\n        this.parent = sig;\n        this.key = key;\n        this.options = options;\n    }\n    setProtectedHeader(protectedHeader) {\n        if (this.protectedHeader) {\n            throw new TypeError('setProtectedHeader can only be called once');\n        }\n        this.protectedHeader = protectedHeader;\n        return this;\n    }\n    setUnprotectedHeader(unprotectedHeader) {\n        if (this.unprotectedHeader) {\n            throw new TypeError('setUnprotectedHeader can only be called once');\n        }\n        this.unprotectedHeader = unprotectedHeader;\n        return this;\n    }\n    addSignature(...args) {\n        return this.parent.addSignature(...args);\n    }\n    sign(...args) {\n        return this.parent.sign(...args);\n    }\n    done() {\n        return this.parent;\n    }\n}\nexport class GeneralSign {\n    constructor(payload) {\n        this._signatures = [];\n        this._payload = payload;\n    }\n    addSignature(key, options) {\n        const signature = new IndividualSignature(this, key, options);\n        this._signatures.push(signature);\n        return signature;\n    }\n    async sign() {\n        if (!this._signatures.length) {\n            throw new JWSInvalid('at least one signature must be added');\n        }\n        const jws = {\n            signatures: [],\n            payload: '',\n        };\n        for (let i = 0; i < this._signatures.length; i++) {\n            const signature = this._signatures[i];\n            const flattened = new FlattenedSign(this._payload);\n            flattened.setProtectedHeader(signature.protectedHeader);\n            flattened.setUnprotectedHeader(signature.unprotectedHeader);\n            const { payload, ...rest } = await flattened.sign(signature.key, signature.options);\n            if (i === 0) {\n                jws.payload = payload;\n            }\n            else if (jws.payload !== payload) {\n                throw new JWSInvalid('inconsistent use of JWS Unencoded Payload (RFC7797)');\n            }\n            jws.signatures.push(rest);\n        }\n        return jws;\n    }\n}\n", "import epoch from '../lib/epoch.js';\nimport isObject from '../lib/is_object.js';\nimport secs from '../lib/secs.js';\nexport class ProduceJWT {\n    constructor(payload) {\n        if (!isObject(payload)) {\n            throw new TypeError('JWT Claims Set MUST be an object');\n        }\n        this._payload = payload;\n    }\n    setIssuer(issuer) {\n        this._payload = { ...this._payload, iss: issuer };\n        return this;\n    }\n    setSubject(subject) {\n        this._payload = { ...this._payload, sub: subject };\n        return this;\n    }\n    setAudience(audience) {\n        this._payload = { ...this._payload, aud: audience };\n        return this;\n    }\n    setJti(jwtId) {\n        this._payload = { ...this._payload, jti: jwtId };\n        return this;\n    }\n    setNotBefore(input) {\n        if (typeof input === 'number') {\n            this._payload = { ...this._payload, nbf: input };\n        }\n        else {\n            this._payload = { ...this._payload, nbf: epoch(new Date()) + secs(input) };\n        }\n        return this;\n    }\n    setExpirationTime(input) {\n        if (typeof input === 'number') {\n            this._payload = { ...this._payload, exp: input };\n        }\n        else {\n            this._payload = { ...this._payload, exp: epoch(new Date()) + secs(input) };\n        }\n        return this;\n    }\n    setIssuedAt(input) {\n        if (typeof input === 'undefined') {\n            this._payload = { ...this._payload, iat: epoch(new Date()) };\n        }\n        else {\n            this._payload = { ...this._payload, iat: input };\n        }\n        return this;\n    }\n}\n", "import { CompactSign } from '../jws/compact/sign.js';\nimport { JWTInvalid } from '../util/errors.js';\nimport { encoder } from '../lib/buffer_utils.js';\nimport { ProduceJWT } from './produce.js';\nexport class SignJWT extends ProduceJWT {\n    setProtectedHeader(protectedHeader) {\n        this._protectedHeader = protectedHeader;\n        return this;\n    }\n    async sign(key, options) {\n        var _a;\n        const sig = new CompactSign(encoder.encode(JSON.stringify(this._payload)));\n        sig.setProtectedHeader(this._protectedHeader);\n        if (Array.isArray((_a = this._protectedHeader) === null || _a === void 0 ? void 0 : _a.crit) &&\n            this._protectedHeader.crit.includes('b64') &&\n            this._protectedHeader.b64 === false) {\n            throw new JWTInvalid('JWTs MUST NOT use unencoded payload');\n        }\n        return sig.sign(key, options);\n    }\n}\n", "import { CompactEncrypt } from '../jwe/compact/encrypt.js';\nimport { encoder } from '../lib/buffer_utils.js';\nimport { ProduceJWT } from './produce.js';\nexport class EncryptJWT extends ProduceJWT {\n    setProtectedHeader(protectedHeader) {\n        if (this._protectedHeader) {\n            throw new TypeError('setProtectedHeader can only be called once');\n        }\n        this._protectedHeader = protectedHeader;\n        return this;\n    }\n    setKeyManagementParameters(parameters) {\n        if (this._keyManagementParameters) {\n            throw new TypeError('setKeyManagementParameters can only be called once');\n        }\n        this._keyManagementParameters = parameters;\n        return this;\n    }\n    setContentEncryptionKey(cek) {\n        if (this._cek) {\n            throw new TypeError('setContentEncryptionKey can only be called once');\n        }\n        this._cek = cek;\n        return this;\n    }\n    setInitializationVector(iv) {\n        if (this._iv) {\n            throw new TypeError('setInitializationVector can only be called once');\n        }\n        this._iv = iv;\n        return this;\n    }\n    replicateIssuerAsHeader() {\n        this._replicateIssuerAsHeader = true;\n        return this;\n    }\n    replicateSubjectAsHeader() {\n        this._replicateSubjectAsHeader = true;\n        return this;\n    }\n    replicateAudienceAsHeader() {\n        this._replicateAudienceAsHeader = true;\n        return this;\n    }\n    async encrypt(key, options) {\n        const enc = new CompactEncrypt(encoder.encode(JSON.stringify(this._payload)));\n        if (this._replicateIssuerAsHeader) {\n            this._protectedHeader = { ...this._protectedHeader, iss: this._payload.iss };\n        }\n        if (this._replicateSubjectAsHeader) {\n            this._protectedHeader = { ...this._protectedHeader, sub: this._payload.sub };\n        }\n        if (this._replicateAudienceAsHeader) {\n            this._protectedHeader = { ...this._protectedHeader, aud: this._payload.aud };\n        }\n        enc.setProtectedHeader(this._protectedHeader);\n        if (this._iv) {\n            enc.setInitializationVector(this._iv);\n        }\n        if (this._cek) {\n            enc.setContentEncryptionKey(this._cek);\n        }\n        if (this._keyManagementParameters) {\n            enc.setKeyManagementParameters(this._keyManagementParameters);\n        }\n        return enc.encrypt(key, options);\n    }\n}\n", "import digest from '../runtime/digest.js';\nimport { encode as base64url } from '../runtime/base64url.js';\nimport { JOSENotSupported, JWKInvalid } from '../util/errors.js';\nimport { encoder } from '../lib/buffer_utils.js';\nimport isObject from '../lib/is_object.js';\nconst check = (value, description) => {\n    if (typeof value !== 'string' || !value) {\n        throw new JWKInvalid(`${description} missing or invalid`);\n    }\n};\nexport async function calculateJwkThumbprint(jwk, digestAlgorithm) {\n    if (!isObject(jwk)) {\n        throw new TypeError('JWK must be an object');\n    }\n    digestAlgorithm !== null && digestAlgorithm !== void 0 ? digestAlgorithm : (digestAlgorithm = 'sha256');\n    if (digestAlgorithm !== 'sha256' &&\n        digestAlgorithm !== 'sha384' &&\n        digestAlgorithm !== 'sha512') {\n        throw new TypeError('digestAlgorithm must one of \"sha256\", \"sha384\", or \"sha512\"');\n    }\n    let components;\n    switch (jwk.kty) {\n        case 'EC':\n            check(jwk.crv, '\"crv\" (Curve) Parameter');\n            check(jwk.x, '\"x\" (X Coordinate) Parameter');\n            check(jwk.y, '\"y\" (Y Coordinate) Parameter');\n            components = { crv: jwk.crv, kty: jwk.kty, x: jwk.x, y: jwk.y };\n            break;\n        case 'OKP':\n            check(jwk.crv, '\"crv\" (Subtype of Key Pair) Parameter');\n            check(jwk.x, '\"x\" (Public Key) Parameter');\n            components = { crv: jwk.crv, kty: jwk.kty, x: jwk.x };\n            break;\n        case 'RSA':\n            check(jwk.e, '\"e\" (Exponent) Parameter');\n            check(jwk.n, '\"n\" (Modulus) Parameter');\n            components = { e: jwk.e, kty: jwk.kty, n: jwk.n };\n            break;\n        case 'oct':\n            check(jwk.k, '\"k\" (Key Value) Parameter');\n            components = { k: jwk.k, kty: jwk.kty };\n            break;\n        default:\n            throw new JOSENotSupported('\"kty\" (Key Type) Parameter missing or unsupported');\n    }\n    const data = encoder.encode(JSON.stringify(components));\n    return base64url(await digest(digestAlgorithm, data));\n}\nexport async function calculateJwkThumbprintUri(jwk, digestAlgorithm) {\n    digestAlgorithm !== null && digestAlgorithm !== void 0 ? digestAlgorithm : (digestAlgorithm = 'sha256');\n    const thumbprint = await calculateJwkThumbprint(jwk, digestAlgorithm);\n    return `urn:ietf:params:oauth:jwk-thumbprint:sha-${digestAlgorithm.slice(-3)}:${thumbprint}`;\n}\n", "import { importJWK } from '../key/import.js';\nimport isObject from '../lib/is_object.js';\nimport { JWSInvalid } from '../util/errors.js';\nexport async function EmbeddedJWK(protectedHeader, token) {\n    const joseHeader = {\n        ...protectedHeader,\n        ...token === null || token === void 0 ? void 0 : token.header,\n    };\n    if (!isObject(joseHeader.jwk)) {\n        throw new JWSInvalid('\"jwk\" (JSON Web Key) Header Parameter must be a JSON object');\n    }\n    const key = await importJWK({ ...joseHeader.jwk, ext: true }, joseHeader.alg, true);\n    if (key instanceof Uint8Array || key.type !== 'public') {\n        throw new JWSInvalid('\"jwk\" (JSON Web Key) Header Parameter must be a public key');\n    }\n    return key;\n}\n", "import { importJWK } from '../key/import.js';\nimport { JWKSInvalid, JOSENotSupported, JWKSNoMatchingKey, JWKSMultipleMatchingKeys, } from '../util/errors.js';\nimport isObject from '../lib/is_object.js';\nfunction getKtyFromAlg(alg) {\n    switch (typeof alg === 'string' && alg.slice(0, 2)) {\n        case 'RS':\n        case 'PS':\n            return 'RSA';\n        case 'ES':\n            return 'EC';\n        case 'Ed':\n            return 'OKP';\n        default:\n            throw new JOSENotSupported('Unsupported \"alg\" value for a JSON Web Key Set');\n    }\n}\nexport function isJWKSLike(jwks) {\n    return (jwks &&\n        typeof jwks === 'object' &&\n        Array.isArray(jwks.keys) &&\n        jwks.keys.every(isJWKLike));\n}\nfunction isJWKLike(key) {\n    return isObject(key);\n}\nfunction clone(obj) {\n    if (typeof structuredClone === 'function') {\n        return structuredClone(obj);\n    }\n    return JSON.parse(JSON.stringify(obj));\n}\nexport class LocalJWKSet {\n    constructor(jwks) {\n        this._cached = new WeakMap();\n        if (!isJWKSLike(jwks)) {\n            throw new JWKSInvalid('JSON Web Key Set malformed');\n        }\n        this._jwks = clone(jwks);\n    }\n    async getKey(protectedHeader, token) {\n        const { alg, kid } = { ...protectedHeader, ...token === null || token === void 0 ? void 0 : token.header };\n        const kty = getKtyFromAlg(alg);\n        const candidates = this._jwks.keys.filter((jwk) => {\n            let candidate = kty === jwk.kty;\n            if (candidate && typeof kid === 'string') {\n                candidate = kid === jwk.kid;\n            }\n            if (candidate && typeof jwk.alg === 'string') {\n                candidate = alg === jwk.alg;\n            }\n            if (candidate && typeof jwk.use === 'string') {\n                candidate = jwk.use === 'sig';\n            }\n            if (candidate && Array.isArray(jwk.key_ops)) {\n                candidate = jwk.key_ops.includes('verify');\n            }\n            if (candidate && alg === 'EdDSA') {\n                candidate = jwk.crv === 'Ed25519' || jwk.crv === 'Ed448';\n            }\n            if (candidate) {\n                switch (alg) {\n                    case 'ES256':\n                        candidate = jwk.crv === 'P-256';\n                        break;\n                    case 'ES256K':\n                        candidate = jwk.crv === 'secp256k1';\n                        break;\n                    case 'ES384':\n                        candidate = jwk.crv === 'P-384';\n                        break;\n                    case 'ES512':\n                        candidate = jwk.crv === 'P-521';\n                        break;\n                }\n            }\n            return candidate;\n        });\n        const { 0: jwk, length } = candidates;\n        if (length === 0) {\n            throw new JWKSNoMatchingKey();\n        }\n        else if (length !== 1) {\n            const error = new JWKSMultipleMatchingKeys();\n            const { _cached } = this;\n            error[Symbol.asyncIterator] = async function* () {\n                for (const jwk of candidates) {\n                    try {\n                        yield await importWithAlgCache(_cached, jwk, alg);\n                    }\n                    catch (_a) {\n                        continue;\n                    }\n                }\n            };\n            throw error;\n        }\n        return importWithAlgCache(this._cached, jwk, alg);\n    }\n}\nasync function importWithAlgCache(cache, jwk, alg) {\n    const cached = cache.get(jwk) || cache.set(jwk, {}).get(jwk);\n    if (cached[alg] === undefined) {\n        const key = await importJWK({ ...jwk, ext: true }, alg);\n        if (key instanceof Uint8Array || key.type !== 'public') {\n            throw new JWKSInvalid('JSON Web Key Set members must be public keys');\n        }\n        cached[alg] = key;\n    }\n    return cached[alg];\n}\nexport function createLocalJWKSet(jwks) {\n    const set = new LocalJWKSet(jwks);\n    return async function (protectedHeader, token) {\n        return set.getKey(protectedHeader, token);\n    };\n}\n", "import { JOSEError, JWKSTimeout } from '../util/errors.js';\nconst fetchJwks = async (url, timeout, options) => {\n    let controller;\n    let id;\n    let timedOut = false;\n    if (typeof AbortController === 'function') {\n        controller = new AbortController();\n        id = setTimeout(() => {\n            timedOut = true;\n            controller.abort();\n        }, timeout);\n    }\n    const response = await fetch(url.href, {\n        signal: controller ? controller.signal : undefined,\n        redirect: 'manual',\n        headers: options.headers,\n    }).catch((err) => {\n        if (timedOut)\n            throw new JWKSTimeout();\n        throw err;\n    });\n    if (id !== undefined)\n        clearTimeout(id);\n    if (response.status !== 200) {\n        throw new JOSEError('Expected 200 OK from the JSON Web Key Set HTTP response');\n    }\n    try {\n        return await response.json();\n    }\n    catch (_a) {\n        throw new JOSEError('Failed to parse the JSON Web Key Set HTTP response as JSON');\n    }\n};\nexport default fetchJwks;\n", "import fetchJwks from '../runtime/fetch_jwks.js';\nimport { JWKSInvalid, JWKSNoMatchingKey } from '../util/errors.js';\nimport { isJWKSLike, LocalJWKSet } from './local.js';\nfunction isCloudflareWorkers() {\n    return (typeof WebSocketPair !== 'undefined' ||\n        (typeof navigator !== 'undefined' && navigator.userAgent === 'Cloudflare-Workers') ||\n        (typeof EdgeRuntime !== 'undefined' && EdgeRuntime === 'vercel'));\n}\nclass RemoteJWKSet extends LocalJWKSet {\n    constructor(url, options) {\n        super({ keys: [] });\n        this._jwks = undefined;\n        if (!(url instanceof URL)) {\n            throw new TypeError('url must be an instance of URL');\n        }\n        this._url = new URL(url.href);\n        this._options = { agent: options === null || options === void 0 ? void 0 : options.agent, headers: options === null || options === void 0 ? void 0 : options.headers };\n        this._timeoutDuration =\n            typeof (options === null || options === void 0 ? void 0 : options.timeoutDuration) === 'number' ? options === null || options === void 0 ? void 0 : options.timeoutDuration : 5000;\n        this._cooldownDuration =\n            typeof (options === null || options === void 0 ? void 0 : options.cooldownDuration) === 'number' ? options === null || options === void 0 ? void 0 : options.cooldownDuration : 30000;\n        this._cacheMaxAge = typeof (options === null || options === void 0 ? void 0 : options.cacheMaxAge) === 'number' ? options === null || options === void 0 ? void 0 : options.cacheMaxAge : 600000;\n    }\n    coolingDown() {\n        return typeof this._jwksTimestamp === 'number'\n            ? Date.now() < this._jwksTimestamp + this._cooldownDuration\n            : false;\n    }\n    fresh() {\n        return typeof this._jwksTimestamp === 'number'\n            ? Date.now() < this._jwksTimestamp + this._cacheMaxAge\n            : false;\n    }\n    async getKey(protectedHeader, token) {\n        if (!this._jwks || !this.fresh()) {\n            await this.reload();\n        }\n        try {\n            return await super.getKey(protectedHeader, token);\n        }\n        catch (err) {\n            if (err instanceof JWKSNoMatchingKey) {\n                if (this.coolingDown() === false) {\n                    await this.reload();\n                    return super.getKey(protectedHeader, token);\n                }\n            }\n            throw err;\n        }\n    }\n    async reload() {\n        if (this._pendingFetch && isCloudflareWorkers()) {\n            this._pendingFetch = undefined;\n        }\n        this._pendingFetch || (this._pendingFetch = fetchJwks(this._url, this._timeoutDuration, this._options)\n            .then((json) => {\n            if (!isJWKSLike(json)) {\n                throw new JWKSInvalid('JSON Web Key Set malformed');\n            }\n            this._jwks = { keys: json.keys };\n            this._jwksTimestamp = Date.now();\n            this._pendingFetch = undefined;\n        })\n            .catch((err) => {\n            this._pendingFetch = undefined;\n            throw err;\n        }));\n        await this._pendingFetch;\n    }\n}\nexport function createRemoteJWKSet(url, options) {\n    const set = new RemoteJWKSet(url, options);\n    return async function (protectedHeader, token) {\n        return set.getKey(protectedHeader, token);\n    };\n}\n", "import * as base64url from '../runtime/base64url.js';\nimport { decoder } from '../lib/buffer_utils.js';\nimport { JWTInvalid } from '../util/errors.js';\nimport jwtPayload from '../lib/jwt_claims_set.js';\nimport { ProduceJWT } from './produce.js';\nexport class UnsecuredJWT extends ProduceJWT {\n    encode() {\n        const header = base64url.encode(JSON.stringify({ alg: 'none' }));\n        const payload = base64url.encode(JSON.stringify(this._payload));\n        return `${header}.${payload}.`;\n    }\n    static decode(jwt, options) {\n        if (typeof jwt !== 'string') {\n            throw new JWTInvalid('Unsecured JWT must be a string');\n        }\n        const { 0: encodedHeader, 1: encodedPayload, 2: signature, length } = jwt.split('.');\n        if (length !== 3 || signature !== '') {\n            throw new JWTInvalid('Invalid Unsecured JWT');\n        }\n        let header;\n        try {\n            header = JSON.parse(decoder.decode(base64url.decode(encodedHeader)));\n            if (header.alg !== 'none')\n                throw new Error();\n        }\n        catch (_a) {\n            throw new JWTInvalid('Invalid Unsecured JWT');\n        }\n        const payload = jwtPayload(header, base64url.decode(encodedPayload), options);\n        return { payload, header };\n    }\n}\n", "import * as base64url from '../runtime/base64url.js';\nexport const encode = base64url.encode;\nexport const decode = base64url.decode;\n", "import { decode as base64url } from './base64url.js';\nimport { decoder } from '../lib/buffer_utils.js';\nimport isObject from '../lib/is_object.js';\nexport function decodeProtectedHeader(token) {\n    let protectedB64u;\n    if (typeof token === 'string') {\n        const parts = token.split('.');\n        if (parts.length === 3 || parts.length === 5) {\n            ;\n            [protectedB64u] = parts;\n        }\n    }\n    else if (typeof token === 'object' && token) {\n        if ('protected' in token) {\n            protectedB64u = token.protected;\n        }\n        else {\n            throw new TypeError('Token does not contain a Protected Header');\n        }\n    }\n    try {\n        if (typeof protectedB64u !== 'string' || !protectedB64u) {\n            throw new Error();\n        }\n        const result = JSON.parse(decoder.decode(base64url(protectedB64u)));\n        if (!isObject(result)) {\n            throw new Error();\n        }\n        return result;\n    }\n    catch (_a) {\n        throw new TypeError('Invalid Token or Protected Header formatting');\n    }\n}\n", "import { decode as base64url } from './base64url.js';\nimport { decoder } from '../lib/buffer_utils.js';\nimport isObject from '../lib/is_object.js';\nimport { JWTInvalid } from './errors.js';\nexport function decodeJwt(jwt) {\n    if (typeof jwt !== 'string')\n        throw new JWTInvalid('JWTs must use Compact JWS serialization, JWT must be a string');\n    const { 1: payload, length } = jwt.split('.');\n    if (length === 5)\n        throw new JWTInvalid('Only JWTs using Compact JWS serialization can be decoded');\n    if (length !== 3)\n        throw new JWTInvalid('Invalid JWT');\n    if (!payload)\n        throw new JWTInvalid('JWTs must contain a payload');\n    let decoded;\n    try {\n        decoded = base64url(payload);\n    }\n    catch (_a) {\n        throw new JWTInvalid('Failed to parse the base64url encoded payload');\n    }\n    let result;\n    try {\n        result = JSON.parse(decoder.decode(decoded));\n    }\n    catch (_b) {\n        throw new JWTInvalid('Failed to parse the decoded payload as JSON');\n    }\n    if (!isObject(result))\n        throw new JWTInvalid('Invalid JWT Claims Set');\n    return result;\n}\n", "import crypto from './webcrypto.js';\nimport { JOSENotSupported } from '../util/errors.js';\nimport random from './random.js';\nexport async function generateSecret(alg, options) {\n    var _a;\n    let length;\n    let algorithm;\n    let keyUsages;\n    switch (alg) {\n        case 'HS256':\n        case 'HS384':\n        case 'HS512':\n            length = parseInt(alg.slice(-3), 10);\n            algorithm = { name: 'HMAC', hash: `SHA-${length}`, length };\n            keyUsages = ['sign', 'verify'];\n            break;\n        case 'A128CBC-HS256':\n        case 'A192CBC-HS384':\n        case 'A256CBC-HS512':\n            length = parseInt(alg.slice(-3), 10);\n            return random(new Uint8Array(length >> 3));\n        case 'A128KW':\n        case 'A192KW':\n        case 'A256KW':\n            length = parseInt(alg.slice(1, 4), 10);\n            algorithm = { name: 'AES-KW', length };\n            keyUsages = ['wrapKey', 'unwrapKey'];\n            break;\n        case 'A128GCMKW':\n        case 'A192GCMKW':\n        case 'A256GCMKW':\n        case 'A128GCM':\n        case 'A192GCM':\n        case 'A256GCM':\n            length = parseInt(alg.slice(1, 4), 10);\n            algorithm = { name: 'AES-GCM', length };\n            keyUsages = ['encrypt', 'decrypt'];\n            break;\n        default:\n            throw new JOSENotSupported('Invalid or unsupported JWK \"alg\" (Algorithm) Parameter value');\n    }\n    return crypto.subtle.generateKey(algorithm, (_a = options === null || options === void 0 ? void 0 : options.extractable) !== null && _a !== void 0 ? _a : false, keyUsages);\n}\nfunction getModulusLengthOption(options) {\n    var _a;\n    const modulusLength = (_a = options === null || options === void 0 ? void 0 : options.modulusLength) !== null && _a !== void 0 ? _a : 2048;\n    if (typeof modulusLength !== 'number' || modulusLength < 2048) {\n        throw new JOSENotSupported('Invalid or unsupported modulusLength option provided, 2048 bits or larger keys must be used');\n    }\n    return modulusLength;\n}\nexport async function generateKeyPair(alg, options) {\n    var _a, _b, _c;\n    let algorithm;\n    let keyUsages;\n    switch (alg) {\n        case 'PS256':\n        case 'PS384':\n        case 'PS512':\n            algorithm = {\n                name: 'RSA-PSS',\n                hash: `SHA-${alg.slice(-3)}`,\n                publicExponent: new Uint8Array([0x01, 0x00, 0x01]),\n                modulusLength: getModulusLengthOption(options),\n            };\n            keyUsages = ['sign', 'verify'];\n            break;\n        case 'RS256':\n        case 'RS384':\n        case 'RS512':\n            algorithm = {\n                name: 'RSASSA-PKCS1-v1_5',\n                hash: `SHA-${alg.slice(-3)}`,\n                publicExponent: new Uint8Array([0x01, 0x00, 0x01]),\n                modulusLength: getModulusLengthOption(options),\n            };\n            keyUsages = ['sign', 'verify'];\n            break;\n        case 'RSA-OAEP':\n        case 'RSA-OAEP-256':\n        case 'RSA-OAEP-384':\n        case 'RSA-OAEP-512':\n            algorithm = {\n                name: 'RSA-OAEP',\n                hash: `SHA-${parseInt(alg.slice(-3), 10) || 1}`,\n                publicExponent: new Uint8Array([0x01, 0x00, 0x01]),\n                modulusLength: getModulusLengthOption(options),\n            };\n            keyUsages = ['decrypt', 'unwrapKey', 'encrypt', 'wrapKey'];\n            break;\n        case 'ES256':\n            algorithm = { name: 'ECDSA', namedCurve: 'P-256' };\n            keyUsages = ['sign', 'verify'];\n            break;\n        case 'ES384':\n            algorithm = { name: 'ECDSA', namedCurve: 'P-384' };\n            keyUsages = ['sign', 'verify'];\n            break;\n        case 'ES512':\n            algorithm = { name: 'ECDSA', namedCurve: 'P-521' };\n            keyUsages = ['sign', 'verify'];\n            break;\n        case 'EdDSA':\n            keyUsages = ['sign', 'verify'];\n            const crv = (_a = options === null || options === void 0 ? void 0 : options.crv) !== null && _a !== void 0 ? _a : 'Ed25519';\n            switch (crv) {\n                case 'Ed25519':\n                case 'Ed448':\n                    algorithm = { name: crv };\n                    break;\n                default:\n                    throw new JOSENotSupported('Invalid or unsupported crv option provided');\n            }\n            break;\n        case 'ECDH-ES':\n        case 'ECDH-ES+A128KW':\n        case 'ECDH-ES+A192KW':\n        case 'ECDH-ES+A256KW': {\n            keyUsages = ['deriveKey', 'deriveBits'];\n            const crv = (_b = options === null || options === void 0 ? void 0 : options.crv) !== null && _b !== void 0 ? _b : 'P-256';\n            switch (crv) {\n                case 'P-256':\n                case 'P-384':\n                case 'P-521': {\n                    algorithm = { name: 'ECDH', namedCurve: crv };\n                    break;\n                }\n                case 'X25519':\n                case 'X448':\n                    algorithm = { name: crv };\n                    break;\n                default:\n                    throw new JOSENotSupported('Invalid or unsupported crv option provided, supported values are P-256, P-384, P-521, X25519, and X448');\n            }\n            break;\n        }\n        default:\n            throw new JOSENotSupported('Invalid or unsupported JWK \"alg\" (Algorithm) Parameter value');\n    }\n    return (crypto.subtle.generateKey(algorithm, (_c = options === null || options === void 0 ? void 0 : options.extractable) !== null && _c !== void 0 ? _c : false, keyUsages));\n}\n", "import { generateKeyPair as generate } from '../runtime/generate.js';\nexport async function generateKeyPair(alg, options) {\n    return generate(alg, options);\n}\n", "import { generateSecret as generate } from '../runtime/generate.js';\nexport async function generateSecret(alg, options) {\n    return generate(alg, options);\n}\n", "export { compactDecrypt } from './jwe/compact/decrypt.js';\nexport { flattenedDecrypt } from './jwe/flattened/decrypt.js';\nexport { generalDecrypt } from './jwe/general/decrypt.js';\nexport { GeneralEncrypt } from './jwe/general/encrypt.js';\nexport { compactVerify } from './jws/compact/verify.js';\nexport { flattenedVerify } from './jws/flattened/verify.js';\nexport { generalVerify } from './jws/general/verify.js';\nexport { jwtVerify } from './jwt/verify.js';\nexport { jwtDecrypt } from './jwt/decrypt.js';\nexport { CompactEncrypt } from './jwe/compact/encrypt.js';\nexport { FlattenedEncrypt } from './jwe/flattened/encrypt.js';\nexport { CompactSign } from './jws/compact/sign.js';\nexport { FlattenedSign } from './jws/flattened/sign.js';\nexport { GeneralSign } from './jws/general/sign.js';\nexport { SignJWT } from './jwt/sign.js';\nexport { EncryptJWT } from './jwt/encrypt.js';\nexport { calculateJwkThumbprint, calculateJwkThumbprintUri } from './jwk/thumbprint.js';\nexport { EmbeddedJWK } from './jwk/embedded.js';\nexport { createLocalJWKSet } from './jwks/local.js';\nexport { createRemoteJWKSet } from './jwks/remote.js';\nexport { UnsecuredJWT } from './jwt/unsecured.js';\nexport { exportPKCS8, exportSPKI, exportJWK } from './key/export.js';\nexport { importSPKI, importPKCS8, importX509, importJWK } from './key/import.js';\nexport { decodeProtectedHeader } from './util/decode_protected_header.js';\nexport { decodeJwt } from './util/decode_jwt.js';\nimport * as errors_1 from './util/errors.js';\nexport { errors_1 as errors };\nexport { generateKeyPair } from './key/generate_key_pair.js';\nexport { generateSecret } from './key/generate_secret.js';\nimport * as base64url_1 from './util/base64url.js';\nexport { base64url_1 as base64url };\n", "import { ConfigurationError } from \"../errors\";\nimport internals from \"../internals\";\nimport { Logger } from \"../logging/interfaces\";\n\nexport interface RetryOptions {\n  /**\n   * Maximum number of retries\n   */\n  retries: number;\n  /**\n   * Delay between retries in milliseconds\n   */\n  retryDelayMs: number;\n  /**\n   * If provided, the error details will be logged\n   */\n  logger?: Logger;\n}\n\n/**\n * Fetch with retries on 500 and 429 errors\n */\nexport async function fetchRetry(\n  options: RetryOptions,\n  request: string | Request,\n  requestInit?: RequestInit | Request\n): Promise<Response> {\n  for (let i = 0; i <= options.retries; i++) {\n    const fetched = internals.fetch(request, requestInit);\n    if (i === options.retries) {\n      // No need to await if we're returning anyway\n      return fetched;\n    }\n    const res = await fetched;\n    if (res.status < 500 && res.status !== 429) {\n      return res;\n    } else {\n      // If a logger was provided, log the error\n      options?.logger?.error(`Request failed, retrying`, {\n        method: typeof request === \"string\" ? \"GET\" : request.method,\n        url: typeof request === \"string\" ? request : request.url,\n        status: res.status,\n      });\n    }\n    await new Promise((resolve) =>\n      setTimeout(resolve, options.retryDelayMs * Math.pow(2, i))\n    );\n  }\n  throw new ConfigurationError(\n    \"An unknown error occurred, ensure retries is not negative\"\n  );\n}\n", "import { importPKCS8, KeyLike, SignJWT } from \"jose\";\nimport { RuntimeError } from \"../errors\";\nimport { fetchRetry, RetryOptions } from \"./retry\";\n\n/**\n * @internal\n */\nexport async function getTokenFromGcpServiceAccount({\n  serviceAccount,\n  audience,\n  expirationTime = \"1h\",\n  payload = {},\n}: {\n  serviceAccount: GcpServiceAccount;\n  audience: string;\n  expirationTime?: number | string;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  payload?: Record<string, any>;\n}) {\n  const { clientEmail, privateKeyId, privateKey } = serviceAccount;\n\n  const jwt = await new SignJWT(payload)\n    .setProtectedHeader({ alg: \"RS256\", kid: privateKeyId })\n    .setIssuer(clientEmail)\n    .setSubject(clientEmail)\n    .setAudience(audience)\n    .setIssuedAt()\n    .setExpirationTime(expirationTime)\n    .sign(privateKey);\n\n  return jwt;\n}\n\nexport interface OAuthTokenResponse {\n  access_token?: string;\n  id_token?: string;\n  expires_in: number;\n  token_type: \"Bearer\";\n}\n\nexport interface FirebaseOAuthTokenResponse {\n  idToken: string;\n  refreshToken: string;\n  expiresIn: string;\n}\n\n/**\n * @internal\n * See https://firebase.google.com/docs/reference/rest/auth\n */\nexport async function exchangeFirebaseJwtForIdToken(\n  audience: string,\n  token: string,\n  retryOptions: RetryOptions\n): Promise<FirebaseOAuthTokenResponse> {\n  return fetchToken<FirebaseOAuthTokenResponse>(\n    audience,\n    {\n      token,\n      returnSecureToken: true,\n    },\n    retryOptions\n  );\n}\n\n/**\n * @internal\n * See https://cloud.google.com/functions/docs/securing/authenticating\n * See https://notes.dt.in.th/InvokingGoogleCloudRunFromCloudflareWorkers\n */\nexport async function exchangeGgpJwtForIdToken(\n  audience: string,\n  token: string,\n  retryOptions: RetryOptions\n): Promise<OAuthTokenResponse> {\n  return fetchToken<OAuthTokenResponse>(\n    audience,\n    {\n      grant_type: \"urn:ietf:params:oauth:grant-type:jwt-bearer\",\n      assertion: token,\n    },\n    retryOptions\n  );\n}\n\nexport async function fetchToken<T>(\n  audience: string,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  body: any,\n  retryOptions: RetryOptions\n): Promise<T> {\n  const response = await fetchRetry(retryOptions, audience, {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n    redirect: \"follow\",\n    body: JSON.stringify(body),\n  });\n\n  if (response.status !== 200) {\n    let extensionMembers: Record<string, unknown> | undefined;\n    try {\n      const text = await response.text();\n      const data = JSON.parse(text);\n      extensionMembers = { cause: data.error ?? data };\n    } catch (err) {\n      // ignore\n    }\n    throw new RuntimeError({\n      message: \"Could not get token from Google Identity\",\n      extensionMembers,\n    });\n  }\n\n  const result = await response.json();\n  return result as T;\n}\n\n/**\n * @internal\n */\ninterface GcpServiceAccountJson {\n  type: string;\n  project_id?: string;\n  private_key_id: string;\n  private_key: string;\n  client_email: string;\n  client_id: string;\n  auth_uri: string;\n  token_url: string;\n  auth_provider_x509_cert_url: string;\n  client_x509_cert_url: string;\n  universe_domain?: string;\n}\n\n/**\n * @internal\n */\nexport class GcpServiceAccount {\n  #privateKey: KeyLike;\n  #serviceAccount: GcpServiceAccountJson;\n\n  private constructor({\n    serviceAccount,\n    privateKey,\n  }: {\n    serviceAccount: GcpServiceAccountJson;\n    privateKey: KeyLike;\n  }) {\n    this.#serviceAccount = serviceAccount;\n    this.#privateKey = privateKey;\n  }\n\n  public static async init(serviceAccountJson: string) {\n    const serviceAccount = JSON.parse(serviceAccountJson);\n    const privateKey = await importPKCS8(\n      serviceAccount.private_key.trim(),\n      \"RS256\"\n    );\n    return new GcpServiceAccount({ serviceAccount, privateKey });\n  }\n\n  public get type(): string | undefined {\n    return this.#serviceAccount.type;\n  }\n\n  public get projectId(): string | undefined {\n    return this.#serviceAccount.project_id;\n  }\n\n  public get privateKeyId(): string {\n    return this.#serviceAccount.private_key_id;\n  }\n\n  public get privateKey(): KeyLike {\n    return this.#privateKey;\n  }\n\n  public get clientEmail(): string {\n    return this.#serviceAccount.client_email;\n  }\n\n  public get clientId(): string {\n    return this.#serviceAccount.client_id;\n  }\n\n  public get authUri(): string {\n    return this.#serviceAccount.auth_uri;\n  }\n\n  public get tokenUrl(): string {\n    return this.#serviceAccount.token_url;\n  }\n\n  public get authProviderX509CertUrl(): string {\n    return this.#serviceAccount.auth_provider_x509_cert_url;\n  }\n\n  public get clientX509CertUrl(): string {\n    return this.#serviceAccount.client_x509_cert_url;\n  }\n\n  public get universalDomain(): string | undefined {\n    return this.#serviceAccount.universe_domain;\n  }\n}\n", "import { SystemError } from \"../../../errors\";\nimport {\n  LoggingEnvironmentStage,\n  LoggingEnvironmentType,\n} from \"../../../interfaces\";\nimport internals from \"../../../internals\";\nimport { BatchDispatch } from \"../../../utils/batch-dispatch\";\nimport { Environment } from \"../../../utils/environment\";\nimport {\n  GcpServiceAccount,\n  getTokenFromGcpServiceAccount,\n} from \"../../../utils/gcp\";\nimport { LogEntry, LogTransport } from \"../interfaces\";\nimport { LogPlugin } from \"../log-plugin\";\nimport {\n  extractBestMessage,\n  makeErrorsSerializable,\n} from \"../log-serializer-utils\";\nimport type { LoggingContext } from \"../logging-context\";\n\ninterface GoogleCloudLoggingOptions {\n  serviceAccountJson: string;\n  logName: string;\n}\n\nexport class GoogleCloudLoggingPlugin extends LogPlugin {\n  constructor(private options: GoogleCloudLoggingOptions) {\n    super();\n  }\n\n  /**\n   * @internal\n   */\n  override getTransport(): LogTransport {\n    return new GoogleLogTransport(this.options);\n  }\n}\n\nconst GCP_LOGGING_ENDPOINT =\n  \"https://logging.googleapis.com/v2/entries:write?alt=json\";\n\nexport type GCPSeverity = \"INFO\" | \"DEBUG\" | \"WARNING\" | \"ERROR\";\n\nexport interface GCPLogEntry {\n  logName: string;\n  resource: { type: string; labels?: Record<string, string> };\n  severity: GCPSeverity;\n  textPayload?: string;\n  jsonPayload?: unknown;\n  timestamp: Date;\n  labels: Record<string, string | undefined>;\n  /**\n   * Correctly parsed by GCP exclusively when sending events through their API\n   */\n  trace?: string;\n  sourceLocation?: {\n    file?: string;\n    line?: string;\n    function?: string;\n  };\n  httpRequest?: {\n    requestMethod: string;\n    requestUrl: string;\n    requestSize: string;\n    status: number;\n    responseSize: string;\n    userAgent: string;\n    remoteIp: string;\n    serverIp: string;\n    referer: string;\n    latency: string;\n    cacheLookup: boolean;\n    cacheHit: boolean;\n    cacheValidatedWithOriginServer: boolean;\n    cacheFillBytes: string;\n    protocol: string;\n  };\n}\n\nexport const ZuploToGCPMap: { [key: string]: GCPSeverity } = {\n  error: \"ERROR\",\n  warn: \"WARNING\",\n  info: \"INFO\",\n  debug: \"DEBUG\",\n};\n\n/**\n * @internal\n */\nexport class GoogleLogTransport implements LogTransport {\n  constructor(options: GoogleCloudLoggingOptions) {\n    this.#logName = options.logName;\n    this.#serviceAccountJson = options.serviceAccountJson;\n    this.#environmentType = Environment.instance.loggingEnvironmentType;\n    this.#environmentStage = Environment.instance.loggingEnvironmentStage;\n    this.#environment = Environment.instance.deploymentName;\n  }\n\n  #serviceAccountJson: string;\n  #serviceAccount: GcpServiceAccount | undefined;\n  #logName: string;\n  #environment: string | undefined;\n  #environmentType: LoggingEnvironmentType;\n  #environmentStage: LoggingEnvironmentStage;\n\n  async init(): Promise<void> {\n    this.#serviceAccount = await GcpServiceAccount.init(\n      this.#serviceAccountJson\n    );\n  }\n\n  log(logEntry: LogEntry, context: LoggingContext): void {\n    if (!this.#serviceAccount) {\n      throw new SystemError(\n        \"Invalid state - Google log transport is not initialized\"\n      );\n    }\n\n    if (logEntry.messages.length === 0) {\n      return;\n    }\n\n    const serializableEntry = {\n      allMessages: makeErrorsSerializable(logEntry.messages),\n    };\n\n    const projectID = this.#serviceAccount.projectId ?? \"zuplo-production\";\n    const gcpEntry: GCPLogEntry = {\n      logName: this.#logName,\n      resource: { type: \"global\" },\n      severity: ZuploToGCPMap[logEntry.level],\n      timestamp: logEntry.timestamp,\n      trace: `projects/${projectID}/traces/${logEntry.requestId}`,\n      labels: {\n        requestId: logEntry.requestId,\n        buildId: logEntry.buildId,\n        source: logEntry.logSource,\n        loggingId: logEntry.loggingId,\n        logOwner: logEntry.logOwner,\n        environment: this.#environment,\n        environmentType: this.#environmentType,\n        environmentStage: this.#environmentStage,\n      },\n    };\n\n    if (logEntry.rayId) {\n      gcpEntry.labels.rayId = logEntry.rayId;\n    }\n\n    const message = extractBestMessage(serializableEntry.allMessages);\n    gcpEntry.jsonPayload = { ...serializableEntry, message };\n\n    this.batcher.enqueue(gcpEntry);\n    context.waitUntil(this.batcher.waitUntilFlushed());\n  }\n\n  dispatchFunction = async (entries: GCPLogEntry[]) => {\n    if (entries.length === 0) {\n      return;\n    }\n\n    if (!this.#serviceAccount) {\n      this.#serviceAccount = await GcpServiceAccount.init(\n        this.#serviceAccountJson\n      );\n    }\n\n    const token = await getTokenFromGcpServiceAccount({\n      serviceAccount: this.#serviceAccount,\n      audience:\n        \"https://logging.googleapis.com/google.logging.v2.LoggingServiceV2\",\n    });\n\n    const result = await internals.fetch(GCP_LOGGING_ENDPOINT, {\n      method: \"POST\",\n      body: JSON.stringify({\n        entries,\n      }),\n      headers: {\n        Authorization: `Bearer ${token}`,\n        \"content-type\": \"application/json;charset=UTF-8\",\n      },\n    });\n\n    if (!result.ok) {\n      // eslint-disable-next-line no-console\n      console.error(result.status, result.statusText, await result.text());\n    }\n  };\n\n  batcher = new BatchDispatch<GCPLogEntry>(\n    \"google-log-transport\",\n    1,\n    this.dispatchFunction\n  );\n}\n", "import { LogEntry } from \"./interfaces\";\nimport {\n  extractBestMessage,\n  makeErrorsSerializable,\n} from \"./log-serializer-utils\";\nimport { GCPSeverity, ZuploToGCPMap } from \"./transports/google-transport\";\n\nexport const GCP_LOG_FORMAT = \"gcp\";\n// NOTE: GCP JSON log field format (https://cloud.google.com/logging/docs/structured-logging)\n// This will be used to correctly parse the trace field when we don't send the data via GCP logging api\nexport interface GCPStructuredLogEntry {\n  logName: string;\n  message: string;\n  severity: GCPSeverity;\n  allMessages?: unknown;\n  timestamp: Date;\n  /**\n   * labels field in GCP, the value of this field must be a structured record\n   */\n  \"logging.googleapis.com/labels\": Record<string, string>;\n  /**\n   * Resource name of the trace associated with the log entry\n   */\n  \"logging.googleapis.com/trace\"?: string;\n}\n\nexport function gcpLogFormat(logEntry: LogEntry): GCPStructuredLogEntry {\n  const serializableEntry = {\n    allMessages: makeErrorsSerializable(logEntry.messages),\n  };\n\n  const projectID = \"zuplo-production\";\n  const message = extractBestMessage(serializableEntry.allMessages);\n  const gcpEntry: GCPStructuredLogEntry = {\n    logName: `projects/${projectID}/logs/runtime-user`,\n    message,\n    severity: ZuploToGCPMap[logEntry.level],\n    timestamp: logEntry.timestamp,\n    \"logging.googleapis.com/labels\": {\n      buildId: logEntry.buildId,\n      source: logEntry.logSource,\n      loggingId: logEntry.loggingId,\n      logOwner: logEntry.logOwner,\n    },\n    \"logging.googleapis.com/trace\": `projects/${projectID}/traces/${logEntry.requestId}`,\n    allMessages: serializableEntry.allMessages,\n  };\n\n  if (logEntry.rayId) {\n    gcpEntry[\"logging.googleapis.com/labels\"].rayId = logEntry.rayId;\n  }\n  return gcpEntry;\n}\n", "/* eslint-disable no-console */\nimport { LogFormat } from \"../../interfaces\";\nimport { GCP_LOG_FORMAT, gcpLogFormat } from \"../gcp-log-format\";\nimport { LogEntry, LogTransport } from \"../interfaces\";\n\n/**\n * @internal\n */\nexport class ConsoleTransport implements LogTransport {\n  constructor(impl?: Console, format?: LogFormat) {\n    this.#impl = impl ?? console;\n    this.#format = format;\n  }\n\n  readonly #impl: Console;\n  readonly #format: LogFormat | undefined;\n\n  log(logEntry: LogEntry): void {\n    if (this.#format === GCP_LOG_FORMAT) {\n      if (logEntry.messages.length === 0) {\n        return;\n      }\n      this.#impl[logEntry.level].apply(null, [gcpLogFormat(logEntry)]);\n    } else {\n      this.#impl[logEntry.level].apply(null, [\n        ...logEntry.messages,\n        {\n          logOwner: logEntry.logOwner,\n          logSource: logEntry.logSource,\n          level: logEntry.level,\n          timestamp: logEntry.timestamp,\n          loggingId: logEntry.loggingId,\n          rayId: logEntry.rayId,\n          requestId: logEntry.requestId,\n          buildId: logEntry.buildId,\n        },\n      ]);\n    }\n  }\n}\n", "import {\n  LoggingEnvironmentStage,\n  LoggingEnvironmentType,\n} from \"../../../interfaces\";\nimport internals from \"../../../internals\";\nimport { BatchDispatch } from \"../../../utils/batch-dispatch\";\nimport { Environment } from \"../../../utils/environment\";\nimport { LogEntry, LogTransport } from \"../interfaces\";\nimport { LogPlugin } from \"../log-plugin\";\nimport {\n  extractBestMessage,\n  makeErrorsSerializable,\n} from \"../log-serializer-utils\";\nimport type { LoggingContext } from \"../logging-context\";\n\ninterface DataDogLoggingOptions {\n  url?: string;\n  apiKey: string;\n}\n\nexport class DataDogLoggingPlugin extends LogPlugin {\n  constructor(private options: DataDogLoggingOptions) {\n    super();\n  }\n\n  /**\n   * @internal\n   */\n  override getTransport(): LogTransport {\n    return new DataDogTransport(this.options);\n  }\n}\n\n/**\n * @internal\n */\ninterface DDLogEntry {\n  ddsource: string;\n  ddtags: string;\n  msg: string;\n  message: LogEntry;\n  hostname: string;\n  service: string;\n  [other: string]: unknown;\n}\n\nconst DD_TAG_PROP = \"__ddtags\";\nconst DD_ATTR_PROP = \"__ddattr\";\n\nconst cleanTagText = (text: string) => {\n  return text.replaceAll(\",\", \"_\").replaceAll(\":\", \"_\");\n};\n\nconst formatTags = (tags: Record<string, unknown>) => {\n  // ddtags takes the form \"tag1:value,tag2:value\"\n  // note that `,` and `:` are not allowed in labels or values\n  // so we will strip them.\n  const keys = Object.keys(tags);\n  const keyValuePairs: string[] = [];\n\n  keys.forEach((key) => {\n    const value = tags[key];\n    // a null tag value creates a string tag, e.g. `foo` instead of `foo:value`\n    if (value === null || value === undefined) {\n      keyValuePairs.push(cleanTagText(key));\n    } else {\n      keyValuePairs.push(\n        `${cleanTagText(key)}:${cleanTagText(value.toString())}`\n      );\n    }\n  });\n\n  return keyValuePairs.join(\",\");\n};\n\n/**\n * @internal\n */\nexport class DataDogTransport implements LogTransport {\n  constructor(options: DataDogLoggingOptions) {\n    this.#apiKey = options.apiKey;\n    this.#baseUrl =\n      options.url ?? \"https://http-intake.logs.datadoghq.com/api/v2/logs\";\n    this.#environmentType = Environment.instance.loggingEnvironmentType;\n    this.#environmentStage = Environment.instance.loggingEnvironmentStage;\n    this.#environment = Environment.instance.deploymentName;\n  }\n\n  #apiKey: string;\n  #baseUrl: string;\n  #environment: string | undefined;\n  #environmentType: LoggingEnvironmentType;\n  #environmentStage: LoggingEnvironmentStage;\n\n  log(logEntry: LogEntry, context: LoggingContext): void {\n    /**\n     * This is a temporary design until we build a full telemetry plug-in model\n     * We identify tags amongst the messages with a property __ddtags. This is also\n     * potentially present on the Context.custom property\n     */\n\n    // TAGS\n\n    // holder for tags - copy from context.custom if there are any\n    const tags = {};\n    const contextLevelTags = context.custom[DD_TAG_PROP];\n\n    if (contextLevelTags && typeof contextLevelTags === \"object\") {\n      Object.assign(tags, contextLevelTags);\n    }\n\n    // clone the array first\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const newMessages: any[] = [...logEntry.messages];\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const indexOfTags = logEntry.messages.findIndex((message: any) => {\n      return message[DD_TAG_PROP] !== undefined;\n    });\n\n    if (indexOfTags > -1) {\n      Object.assign(tags, newMessages[indexOfTags][DD_TAG_PROP]);\n      // remove that object from the messages\n      newMessages.splice(indexOfTags, 1);\n    }\n\n    // CUSTOM ATTRIBUTES\n    const attributes = {};\n    const contextLevelAttributes = context.custom[DD_ATTR_PROP];\n\n    if (contextLevelAttributes && typeof contextLevelAttributes === \"object\") {\n      Object.assign(attributes, contextLevelAttributes);\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const indexOfAttr = logEntry.messages.findIndex((message: any) => {\n      return message[DD_ATTR_PROP] !== undefined;\n    });\n\n    if (indexOfAttr > -1) {\n      Object.assign(attributes, newMessages[indexOfAttr][DD_ATTR_PROP]);\n      newMessages.splice(indexOfAttr, 1);\n    }\n\n    // Errors serialize to {} so need to do better :)\n    const serializableMessages = makeErrorsSerializable(newMessages);\n\n    // add back legacy fields to not break existing users\n    const legacyEntry = {\n      ...logEntry,\n      activityId: logEntry.requestId,\n      trace: logEntry.requestId,\n    };\n\n    const serializableEntry: DDLogEntry = {\n      message: { ...legacyEntry, messages: serializableMessages },\n      ddsource: \"Zuplo\",\n      hostname: new URL(context.originalRequest.url).hostname,\n      msg: extractBestMessage(serializableMessages),\n      service: logEntry.loggingId,\n      ddtags: formatTags(tags),\n      environment: this.#environment,\n      environment_type: this.#environmentType,\n      environment_stage: this.#environmentStage,\n    };\n\n    Object.assign(serializableEntry, attributes);\n\n    this.batcher.enqueue(serializableEntry);\n    context.waitUntil(this.batcher.waitUntilFlushed());\n  }\n\n  dispatchFunction = async (entries: DDLogEntry[]) => {\n    if (entries.length === 0) {\n      return;\n    }\n\n    await internals.fetch(this.#baseUrl, {\n      method: \"POST\",\n      body: JSON.stringify([...entries]),\n      headers: {\n        \"content-type\": \"application/json\",\n        \"DD-API-KEY\": this.#apiKey,\n      },\n    });\n  };\n\n  batcher = new BatchDispatch<DDLogEntry>(\n    \"data-dog-transport\",\n    10,\n    this.dispatchFunction\n  );\n}\n", "/* eslint-disable no-console */\n\nimport { LogFormat, Logger } from \"../../interfaces\";\nimport { GCP_LOG_FORMAT, gcpLogFormat } from \"../gcp-log-format\";\nimport { LogEntry, LogTransport } from \"../interfaces\";\n\n/**\n * @internal\n */\nexport class ProcessTransport implements LogTransport {\n  constructor(impl: Logger, format?: LogFormat) {\n    this.#impl = impl;\n    this.#format = format;\n  }\n\n  readonly #impl: Logger;\n  readonly #format: LogFormat | undefined;\n\n  log(logEntry: LogEntry): void {\n    if (this.#format === GCP_LOG_FORMAT) {\n      if (logEntry.messages.length === 0) {\n        return;\n      }\n\n      this.#impl[logEntry.level].apply(null, [gcpLogFormat(logEntry)]);\n    } else {\n      this.#impl[logEntry.level].apply(null, [\n        ...logEntry.messages,\n        {\n          logOwner: logEntry.logOwner,\n          logSource: logEntry.logSource,\n          timestamp: logEntry.timestamp,\n          loggingId: logEntry.loggingId,\n          rayId: logEntry.rayId,\n          requestId: logEntry.requestId,\n          buildId: logEntry.buildId,\n          vectorClock: logEntry.vectorClock,\n        },\n      ]);\n    }\n  }\n}\n", "import internals from \"../../../internals\";\nimport { BatchDispatch } from \"../../../utils/batch-dispatch\";\nimport { Environment } from \"../../../utils/environment\";\nimport { LogEntry, LogTransport } from \"../interfaces\";\nimport { makeErrorsSerializable } from \"../log-serializer-utils\";\nimport type { LoggingContext } from \"../logging-context\";\n\ninterface RemoteLogTransportOptions {\n  url: string;\n  remoteLogToken: string;\n  loggingId: string;\n  sendOnlyErrors: boolean;\n}\n\nconst dispatchFunction = ({\n  url,\n  remoteLogToken,\n  loggingId,\n  sendOnlyErrors,\n}: RemoteLogTransportOptions) => {\n  return async (entries: LogEntry[]) => {\n    let filteredEntries: LogEntry[];\n\n    if (sendOnlyErrors === true) {\n      filteredEntries = entries.filter((entry) => entry.level === \"error\");\n    } else {\n      filteredEntries = entries;\n    }\n\n    if (filteredEntries.length === 0) {\n      return;\n    }\n\n    try {\n      await internals.fetch(`${url}/publish/${loggingId}`, {\n        method: \"POST\",\n        body: JSON.stringify({\n          timestamp: Date.now(),\n          type: \"log\",\n          message: filteredEntries.map((entry) => {\n            return {\n              ...entry,\n              messages: makeErrorsSerializable(entry.messages),\n            };\n          }),\n        }),\n        headers: {\n          \"content-type\": \"application/json\",\n          authentication: `Bearer ${remoteLogToken}`,\n          \"user-agent\": Environment.instance.systemUserAgent,\n          \"zp-dn\": Environment.instance.deploymentName ?? \"unknown\",\n        },\n      });\n    } catch (err) {\n      // just log, use only console.error because we dont want\n      // to recursively call the logging service\n      // eslint-disable-next-line no-console\n      console.error(err);\n    }\n  };\n};\n\nlet batcher: BatchDispatch<LogEntry>;\n\n/**\n * @internal\n */\nexport class RemoteLogTransport implements LogTransport {\n  constructor(options: RemoteLogTransportOptions) {\n    if (!batcher) {\n      batcher = new BatchDispatch<LogEntry>(\n        \"remote-log-transport\",\n        1,\n        dispatchFunction(options)\n      );\n    }\n  }\n  log(logEntry: LogEntry, context: LoggingContext): void {\n    batcher.enqueue(logEntry);\n    context.waitUntil(batcher.waitUntilFlushed());\n  }\n}\n", "import { BuildEnvironment } from \"../../../interfaces\";\nimport { LogEntry } from \"../interfaces\";\nimport { UnifiedLogEntry } from \"./interfaces\";\n\nexport const SeverityNumberOpenTelemetryMap: { [key: string]: number } = {\n  internal: 1,\n  /**\n   * A fine-grained debugging event. Typically disabled in default configurations.\n   * Note: Normal range is 1-4 but we've reserved 1 for internal purposes\n   */\n  trace: 2,\n  /**\n   * A debugging event. Range 5-8\n   */\n  debug: 5,\n  /**\n   * An informational event. Indicates that an event happened. Range 9-12\n   */\n  info: 9,\n  /**\n   * A warning event. Not an error but is likely more important than an informational event.\n   * Range 13-16\n   */\n  warn: 13,\n  /**\n   * An error event. Something went wrong.\n   * Range 17-20\n   */\n  error: 17,\n  /**\n   * A fatal error such as application or system crash.\n   * Range 21-24\n   */\n  fatal: 21,\n};\n\nexport const unifiedFormatter =\n  (deploymentName: string, build: BuildEnvironment) => (logEntry: LogEntry) => {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const attributeAggregator: Record<string, any> = {};\n\n    attributeAggregator[\"deploymentName\"] = deploymentName;\n    attributeAggregator[\"labels\"] = {\n      requestId: logEntry.requestId,\n      source: logEntry.logSource,\n      loggingId: logEntry.loggingId,\n      logOwner: logEntry.logOwner,\n    };\n    attributeAggregator[\"rayId\"] = logEntry.rayId ?? \"\";\n    attributeAggregator[\"runtime\"] = {\n      buildId: build.BUILD_ID,\n      buildTimestamp: build.TIMESTAMP,\n      gitSHA: build.GIT_SHA,\n      version: build.ZUPLO_VERSION,\n    };\n    attributeAggregator[\"atomicCounter\"] = logEntry.vectorClock;\n\n    const unifiedEntry: UnifiedLogEntry = {\n      timestamp: logEntry.timestamp,\n      observerdTimestamp: logEntry.timestamp,\n      traceId: logEntry.requestId,\n      severityText: logEntry.level,\n      severityNumber: SeverityNumberOpenTelemetryMap[logEntry.level],\n      body: logEntry.messages,\n      attributes: attributeAggregator,\n    };\n    return unifiedEntry;\n  };\n", "import { BuildEnvironment } from \"../../../interfaces\";\nimport internals from \"../../../internals\";\nimport { BatchDispatch } from \"../../../utils/batch-dispatch\";\nimport { Environment } from \"../../../utils/environment\";\nimport { LogEntry, LogTransport } from \"../interfaces\";\nimport { LoggingContext } from \"../logging-context\";\nimport { unifiedFormatter } from \"./formatter\";\n\ninterface UnifiedLogTransportOptions {\n  url: string;\n  remoteLogToken: string;\n  deploymentName: string;\n  build: BuildEnvironment;\n}\nconst dispatchFunction = ({\n  url,\n  remoteLogToken,\n  deploymentName,\n  build,\n}: UnifiedLogTransportOptions) => {\n  return async (entries: LogEntry[]) => {\n    if (entries.length === 0) {\n      return;\n    }\n\n    const formatter = unifiedFormatter(deploymentName, build);\n    try {\n      await internals.fetch(`${url}/v1/runtime-logs`, {\n        method: \"POST\",\n        body: JSON.stringify({\n          entries: entries.map(formatter),\n        }),\n        headers: {\n          \"content-type\": \"application/json\",\n          authentication: `Bearer ${remoteLogToken}`,\n          \"user-agent\": Environment.instance.systemUserAgent,\n          \"zp-dn\": Environment.instance.deploymentName ?? \"unknown\",\n        },\n      });\n    } catch (err) {\n      // just log, use only console.error because we dont want\n      // to recursively call the logging service\n      // eslint-disable-next-line no-console\n      console.error(err);\n    }\n  };\n};\n\nlet batcher: BatchDispatch<LogEntry>;\n\n/**\n * @internal\n */\nexport class UnifiedLogTransport implements LogTransport {\n  constructor(options: UnifiedLogTransportOptions) {\n    if (!batcher) {\n      batcher = new BatchDispatch<LogEntry>(\n        \"unified-log-transport\",\n        1,\n        dispatchFunction(options)\n      );\n    }\n  }\n  async log(logEntry: LogEntry, context: LoggingContext): Promise<void> {\n    batcher.enqueue(logEntry);\n    context.waitUntil(batcher.waitUntilFlushed());\n  }\n}\n", "import { debug } from \"@zuplo/debug\";\nimport { SYSTEM_LOGGER } from \"../../constants\";\nimport { plugins } from \"../../extensions\";\nimport {\n  LogService,\n  ServiceProvider,\n  ZuploEventContext,\n} from \"../../interfaces\";\nimport { Environment } from \"../../utils/environment\";\nimport { CoreLogger } from \"./core-logger\";\nimport { LogTransport } from \"./interfaces\";\nimport { LogPlugin } from \"./log-plugin\";\nimport { LoggingContext } from \"./logging-context\";\nimport { RequestLogger } from \"./request-logger\";\nimport { ConsoleTransport } from \"./transports/console-transport\";\nimport { DataDogTransport } from \"./transports/data-dog-transport\";\nimport { GoogleLogTransport } from \"./transports/google-transport\";\nimport { ProcessTransport } from \"./transports/process-transport\";\nimport { RemoteLogTransport } from \"./transports/remote-log-transport\";\nimport { UnifiedLogTransport } from \"./unified-logging/transport\";\n\nconst log = debug(\"zuplo:logging\");\n\nexport class LogInitializer {\n  readonly systemCoreLogger: CoreLogger;\n  readonly userCoreLogger: CoreLogger;\n\n  private constructor({\n    systemCoreLogger,\n    userCoreLogger,\n  }: {\n    systemCoreLogger: CoreLogger;\n    userCoreLogger: CoreLogger;\n  }) {\n    this.systemCoreLogger = systemCoreLogger;\n    this.userCoreLogger = userCoreLogger;\n  }\n\n  public static async init(serviceProvider: ServiceProvider) {\n    const systemCoreLogger = await LogInitializer.setupSystemCoreLogger(\n      Environment.instance,\n      serviceProvider\n    );\n    const userCoreLogger = await LogInitializer.setupUserCoreLogger(\n      Environment.instance,\n      serviceProvider\n    );\n    return new LogInitializer({ systemCoreLogger, userCoreLogger });\n  }\n\n  private static async setupSystemCoreLogger(\n    env: Environment,\n    serviceProvider: ServiceProvider\n  ): Promise<CoreLogger> {\n    const { build } = env;\n\n    log(\"Gateway.setupSystemCoreLogger\");\n    const transports: LogTransport[] = [];\n\n    const logService = serviceProvider.getService(SYSTEM_LOGGER) as LogService;\n    if (logService) {\n      transports.push(new ProcessTransport(logService.logger, env.logFormat));\n    } else if (env.isDeno) {\n      // Console logging should not be enabled for cloudflare,\n      // we only use trace workers for catching unhandled errors\n      transports.push(new ConsoleTransport(console, env.logFormat));\n    }\n\n    if (env.isCloudflare && env.deploymentName && env.remoteLogToken) {\n      transports.push(\n        new UnifiedLogTransport({\n          url: env.remoteLogURL,\n          deploymentName: env.deploymentName,\n          remoteLogToken: env.remoteLogToken,\n          build: env.build,\n        })\n      );\n    }\n\n    // Initialize transports\n    await Promise.all(\n      transports.map(async (transport) => {\n        if (transport.init) {\n          await transport.init();\n        }\n      })\n    );\n\n    return new CoreLogger(\n      env.systemLogLevel,\n      \"system\",\n      env.loggingId,\n      build.BUILD_ID,\n      transports\n    );\n  }\n\n  private static async setupUserCoreLogger(\n    env: Environment,\n    serviceProvider: ServiceProvider\n  ): Promise<CoreLogger> {\n    log(\"Gateway.setupUserCoreLogger\");\n    const transports: LogTransport[] = [];\n    const { runtime, build } = env;\n\n    const logService = serviceProvider.getService(SYSTEM_LOGGER) as LogService;\n    if (logService && logService.captureUserLogs === true) {\n      transports.push(new ProcessTransport(logService.logger, env.logFormat));\n    } else if (env.isDeno) {\n      transports.push(new ConsoleTransport(console, env.logFormat));\n    }\n\n    if (env.remoteLogToken && env.loggingId) {\n      transports.push(\n        new RemoteLogTransport({\n          loggingId: env.loggingId,\n          url: env.remoteLogURL,\n          remoteLogToken: env.remoteLogToken,\n          sendOnlyErrors: !env.isWorkingCopy,\n        })\n      );\n    }\n\n    //\n    // Legacy Log Registrations\n    //\n    if (runtime.GCP_USER_LOG_NAME && runtime.GCP_USER_LOG_SVC_ACCT_JSON) {\n      transports.push(\n        new GoogleLogTransport({\n          serviceAccountJson: runtime.GCP_USER_LOG_SVC_ACCT_JSON,\n          logName: runtime.GCP_USER_LOG_NAME,\n        })\n      );\n    }\n    if (runtime.ZUPLO_USER_LOGGER_DATA_DOG_API_KEY) {\n      const urlOverride = runtime.ZUPLO_USER_LOGGER_DATA_DOG_URL;\n      transports.push(\n        new DataDogTransport({\n          apiKey: runtime.ZUPLO_USER_LOGGER_DATA_DOG_API_KEY,\n          url: urlOverride,\n        })\n      );\n    }\n    //\n    // End Legacy Log Registrations\n    //\n\n    // Add log transports exposed in plugins\n    plugins.forEach((plugin) => {\n      if (plugin instanceof LogPlugin) {\n        transports.push(plugin.getTransport());\n      }\n    });\n\n    // Initialize transports\n    await Promise.all(\n      transports.map(async (transport) => {\n        if (transport.init) {\n          await transport.init();\n        }\n      })\n    );\n\n    return new CoreLogger(\n      env.userLogLevel,\n      \"user\",\n      env.loggingId,\n      build.BUILD_ID,\n      transports\n    );\n  }\n\n  public createRequestLoggers(\n    requestId: string,\n    rayId: string | null,\n    event: ZuploEventContext,\n    custom: Record<string, unknown>,\n    originalRequest: Request\n  ) {\n    log(\"Gateway.createRequestLoggers\");\n    const loggingContext = new LoggingContext(event, custom, originalRequest);\n\n    const systemRequestLogger = new RequestLogger(\n      requestId,\n      rayId,\n      this.systemCoreLogger,\n      loggingContext\n    );\n\n    const userRequestLogger = new RequestLogger(\n      requestId,\n      rayId,\n      this.userCoreLogger,\n      loggingContext\n    );\n\n    return { userRequestLogger, systemRequestLogger };\n  }\n}\n", "import {\n  CorsPolicy,\n  HandlerDefinition,\n  HttpMethod,\n  ParameterDefinition,\n  ResponsesDefinition,\n  RouteConfiguration,\n} from \"./interfaces\";\n\n/**\n * @internal\n */\nexport class UserRouteConfiguration implements RouteConfiguration {\n  constructor(config: RouteConfiguration) {\n    this.path = config.path;\n    this.methods = config.methods;\n    this.label = config.label;\n    this.key = config.key;\n    this.handler = config.handler;\n    this.corsPolicy = config.corsPolicy;\n    this.custom = config.custom;\n    this.version = config.version;\n    this.policies = config.policies;\n    this.excludeFromOpenApi = config.excludeFromOpenApi;\n    this.pathPattern = config.pathPattern;\n\n    if (config.raw) {\n      this.#raw = config.raw();\n      this.operationId = this.raw()?.operationId;\n      this.summary = this.raw()?.summary;\n      this.tags = this.raw()?.tags;\n      this.parameters = this.raw()?.parameters;\n      this.responses = this.raw()?.responses;\n    } else {\n      // handle old routes.json format\n      this.operationId = config.operationId;\n      this.summary = config.summary;\n      this.tags = config.tags;\n      this.parameters = config.parameters;\n      this.responses = config.responses;\n    }\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  public raw<T = any>(): T {\n    return this.#raw;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  #raw: any;\n  public readonly label: string | undefined;\n  public readonly key: string | undefined;\n  public readonly path: string;\n  public readonly summary: string | undefined;\n  public readonly operationId?: string | undefined;\n  public readonly tags: string[] | undefined;\n  public readonly parameters: ParameterDefinition[] | undefined;\n  public readonly responses: ResponsesDefinition | undefined;\n  public readonly excludeFromOpenApi: boolean | undefined;\n  public readonly pathPattern: string | undefined;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  public readonly custom: any;\n  public readonly methods: HttpMethod[];\n  public readonly handler: HandlerDefinition;\n  public readonly corsPolicy: CorsPolicy | undefined;\n  public readonly version: string;\n  public readonly policies:\n    | { inbound?: string[]; outbound?: string[] }\n    | undefined;\n}\n", "import { ZuploContext } from \"../context\";\nimport { ConfigurationError, SystemError } from \"../errors\";\nimport { ZuploRequest } from \"../request\";\nimport {\n  BuildRouteConfiguration,\n  HttpMethod,\n  RouteConfiguration,\n  VersionData,\n} from \"./interfaces\";\nimport { SystemRouteConfiguration } from \"./system-route-configuration\";\nimport { UserRouteConfiguration } from \"./user-route-configuration\";\n\n/**\n * @beta\n */\nexport interface RouteHandler<T = unknown> {\n  (request: ZuploRequest, context: ZuploContext): Promise<T>;\n}\n\n/**\n * @beta\n */\nexport interface ErrorHandler {\n  (\n    request: ZuploRequest,\n    context: ZuploContext,\n    err: Error\n  ): Response | Promise<Response>;\n}\n\n/**\n * @internal\n */\nexport class RouterEntry<TRouteHandler extends RouteHandler = RouteHandler> {\n  constructor(\n    path: string,\n    urlPattern: URLPattern,\n    config: RouteConfiguration,\n    executableHandler: TRouteHandler\n  ) {\n    this.fullPath = path;\n    this.urlPattern = urlPattern;\n    this.config = config;\n    this.executableHandler = executableHandler;\n  }\n\n  fullPath: string;\n  urlPattern: URLPattern;\n  config: RouteConfiguration;\n  executableHandler: TRouteHandler;\n}\n\n/**\n * @internal\n */\nexport class LookupResult<TRouteHandler extends RouteHandler = RouteHandler> {\n  constructor(\n    routeConfiguration: RouteConfiguration,\n    executableHandler: TRouteHandler,\n    params?: Record<string, string>\n  ) {\n    this.routeConfiguration = routeConfiguration;\n    this.params = params ?? {};\n    this.executableHandler = executableHandler;\n  }\n  executableHandler: TRouteHandler;\n  routeConfiguration: RouteConfiguration;\n  params: Record<string, string>;\n}\n\n/**\n * @internal\n */\nexport class RouterError extends Error {\n  constructor(message?: string | undefined, options?: ErrorOptions) {\n    super(message, options);\n  }\n}\n\n/**\n * @internal\n */\nexport class Router<TRouteHandler extends RouteHandler = RouteHandler> {\n  constructor(versions: VersionData[]) {\n    this.routeEntries = [];\n    this.versions = versions;\n  }\n\n  versions: VersionData[];\n  routeEntries: RouterEntry<TRouteHandler>[];\n  addRoute<T extends BuildRouteConfiguration>(\n    config: T,\n    executableHandler: TRouteHandler\n  ): void {\n    if (\n      !(\n        config instanceof UserRouteConfiguration ||\n        config instanceof SystemRouteConfiguration\n      )\n    ) {\n      throw new SystemError(\n        \"Config must be a UserRouteConfiguration or SystemRouteConfiguration\"\n      );\n    }\n    const prefix = this.versions.find((v) => v.name === config.version)\n      ?.pathPrefix;\n    let fullPath;\n    if (\"pathPattern\" in config && config.pathPattern) {\n      // Prefer the pathPattern if it is set\n      // Because that is the one that is properly transformed for use by URLPattern\n      fullPath = `${prefix ?? \"\"}${config.pathPattern}`;\n    } else {\n      fullPath = `${prefix ?? \"\"}${config.path}`;\n    }\n    try {\n      const urlPattern = new URLPattern({ pathname: fullPath });\n      const route = new RouterEntry<TRouteHandler>(\n        fullPath,\n        urlPattern,\n        config,\n        executableHandler\n      );\n      // Note: This only freezes the top level to prevent some basic user\n      // errors, we dont freeze everything here because it takes a LONG\n      // time on large APIs with lots of routes.\n      Object.freeze(route.config);\n\n      this.routeEntries.push(route);\n    } catch (err) {\n      throw new RouterError(\n        `addRoute-error: Invalid path '${fullPath}'. '${err.message}'`,\n        { cause: err }\n      );\n    }\n  }\n\n  lookup(\n    method: HttpMethod,\n    path: string\n  ): LookupResult<TRouteHandler> | undefined {\n    if (typeof method === \"undefined\") {\n      throw new ConfigurationError(\n        `Invalid request - Method was undefined. Path: '${path}'`\n      );\n    }\n\n    // first match on method (fastest)\n    const methodMatches = this.routeEntries.filter((re) =>\n      re.config.methods.includes(method)\n    );\n\n    if (methodMatches.length === 0) {\n      return;\n    }\n\n    for (let i = 0; i < methodMatches.length; i++) {\n      const routeEntry = methodMatches[i];\n      const pattern = routeEntry.urlPattern;\n      const m = pattern.exec({ pathname: path });\n      if (m !== null) {\n        const result = new LookupResult<TRouteHandler>(\n          routeEntry.config,\n          routeEntry.executableHandler,\n          m.pathname.groups as Record<string, string>\n        );\n        return result;\n      }\n    }\n\n    return undefined;\n  }\n\n  // Used by API test console and Route Tester\n  lookupByPathOnly(path: string): LookupResult<TRouteHandler>[] {\n    const results = [];\n    for (let i = 0; i < this.routeEntries.length; i++) {\n      const routeEntry = this.routeEntries[i];\n      const pattern = routeEntry.urlPattern;\n      const m = pattern.exec({ pathname: path });\n      if (m !== null) {\n        const result = new LookupResult<TRouteHandler>(\n          routeEntry.config,\n          routeEntry.executableHandler,\n          m.pathname.groups as Record<string, string>\n        );\n        results.push(result);\n      }\n    }\n    return results;\n  }\n}\n", "/**\n * We need a to grab a handy waitUntil function from the global context\n * without passing ZuploContext around everywhere. We have the gateway update this with\n * every request because waitUntil is safe to use across requests;\n */\n\nimport { ZuploEventContext } from \"../interfaces\";\n\nlet _event: ZuploEventContext;\n\nexport function setGlobalZuploEventContext(event: ZuploEventContext) {\n  _event = event;\n}\n\nexport function getGlobalZuploEventContext(): ZuploEventContext {\n  if (_event === undefined) {\n    throw new Error(\n      \"global ZuploEventContext has not been defined - invalid runtime state\"\n    );\n  }\n  return _event;\n}\n", "import {\n  DISPATCH_HEADERS_TO_REMOVE,\n  INTERNAL_HEADERS_TO_REMOVE,\n  VENDOR_HEADERS_TO_ALLOW,\n  VENDOR_HEADER_PREFIXES,\n  X_REAL_IP_HEADER,\n} from \"../constants\";\n\nexport function normalizeIncomingRequestHeaders({\n  headers,\n  removeAllVendorHeadersExceptListed,\n  isDeno,\n}: {\n  headers: Headers;\n  removeAllVendorHeadersExceptListed: boolean;\n  isDeno: boolean;\n}) {\n  const outputHeaders = new Headers(headers);\n  if (removeAllVendorHeadersExceptListed) {\n    // After the compatibility date, we remove all zp and cf headers except\n    // those specifically allowed\n    for (const [key] of headers) {\n      const prefix = key.substring(0, 3);\n      if (\n        VENDOR_HEADER_PREFIXES.includes(prefix.toLowerCase()) &&\n        !VENDOR_HEADERS_TO_ALLOW.includes(key.toLowerCase())\n      ) {\n        outputHeaders.delete(key);\n      }\n    }\n    outputHeaders.delete(X_REAL_IP_HEADER);\n  } else {\n    // Remove the dispatch headers that where added to\n    // the incomingRequestProperties object\n    DISPATCH_HEADERS_TO_REMOVE.forEach((key) => {\n      outputHeaders.delete(key);\n    });\n  }\n  if (isDeno) {\n    // When running in working copy, remove some of the\n    // internal headers like envoy, fly, etc.\n    INTERNAL_HEADERS_TO_REMOVE.forEach((key) => {\n      outputHeaders.delete(key);\n    });\n  }\n  return outputHeaders;\n}\n", "import { trace } from \"@opentelemetry/api\";\nimport { debug } from \"@zuplo/debug\";\nimport { registerBuildRoute } from \"./built-in-routes/build-route\";\nimport { registerCorsRoute } from \"./built-in-routes/cors-route\";\nimport { registerNoRoutes } from \"./built-in-routes/no-routes\";\nimport {\n  notFoundRouteConfiguration,\n  registerNotMatchedHandler,\n} from \"./built-in-routes/not-found-route\";\nimport { registerPingRoute } from \"./built-in-routes/ping-route\";\nimport { BODY_REMOVED_HEADER, REQUEST_ID_HEADER } from \"./constants\";\nimport {\n  HeaderIncomingRequestProperties,\n  SystemZuploContext,\n  ZuploContext,\n  ZuploContextExtensions,\n} from \"./context\";\nimport {\n  registerDevPortalLegacyRedirectRoute,\n  registerDevPortalV3Route,\n} from \"./dev-portal/routes-v3\";\nimport { SemanticAttributes } from \"./diagnostics/attributes\";\nimport { ConfigurationError, RuntimeError, SystemError } from \"./errors\";\nimport {\n  invokeOnRequestExtensions,\n  plugins,\n  runtimeExtensions,\n} from \"./extensions\";\nimport {\n  RequestContext,\n  RequestProcessor,\n  RuntimeSettings,\n  ServiceProvider,\n  ValidateFunction,\n  ZuploEventContext,\n} from \"./interfaces\";\nimport { LogInitializer } from \"./logging/v1/log-initializer\";\nimport { Pipeline } from \"./pipeline\";\nimport { SystemRuntimePlugin } from \"./plugins/plugins\";\nimport { HttpProblems } from \"./problem-responses/http-problems\";\nimport { corsProcessor } from \"./processors/cors-processor\";\nimport { metricsProcessor } from \"./processors/metrics-processor\";\nimport { policyProcessor } from \"./processors/policy-processor\";\nimport { ZuploRequest } from \"./request\";\nimport {\n  HttpMethod,\n  ParsedRouteData,\n  RouteData,\n  VersionData,\n} from \"./router/interfaces\";\nimport {\n  ErrorHandler,\n  LookupResult,\n  RouteHandler,\n  Router,\n} from \"./router/router\";\nimport { systemNoVersion } from \"./router/system-route-configuration\";\nimport { UserRouteConfiguration } from \"./router/user-route-configuration\";\nimport { SystemLogMap } from \"./system-log-map\";\nimport { parseCorsPolicies } from \"./utils/cors\";\nimport { Environment } from \"./utils/environment\";\nimport { setGlobalZuploEventContext } from \"./utils/global-zuplo-event-context\";\nimport { normalizeIncomingRequestHeaders } from \"./utils/normalize-headers\";\nimport { cleanStack, serializeError } from \"./utils/serialize-error\";\nimport { isSystemRoute } from \"./utils/system-routes\";\n\nconst log = debug(\"zuplo:runtime\");\n/**\n *\n * @param versions - VersionData[]\n * We must have a 'root' with no version for use by the built-in routes. This is added with\n * the name __system_root and is overwrites any route with the same name. A root with the same name is most\n * likely user shenanigans so that is fine. This prevents errors where an invalid root version can cause\n * all routes not to be matched and create system errors.\n */\nconst setupSystemNoVersion = (versions: VersionData[]) => {\n  const index = versions.findIndex((v) => v.name === systemNoVersion.name);\n  if (index > -1) {\n    const newVersions = versions.splice(index);\n    return [...newVersions, systemNoVersion];\n  }\n  return [...versions, systemNoVersion];\n};\n\n/**\n * @internal\n */\nexport class Gateway {\n  // gateway is stored at the module level and lazily created on the first request\n  // cloudflare doesn't like many function calls (crypto, date ) outside of a request\n  static #instance: Gateway | undefined;\n\n  private constructor(\n    public routeData: ParsedRouteData,\n    public runtimeSettings: RuntimeSettings,\n    logInitializer: LogInitializer,\n    public schemaValidator: Record<string, ValidateFunction>\n  ) {\n    log(\"Gateway.constructor\");\n    SemanticAttributes;\n    this.#router = this.setupRoutes();\n    this.#errorHandler = this.setupErrorHandler();\n    this.#logInitializer = logInitializer;\n  }\n\n  public static async initialize(\n    routeLoader: () => RouteData,\n    runtimeSettings: RuntimeSettings,\n    serviceProvider: ServiceProvider,\n    schemaValidator: Record<string, ValidateFunction>\n  ): Promise<Gateway> {\n    log(\"Gateway.initialize\");\n\n    if (!Gateway.#instance) {\n      const tracer = trace.getTracer(\"gateway\");\n      // This must happen after initializeRuntime because that is where\n      // the plugins get setup. So we can't actually instrument that step.\n      await tracer.startActiveSpan(\n        \"gateway:initialize\",\n        {\n          attributes: {\n            [SemanticAttributes.SystemTrace]: true,\n          },\n        },\n        async (span) => {\n          try {\n            const logInitializer = await LogInitializer.init(serviceProvider);\n\n            const routeData = routeLoader();\n\n            // Convert the raw used written route data to validated data\n            const parsedRouteData: ParsedRouteData = {\n              ...routeData,\n              corsPolicies: parseCorsPolicies(routeData.corsPolicies),\n            };\n            const gateway = new Gateway(\n              parsedRouteData,\n              runtimeSettings,\n              logInitializer,\n              schemaValidator\n            );\n\n            Gateway.#instance = gateway;\n          } finally {\n            span.end();\n          }\n        }\n      );\n    }\n\n    if (!Gateway.#instance) {\n      throw new SystemError(\n        \"Invalid state - Gateway not initialized after trace call. The trace provider is likely not functioning correctly.\"\n      );\n    }\n\n    return Gateway.#instance;\n  }\n\n  public static purgeGatewayCache() {\n    log(\"Gateway.purgeGatewayCache\");\n    Gateway.#instance = undefined;\n  }\n\n  static get instance(): Gateway {\n    if (!Gateway.#instance) {\n      throw new SystemError(\"Gateway cannot be used before it is initialized\");\n    }\n    return Gateway.#instance;\n  }\n\n  readonly #logInitializer: LogInitializer;\n  readonly #router: Router;\n  readonly #processors: RequestProcessor[] = [\n    policyProcessor,\n    corsProcessor,\n    metricsProcessor,\n  ];\n  readonly #errorHandler: ErrorHandler;\n\n  setupRoutes = (): Router<RouteHandler> => {\n    log(\"Gateway.setupRoutes\");\n    const routeData = this.routeData;\n    const versions = setupSystemNoVersion(routeData.versions);\n    const router = new Router(versions);\n\n    // Handle project with no routes\n    if (routeData.routes.length === 0) {\n      registerBuildRoute(router, this);\n      registerPingRoute(router, this);\n\n      registerCorsRoute(router, this);\n\n      registerNoRoutes(router, this);\n      return router;\n    }\n\n    const { enabled } = this.runtimeSettings.developerPortal;\n    if (enabled) {\n      registerDevPortalLegacyRedirectRoute(router, this);\n      registerDevPortalV3Route(router, this);\n    }\n\n    registerBuildRoute(router, this);\n    registerPingRoute(router, this);\n\n    registerCorsRoute(router, this);\n\n    // Register plugin routes\n    for (const plugin of plugins) {\n      if (plugin instanceof SystemRuntimePlugin) {\n        plugin.registerRoutes(router, this);\n      }\n    }\n\n    routeData.routes.forEach((route) => {\n      let innerHandler: RouteHandler | undefined;\n\n      if (typeof route.handler?.module === \"object\") {\n        innerHandler = route.handler?.module[route.handler.export];\n      }\n\n      // prevents build error as code assumes innerHandler can be undefined\n      // (it cannot because of the check above)\n      if (typeof innerHandler !== \"function\") {\n        throw new ConfigurationError(\n          `Invalid state - No handler on route for path '${route.path}'`\n        );\n      }\n\n      const pipeline = new Pipeline({\n        processors: this.#processors,\n        handler: innerHandler,\n        gateway: this,\n      });\n      const userConfigRoute = new UserRouteConfiguration(route);\n\n      router.addRoute(userConfigRoute, pipeline.execute);\n    });\n\n    registerNotMatchedHandler(router, this);\n\n    return router;\n  };\n\n  setupErrorHandler = () => {\n    let errorHandler: ErrorHandler;\n    if (typeof this.routeData.requestErrorHandler?.module === \"object\") {\n      errorHandler =\n        this.routeData.requestErrorHandler.module[\n          this.routeData.requestErrorHandler.export\n        ];\n\n      if (typeof errorHandler !== \"function\") {\n        throw new ConfigurationError(\n          `Invalid state - Module and export set for 'errorHandler' is not a function`\n        );\n      }\n    } else {\n      // No user handler, just use default\n      errorHandler = (request, context, err) =>\n        this.#internalErrorResponse(request, context, err);\n    }\n    return errorHandler;\n  };\n\n  errorHandler(request: ZuploRequest, context: ZuploContext, error: Error) {\n    try {\n      return this.#errorHandler(request, context, error);\n    } catch (err) {\n      log(\"An error occurred in the user's errorHandler\", err);\n      return this.#internalErrorResponse(request, context, err);\n    }\n  }\n\n  #internalErrorResponse(\n    request: ZuploRequest,\n    context: ZuploContext,\n    error: Error\n  ) {\n    log(\"Gateway.internalErrorResponse\");\n\n    let extensionMembers: Record<string, unknown> = {};\n    if (Environment.instance.isWorkingCopy) {\n      // Only showing extra stuff local and in working copy for now\n      if (error instanceof RuntimeError && error.extensionMembers) {\n        extensionMembers = error.extensionMembers;\n      } else if (error.cause) {\n        const cause = serializeError(error.cause);\n        if (\"stack\" in cause) {\n          cause.stack = cleanStack(cause.stack);\n        }\n        extensionMembers = {\n          cause,\n        };\n      }\n    }\n\n    return HttpProblems.internalServerError(request, context, {\n      detail: error.message,\n      ...extensionMembers,\n    });\n  }\n\n  async handleRequest(\n    originalRequest: Request,\n    requestContext: RequestContext,\n    event: ZuploEventContext\n  ): Promise<Response> {\n    const { requestId, rayId } = requestContext;\n    // set the global waitUntil for use by internal libs\n    setGlobalZuploEventContext(event);\n\n    const normalizedHeaders = normalizeIncomingRequestHeaders({\n      headers: originalRequest.headers,\n      removeAllVendorHeadersExceptListed:\n        Environment.instance.build.COMPATIBILITY_FLAGS\n          .removeAllVendorHeadersExceptListed,\n      isDeno: Environment.instance.isDeno,\n    });\n\n    // Make sure the requestId header is set\n\n    normalizedHeaders.set(REQUEST_ID_HEADER, requestId);\n\n    let mutableRequest = new Request(originalRequest, {\n      headers: normalizedHeaders,\n    });\n\n    // If a GET or HEAD method comes in with a body\n    // we clear it and set a header to inform the origin\n    if (\n      [\"GET\", \"HEAD\"].includes(mutableRequest.method) &&\n      mutableRequest.body\n    ) {\n      const headers = new Headers(mutableRequest.headers);\n      headers.set(BODY_REMOVED_HEADER, \"true\");\n      mutableRequest = new Request(mutableRequest, {\n        headers,\n        body: null,\n      });\n    }\n\n    // The custom property is shared with the loggers on logging context\n    const custom: Record<string, unknown> = {};\n\n    const { userRequestLogger, systemRequestLogger } =\n      this.#logInitializer.createRequestLoggers(\n        requestId,\n        rayId,\n        event,\n        custom,\n        mutableRequest\n      );\n\n    const url = new URL(mutableRequest.url);\n    const path = url.pathname;\n\n    const routeMatch = this.#router.lookup(\n      mutableRequest.method as HttpMethod,\n      path\n    );\n\n    if (!routeMatch) {\n      throw new SystemError(\n        `Invalid state - no route match - should have been picked up by the not found handler, path: '${path}'`\n      );\n    }\n\n    const incomingRequestProperties = new HeaderIncomingRequestProperties(\n      // IMPORTANT: This uses the original request because we read the request\n      // props lazily, but they get stripped out of the mutableRequest when\n      // the #normalizeIncomingRequest function runs\n      originalRequest.headers\n    );\n\n    let zuploRequest = new ZuploRequest(mutableRequest, {\n      params: routeMatch.params,\n    });\n\n    const zuploContext = new SystemZuploContext({\n      logger: userRequestLogger,\n      route: routeMatch.routeConfiguration,\n      requestId,\n      event,\n      custom,\n      incomingRequestProperties,\n    });\n\n    const rawRoute = routeMatch.routeConfiguration.raw<{\n      operationId?: string;\n      [\"x-zuplo-trace\"]?: boolean;\n    }>();\n\n    trace.getActiveSpan()?.setAttributes({\n      \"http.route\": zuploContext.route.path ?? zuploContext.route.pathPattern,\n      \"cloud.region\": zuploContext.incomingRequestProperties.colo,\n      [SemanticAttributes.RoutePathPattern]: zuploContext.route.pathPattern,\n      [SemanticAttributes.RouteOperationId]: rawRoute.operationId,\n      [SemanticAttributes.RouteTrace]: rawRoute[`x-zuplo-trace`],\n      [SemanticAttributes.RouteSystem]: isSystemRoute(url) ? true : undefined,\n    });\n\n    const ext = ZuploContextExtensions.initialize(zuploContext, zuploRequest);\n\n    // Only worth running this code if a custom notFoundHandler is specified\n    if (\n      routeMatch.routeConfiguration === notFoundRouteConfiguration &&\n      runtimeExtensions.value?.notFoundHandler !== undefined\n    ) {\n      // This is the not found handler, let's find other matching paths\n      const otherMatches = this.#router.lookupByPathOnly(path);\n      // Only show User Routes - not System Routes\n      ext.pathOnlyMatches = otherMatches\n        .map((m) => m.routeConfiguration)\n        .filter((m) => m instanceof UserRouteConfiguration);\n    }\n\n    try {\n      SystemLogMap.addLogger(zuploContext, systemRequestLogger);\n\n      // Before this flag hooks didn't run on routes that start with __zuplo\n      // after the flag, hooks don't run on any system route.\n      if (\n        Environment.instance.build.COMPATIBILITY_FLAGS\n          .doNotRunHooksOnSystemRoutes\n          ? !isSystemRoute(url)\n          : !url.pathname.startsWith(\"/__zuplo\")\n      ) {\n        const onRequestHookResult = await invokeOnRequestExtensions(\n          zuploRequest,\n          zuploContext\n        );\n        if (onRequestHookResult instanceof Response) {\n          return onRequestHookResult;\n        } else {\n          const ext = ZuploContextExtensions.getContextExtensions(zuploContext);\n          zuploRequest = onRequestHookResult;\n          ext.latestRequest = zuploRequest;\n        }\n      }\n\n      if (!isSystemRoute(url)) {\n        userRequestLogger.debug(`Request received '${url.pathname}'`, {\n          method: mutableRequest.method,\n          url: url.pathname,\n          hostname: url.hostname,\n          route: routeMatch.routeConfiguration.path,\n        });\n      }\n\n      const handler = routeMatch.executableHandler;\n      checkHandler(handler, routeMatch, mutableRequest);\n\n      log(\"Gateway.handleRequest - call user handler\");\n      const response = await handler(zuploRequest, zuploContext);\n      log(\"Gateway.handleRequest - user handler\");\n\n      if (!(response instanceof Response)) {\n        throw new RuntimeError(\n          `Invalid Response type from the request handler: ${typeof response}`\n        );\n      }\n\n      // On CloudFlare we have to check if the user accidentally used the body to avoid\n      // an unhandled error deeper in the stack than we can handle.\n      if (response.bodyUsed) {\n        throw new RuntimeError(\n          \"The response object has already been used. Return a new response instead.\"\n        );\n      }\n\n      // Ensure request id is always on the response\n      // NOTE: Headers might mess up websockets so we dont apply this in the\n      // case that the response is a websocket\n      let newResponse: Response;\n      if (\n        response.headers.get(REQUEST_ID_HEADER) === null &&\n        !response.webSocket\n      ) {\n        const headers = new Headers(response.headers);\n        headers.set(REQUEST_ID_HEADER, requestId);\n        newResponse = new Response(response.body, {\n          status: response.status,\n          statusText: response.statusText,\n          headers,\n          cf: response.cf,\n        });\n      } else {\n        newResponse = response;\n      }\n      return newResponse;\n    } catch (err) {\n      log(\"Gateway - error executing handler\", err);\n      // Write error to the user, they are generally caused\n      // by invalid configurations in the routes.json, etc.\n      // Write warnings to the system logger as this might be useful\n      // for debugging, etc.\n      if (err instanceof RuntimeError) {\n        userRequestLogger.error(err);\n        systemRequestLogger.warn(err);\n      } else {\n        // Other errors should not happen and are logged as system errors\n        systemRequestLogger.error(err);\n      }\n      return await this.#internalErrorResponse(zuploRequest, zuploContext, err);\n    }\n  }\n}\n\nfunction checkHandler(\n  handler: RouteHandler,\n  routeMatch: LookupResult<RouteHandler>,\n  request: Request\n) {\n  log(\"Gateway.checkHandler\");\n  if (!handler) {\n    if (typeof routeMatch.routeConfiguration === \"undefined\") {\n      throw new ConfigurationError(\n        `Invalid state - no routeConfiguration for '${request.method}:${request.url}`\n      );\n    }\n    throw new ConfigurationError(\n      `Invalid state. No handler for request '${request.method}':'${routeMatch.routeConfiguration.path}'`\n    );\n  }\n}\n", "import { ZuploContext } from \"./context\";\nimport { RuntimeError } from \"./errors\";\nimport { Gateway } from \"./gateway\";\nimport { getInboundPolicyInstances } from \"./processors/policy-processor\";\nimport { ZuploRequest } from \"./request\";\n\nexport const invokeInboundPolicy = async (\n  policyName: string,\n  request: ZuploRequest,\n  context: ZuploContext\n) => {\n  const policies = Gateway.instance.routeData.policies;\n  const matchingPolicies = getInboundPolicyInstances([policyName], policies);\n\n  if (matchingPolicies.length === 0) {\n    throw new RuntimeError(\n      `Invalid 'invokeInboundPolicy call' - no policy '${policyName}' found.`\n    );\n  }\n\n  const policy = matchingPolicies[0];\n\n  return policy.handler(request, context);\n};\n\n// TODO - add InvokeOutboundPolicy;\n", "import {\n  CF_IP_CITY_HEADER,\n  CF_IP_CONTINENT_HEADER,\n  CF_IP_COUNTRY_HEADER,\n  CF_IP_LATITUDE_HEADER,\n  CF_IP_LONGITUDE_HEADER,\n  CF_IP_REGION_HEADER,\n  CF_METRO_CODE_HEADER,\n  CF_POSTAL_CODE_HEADER,\n  CF_REGION_CODE_HEADER,\n  CF_TIMEZONE_HEADER,\n  ZP_ASN_HEADER,\n  ZP_AS_ORG_HEADER,\n  ZP_COLO_HEADER,\n  ZP_IP_CITY_HEADER,\n  ZP_IP_CONTINENT_HEADER,\n  ZP_IP_COUNTRY_HEADER,\n  ZP_IP_LATITUDE_HEADER,\n  ZP_IP_LONGITUDE_HEADER,\n  ZP_METRO_CODE_HEADER,\n  ZP_POSTAL_CODE_HEADER,\n  ZP_REGION_CODE_HEADER,\n  ZP_REGION_HEADER,\n  ZP_TIMEZONE_HEADER,\n} from \"./constants\";\nimport { RuntimeError } from \"./errors\";\nimport {\n  OnResponseSendingFinalHook,\n  OnResponseSendingHook,\n} from \"./extensions\";\nimport { WaitUntilFunc, ZuploEventContext } from \"./interfaces\";\nimport { invokeInboundPolicy } from \"./invoke-policy\";\nimport { Logger } from \"./logging/interfaces\";\nimport { ZuploRequest } from \"./request\";\nimport { RouteConfiguration } from \"./router/interfaces\";\n\nexport interface IncomingRequestProperties {\n  /**\n   * ASN of the incoming request, for example, 395747.\n   */\n  readonly asn: number | undefined;\n\n  /**\n   * The organization which owns the ASN of the incoming request,\n   * for example, Google Cloud.\n   */\n  readonly asOrganization: string | undefined;\n\n  /**\n   * City of the incoming request, for example, \"Austin\".\n   */\n  readonly city: string | undefined;\n\n  /**\n   * Continent of the incoming request, for example, \"NA\".\n   */\n  readonly continent: ContinentCode | undefined;\n  /**\n   * The two-letter country code in the request.\n   * @see {@link https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2|ISO 3166-1 alpha-2}\n   */\n  readonly country: Iso3166Alpha2Code | undefined;\n\n  /**\n   * Latitude of the incoming request, for example, \"30.27130\".\n   */\n  readonly latitude: string | undefined;\n\n  /**\n   * Longitude of the incoming request, for example, \"-97.74260\".\n   */\n  readonly longitude: string | undefined;\n\n  /**\n   * The three-letter IATA airport code of the data center that the request hit,\n   * for example, \"DFW\".\n   * @see {@link https://en.wikipedia.org/wiki/IATA_airport_code|IATA airport code}\n   */\n  readonly colo: string | undefined;\n\n  /**\n   * Postal code of the incoming request, for example, \"78701\".\n   */\n  readonly postalCode: string | undefined;\n\n  /**\n   * Metro code (DMA) of the incoming request, for example, \"635\".\n   */\n  readonly metroCode: string | undefined;\n\n  /**\n   * If known, the ISO 3166-2 name for the first level region associated with\n   * the IP address of the incoming request, for example, \"Texas\".\n   * @see {@link https://en.wikipedia.org/wiki/ISO_3166-2|ISO 3166-2}\n   */\n  readonly region: string | undefined;\n\n  /**\n   * If known, the ISO 3166-2 code for the first-level region associated with\n   * the IP address of the incoming request, for example, \"TX\".\n   * @see {@link https://en.wikipedia.org/wiki/ISO_3166-2|ISO 3166-2}\n   */\n  readonly regionCode: string | undefined;\n\n  /**\n   * Timezone of the incoming request, for example, \"America/Chicago\".\n   */\n  readonly timezone: string | undefined;\n}\n\nexport class HeaderIncomingRequestProperties\n  implements IncomingRequestProperties\n{\n  #headers: Headers;\n\n  constructor(headers: Headers) {\n    this.#headers = headers;\n  }\n\n  get asn(): number | undefined {\n    try {\n      const asn = this.#headers.get(ZP_ASN_HEADER);\n      if (typeof asn === \"string\") {\n        return parseInt(asn);\n      }\n    } catch (err) {\n      // Ignore\n    }\n  }\n\n  get asOrganization(): string | undefined {\n    return this.#headers.get(ZP_AS_ORG_HEADER) ?? undefined;\n  }\n\n  get city(): string | undefined {\n    return (\n      this.#headers.get(CF_IP_CITY_HEADER) ??\n      this.#headers.get(ZP_IP_CITY_HEADER) ??\n      undefined\n    );\n  }\n\n  get continent(): ContinentCode | undefined {\n    return (\n      (this.#headers.get(CF_IP_CONTINENT_HEADER) as ContinentCode | null) ??\n      (this.#headers.get(ZP_IP_CONTINENT_HEADER) as ContinentCode | null) ??\n      undefined\n    );\n  }\n\n  get country(): Iso3166Alpha2Code | undefined {\n    return (\n      (this.#headers.get(CF_IP_COUNTRY_HEADER) as Iso3166Alpha2Code | null) ??\n      (this.#headers.get(ZP_IP_COUNTRY_HEADER) as Iso3166Alpha2Code | null) ??\n      undefined\n    );\n  }\n\n  get latitude(): string | undefined {\n    return (\n      this.#headers.get(CF_IP_LATITUDE_HEADER) ??\n      this.#headers.get(ZP_IP_LATITUDE_HEADER) ??\n      undefined\n    );\n  }\n\n  get longitude(): string | undefined {\n    return (\n      this.#headers.get(CF_IP_LONGITUDE_HEADER) ??\n      this.#headers.get(ZP_IP_LONGITUDE_HEADER) ??\n      undefined\n    );\n  }\n\n  get colo(): string | undefined {\n    return this.#headers.get(ZP_COLO_HEADER) ?? undefined;\n  }\n\n  get postalCode(): string | undefined {\n    return (\n      this.#headers.get(CF_POSTAL_CODE_HEADER) ??\n      this.#headers.get(ZP_POSTAL_CODE_HEADER) ??\n      undefined\n    );\n  }\n\n  get metroCode(): string | undefined {\n    return (\n      this.#headers.get(CF_METRO_CODE_HEADER) ??\n      this.#headers.get(ZP_METRO_CODE_HEADER) ??\n      undefined\n    );\n  }\n\n  get region(): string | undefined {\n    return (\n      this.#headers.get(CF_IP_REGION_HEADER) ??\n      this.#headers.get(ZP_REGION_HEADER) ??\n      undefined\n    );\n  }\n\n  get regionCode(): string | undefined {\n    return (\n      this.#headers.get(CF_REGION_CODE_HEADER) ??\n      this.#headers.get(ZP_REGION_CODE_HEADER) ??\n      undefined\n    );\n  }\n\n  get timezone(): string | undefined {\n    return (\n      this.#headers.get(CF_TIMEZONE_HEADER) ??\n      this.#headers.get(ZP_TIMEZONE_HEADER) ??\n      undefined\n    );\n  }\n\n  toJSON() {\n    const obj: IncomingRequestProperties = {\n      asn: this.asn,\n      asOrganization: this.asOrganization,\n      city: this.city,\n      continent: this.continent,\n      country: this.country,\n      latitude: this.latitude,\n      longitude: this.longitude,\n      colo: this.colo,\n      postalCode: this.postalCode,\n      metroCode: this.metroCode,\n      region: this.region,\n      regionCode: this.regionCode,\n      timezone: this.timezone,\n    };\n    return obj;\n  }\n}\n\n/**\n * @beta\n */\nexport interface ZuploContext extends EventTarget {\n  /**\n   * The unique identifier of the incoming request\n   */\n  readonly requestId: Readonly<string>;\n  /**\n   * Request based logger\n   */\n  readonly log: Readonly<Logger>;\n  readonly route: Readonly<RouteConfiguration>;\n  /**\n   * Custom data stored on the ZuploContext\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  readonly custom: Record<string, any>;\n  readonly incomingRequestProperties: IncomingRequestProperties;\n  readonly invokeInboundPolicy: (\n    policyName: string,\n    request: ZuploRequest\n  ) => Promise<Response | ZuploRequest>;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  readonly waitUntil: WaitUntilFunc;\n\n  /**\n   * Fires just before the response is sent. Response can be modified.\n   */\n  readonly addResponseSendingHook: (hook: OnResponseSendingHook) => void;\n\n  /**\n   * Fires immediately after the response is sent. Response cannot be modified.\n   */\n  readonly addResponseSendingFinalHook: (\n    hook: OnResponseSendingFinalHook\n  ) => void;\n\n  /**\n   * Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.\n   *\n   * The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.\n   *\n   * When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.\n   *\n   * When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in \u00A7 2.8 Observing event listeners.\n   *\n   * When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.\n   *\n   * If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.\n   *\n   * The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.\n   * @deprecated This will be removed in the future. Use hooks instead. See {@link https://zuplo.com/docs/articles/runtime-extensions}\n   */\n  addEventListener<Type extends keyof Record<string, Event>>(\n    type: Type,\n    handler: EventListenerOrEventListenerObject,\n    options?: AddEventListenerOptions | boolean\n  ): void;\n\n  /**\n   * @deprecated This will be removed in the future. See {@link https://zuplo.com/docs/articles/runtime-extensions}\n   */\n  removeEventListener<Type extends keyof Record<string, Event>>(\n    type: Type,\n    handler: EventListenerOrEventListenerObject,\n    options?: AddEventListenerOptions | boolean\n  ): void;\n}\n\nexport type ZuploRewriteContext = Omit<\n  ZuploContext,\n  | \"log\"\n  | \"invokeInboundPolicy\"\n  | \"waitUntil\"\n  | \"addEventListener\"\n  | \"removeEventListener\"\n  | \"dispatchEvent\"\n  | \"addResponseSendingFinalHook\"\n  | \"addResponseSendingHook\"\n>;\n\n// These two are very similar but it's clearer to create a type for each\nexport type ZuploForwardContext = ZuploRewriteContext;\n\n/**\n * @beta\n */\nexport class ResponseSendingEvent extends Event {\n  constructor(request: ZuploRequest, response: Response) {\n    super(\"responseSending\");\n    this.request = request;\n    this.mutableResponse = response;\n  }\n\n  readonly request: ZuploRequest;\n  mutableResponse: Response | Promise<Response>;\n}\n\n/**\n * @beta\n */\nexport class ResponseSentEvent extends Event {\n  constructor(request: ZuploRequest, response: Response) {\n    super(\"responseSent\");\n    this.request = request;\n    this.response = response; // Question, should we clone here to prevent mutation? Expensive when not used though\n  }\n\n  readonly request: ZuploRequest;\n  readonly response: Response;\n}\n\n/**\n * Used for storing and invoking context extensions\n * @internal\n */\nexport class ZuploContextExtensions {\n  static #map: WeakMap<ZuploContext, ZuploContextExtensions> = new WeakMap<\n    ZuploContext,\n    ZuploContextExtensions\n  >();\n\n  static initialize(context: ZuploContext, originalRequest: ZuploRequest) {\n    if (!ZuploContextExtensions.#map.has(context)) {\n      const ext = new ZuploContextExtensions(originalRequest);\n      ZuploContextExtensions.#map.set(context, ext);\n      return ext;\n    }\n    throw new Error(\n      `ZuploContextExtensions already initialized for context with requestId '${context.requestId}'`\n    );\n  }\n\n  static getContextExtensions(context: ZuploContext): ZuploContextExtensions {\n    const extensions = ZuploContextExtensions.#map.get(context);\n    if (!extensions) {\n      throw new RuntimeError(\n        `Invalid state, could not get ZuploContext extensions for context with requestId '${context.requestId}'`\n      );\n    }\n    return extensions;\n  }\n\n  // This starts with the original request, and is updated as the request is modified\n  // in the pipeline\n  latestRequest: ZuploRequest;\n\n  // Set only on NotFound responses - contains other path matches that match path but not method\n  pathOnlyMatches?: RouteConfiguration[];\n\n  #onResponseSendingFinalHooks: OnResponseSendingFinalHook[];\n  #onResponseSendingHooks: OnResponseSendingHook[];\n\n  private constructor(originalRequest: ZuploRequest) {\n    this.latestRequest = originalRequest;\n    this.#onResponseSendingFinalHooks = [];\n    this.#onResponseSendingHooks = [];\n  }\n\n  addResponseSendingHook(hook: OnResponseSendingHook) {\n    this.#onResponseSendingHooks.push(hook);\n  }\n\n  addResponseSendingFinalHook(hook: OnResponseSendingFinalHook) {\n    this.#onResponseSendingFinalHooks.push(hook);\n  }\n\n  onResponseSendingFinal: OnResponseSendingFinalHook = async (\n    response,\n    latestRequest,\n    context\n  ) => {\n    for (const hook of this.#onResponseSendingFinalHooks) {\n      await hook(response, latestRequest, context);\n    }\n  };\n\n  onResponseSending: OnResponseSendingHook = async (\n    response,\n    latestRequest,\n    context\n  ) => {\n    let latestResponse = response;\n\n    for (const hook of this.#onResponseSendingHooks) {\n      latestResponse = await hook(response, latestRequest, context);\n    }\n\n    return latestResponse;\n  };\n}\n\n/**\n * @beta\n */\nexport class SystemZuploContext extends EventTarget implements ZuploContext {\n  constructor({\n    logger,\n    route,\n    requestId,\n    event,\n    custom,\n    incomingRequestProperties,\n  }: {\n    logger: Logger;\n    route: RouteConfiguration;\n    requestId: string;\n    event: ZuploEventContext;\n    custom: Record<string, unknown>;\n    incomingRequestProperties: IncomingRequestProperties;\n  }) {\n    super();\n    this.log = Object.freeze(logger);\n    this.route = route;\n    this.requestId = requestId;\n    this.custom = custom;\n    this.incomingRequestProperties = incomingRequestProperties;\n    this.#event = event;\n    this.invokeInboundPolicy = (policyName: string, request: ZuploRequest) => {\n      return invokeInboundPolicy(policyName, request, this);\n    };\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    this.waitUntil = (promise: Promise<any>) => {\n      this.#event.waitUntil(promise);\n    };\n\n    // Hooks\n    this.addResponseSendingHook = (hook) => {\n      ZuploContextExtensions.getContextExtensions(this).addResponseSendingHook(\n        hook\n      );\n    };\n    this.addResponseSendingFinalHook = (hook) => {\n      ZuploContextExtensions.getContextExtensions(\n        this\n      ).addResponseSendingFinalHook(hook);\n    };\n\n    // Freeze the context\n    Object.freeze(this);\n  }\n\n  readonly #event: ZuploEventContext;\n  readonly requestId: string;\n  readonly log: Logger;\n  readonly route: RouteConfiguration;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  readonly custom: Record<string, any>;\n  readonly incomingRequestProperties: IncomingRequestProperties;\n  readonly invokeInboundPolicy: (\n    policyName: string,\n    request: ZuploRequest\n  ) => Promise<ZuploRequest | Response>;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  readonly waitUntil: (promise: Promise<any>) => void;\n\n  /**\n   * Fires just before the response is sent. Response can be modified.\n   */\n  readonly addResponseSendingHook: (hook: OnResponseSendingHook) => void;\n\n  /**\n   * Fires immediately after the response is sent. Response cannot be modified.\n   */\n  readonly addResponseSendingFinalHook: (\n    hook: OnResponseSendingFinalHook\n  ) => void;\n\n  override addEventListener<Type extends keyof Record<string, Event>>(\n    type: Type,\n    handler: EventListenerOrEventListenerObject,\n    options?: AddEventListenerOptions | boolean\n  ): void {\n    const wrapped: EventListenerOrEventListenerObject = (e) => {\n      try {\n        typeof handler === \"function\" ? handler(e) : handler.handleEvent(e);\n      } catch (err) {\n        this.log.error(\n          `Error invoking event ${type}. See following logs for details.`\n        );\n        throw err;\n      }\n    };\n    super.addEventListener(type, wrapped, options);\n  }\n}\n\n/** ISO 3166-1 Alpha-2 codes */\nexport type Iso3166Alpha2Code =\n  | \"AD\"\n  | \"AE\"\n  | \"AF\"\n  | \"AG\"\n  | \"AI\"\n  | \"AL\"\n  | \"AM\"\n  | \"AO\"\n  | \"AQ\"\n  | \"AR\"\n  | \"AS\"\n  | \"AT\"\n  | \"AU\"\n  | \"AW\"\n  | \"AX\"\n  | \"AZ\"\n  | \"BA\"\n  | \"BB\"\n  | \"BD\"\n  | \"BE\"\n  | \"BF\"\n  | \"BG\"\n  | \"BH\"\n  | \"BI\"\n  | \"BJ\"\n  | \"BL\"\n  | \"BM\"\n  | \"BN\"\n  | \"BO\"\n  | \"BQ\"\n  | \"BR\"\n  | \"BS\"\n  | \"BT\"\n  | \"BV\"\n  | \"BW\"\n  | \"BY\"\n  | \"BZ\"\n  | \"CA\"\n  | \"CC\"\n  | \"CD\"\n  | \"CF\"\n  | \"CG\"\n  | \"CH\"\n  | \"CI\"\n  | \"CK\"\n  | \"CL\"\n  | \"CM\"\n  | \"CN\"\n  | \"CO\"\n  | \"CR\"\n  | \"CU\"\n  | \"CV\"\n  | \"CW\"\n  | \"CX\"\n  | \"CY\"\n  | \"CZ\"\n  | \"DE\"\n  | \"DJ\"\n  | \"DK\"\n  | \"DM\"\n  | \"DO\"\n  | \"DZ\"\n  | \"EC\"\n  | \"EE\"\n  | \"EG\"\n  | \"EH\"\n  | \"ER\"\n  | \"ES\"\n  | \"ET\"\n  | \"FI\"\n  | \"FJ\"\n  | \"FK\"\n  | \"FM\"\n  | \"FO\"\n  | \"FR\"\n  | \"GA\"\n  | \"GB\"\n  | \"GD\"\n  | \"GE\"\n  | \"GF\"\n  | \"GG\"\n  | \"GH\"\n  | \"GI\"\n  | \"GL\"\n  | \"GM\"\n  | \"GN\"\n  | \"GP\"\n  | \"GQ\"\n  | \"GR\"\n  | \"GS\"\n  | \"GT\"\n  | \"GU\"\n  | \"GW\"\n  | \"GY\"\n  | \"HK\"\n  | \"HM\"\n  | \"HN\"\n  | \"HR\"\n  | \"HT\"\n  | \"HU\"\n  | \"ID\"\n  | \"IE\"\n  | \"IL\"\n  | \"IM\"\n  | \"IN\"\n  | \"IO\"\n  | \"IQ\"\n  | \"IR\"\n  | \"IS\"\n  | \"IT\"\n  | \"JE\"\n  | \"JM\"\n  | \"JO\"\n  | \"JP\"\n  | \"KE\"\n  | \"KG\"\n  | \"KH\"\n  | \"KI\"\n  | \"KM\"\n  | \"KN\"\n  | \"KP\"\n  | \"KR\"\n  | \"KW\"\n  | \"KY\"\n  | \"KZ\"\n  | \"LA\"\n  | \"LB\"\n  | \"LC\"\n  | \"LI\"\n  | \"LK\"\n  | \"LR\"\n  | \"LS\"\n  | \"LT\"\n  | \"LU\"\n  | \"LV\"\n  | \"LY\"\n  | \"MA\"\n  | \"MC\"\n  | \"MD\"\n  | \"ME\"\n  | \"MF\"\n  | \"MG\"\n  | \"MH\"\n  | \"MK\"\n  | \"ML\"\n  | \"MM\"\n  | \"MN\"\n  | \"MO\"\n  | \"MP\"\n  | \"MQ\"\n  | \"MR\"\n  | \"MS\"\n  | \"MT\"\n  | \"MU\"\n  | \"MV\"\n  | \"MW\"\n  | \"MX\"\n  | \"MY\"\n  | \"MZ\"\n  | \"NA\"\n  | \"NC\"\n  | \"NE\"\n  | \"NF\"\n  | \"NG\"\n  | \"NI\"\n  | \"NL\"\n  | \"NO\"\n  | \"NP\"\n  | \"NR\"\n  | \"NU\"\n  | \"NZ\"\n  | \"OM\"\n  | \"PA\"\n  | \"PE\"\n  | \"PF\"\n  | \"PG\"\n  | \"PH\"\n  | \"PK\"\n  | \"PL\"\n  | \"PM\"\n  | \"PN\"\n  | \"PR\"\n  | \"PS\"\n  | \"PT\"\n  | \"PW\"\n  | \"PY\"\n  | \"QA\"\n  | \"RE\"\n  | \"RO\"\n  | \"RS\"\n  | \"RU\"\n  | \"RW\"\n  | \"SA\"\n  | \"SB\"\n  | \"SC\"\n  | \"SD\"\n  | \"SE\"\n  | \"SG\"\n  | \"SH\"\n  | \"SI\"\n  | \"SJ\"\n  | \"SK\"\n  | \"SL\"\n  | \"SM\"\n  | \"SN\"\n  | \"SO\"\n  | \"SR\"\n  | \"SS\"\n  | \"ST\"\n  | \"SV\"\n  | \"SX\"\n  | \"SY\"\n  | \"SZ\"\n  | \"TC\"\n  | \"TD\"\n  | \"TF\"\n  | \"TG\"\n  | \"TH\"\n  | \"TJ\"\n  | \"TK\"\n  | \"TL\"\n  | \"TM\"\n  | \"TN\"\n  | \"TO\"\n  | \"TR\"\n  | \"TT\"\n  | \"TV\"\n  | \"TW\"\n  | \"TZ\"\n  | \"UA\"\n  | \"UG\"\n  | \"UM\"\n  | \"US\"\n  | \"UY\"\n  | \"UZ\"\n  | \"VA\"\n  | \"VC\"\n  | \"VE\"\n  | \"VG\"\n  | \"VI\"\n  | \"VN\"\n  | \"VU\"\n  | \"WF\"\n  | \"WS\"\n  | \"YE\"\n  | \"YT\"\n  | \"ZA\"\n  | \"ZM\"\n  | \"ZW\";\n/** The 2-letter continent codes Cloudflare uses */\nexport type ContinentCode = \"AF\" | \"AN\" | \"AS\" | \"EU\" | \"NA\" | \"OC\" | \"SA\";\n", "/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { ZuploContext } from \"./index.worker\";\n\n/**\n * Utility for storing data across the lifecycle of a request. This class is\n * useful for storing and retrieving data that is shared between policies.\n *\n * @public\n *\n * @example\n * Using static methods\n * ```\n * ContextData.set(context, \"my-data\", { prop1: \"hello world\" });\n *\n * const data = ContextData.get(context, \"my-data\");\n * ContextData.set(context, data);\n * ```\n *\n * @example\n * Reusable class shared across modules\n *\n * The shared module allows other modules to access the same storage without\n * passing the string name or type around.\n *\n * ```\n * export const myData =\n *    new ContextData<{ prop1: string }>(\"my-data\");\n * ```\n *\n * Then use the class in another module.\n *\n * ```\n * import { myData } from \"./my-module\";\n *\n *\n * const data = myData.get(context)\n * myData.set(context, data);\n *\n * ```\n */\nexport class ContextData<T = any> {\n  static #storage: WeakMap<ZuploContext, Map<string, any>> | undefined;\n\n  #name: string;\n\n  constructor(name: string) {\n    this.#name = name;\n  }\n\n  set(context: ZuploContext, data: T) {\n    ContextData.set(context, this.#name, data);\n  }\n\n  get(context: ZuploContext): T | undefined {\n    return ContextData.get(context, this.#name);\n  }\n\n  static set<T = any>(context: ZuploContext, name: string, data: T) {\n    if (!ContextData.#storage) {\n      ContextData.#storage = new WeakMap();\n    }\n    let map = ContextData.#storage.get(context);\n    if (!map) {\n      map = new Map<string, any>();\n    }\n    map.set(name, data);\n    ContextData.#storage.set(context, map);\n  }\n\n  static get<T = any>(context: ZuploContext, name: string): T | undefined {\n    if (!ContextData.#storage) {\n      ContextData.#storage = new WeakMap();\n    }\n    return ContextData.#storage.get(context)?.get(name) as T | undefined;\n  }\n}\n", "import { Environment } from \"./utils/environment\";\n\nconst ALLOWED_WRITABLE_ZUPLO_VARIABLES = [\n  \"ZUPLO_USER_LOGGER_DATA_DOG_API_KEY\",\n  \"ZUPLO_USER_LOGGER_DATA_DOG_URL\",\n  \"ZUPLO_LOG_LEVEL\",\n  \"ZUPLO_HANDLER_WRITE_LOG_LEVEL\",\n];\n\n/**\n * @internal\n * Checks if the variable is a restricted name that the\n * end-user is not allowed to use\n */\nexport function isRestrictedEnvVariableName(name: string) {\n  // By default _ZUPLO and ZUPLO_ names are not allowed\n  if (name.startsWith(\"__ZUPLO\") || name.startsWith(\"ZUPLO_\")) {\n    // If the variable is one of the specific allowed variables or\n    // if it starts with ZUPLO_PUBLIC_ then it is also allowed\n    return (\n      !ALLOWED_WRITABLE_ZUPLO_VARIABLES.includes(name) &&\n      !name.startsWith(\"ZUPLO_PUBLIC_\")\n    );\n  }\n  return false;\n}\n\nexport function isZuploReadableEnvVariableName(name: string) {\n  if (name.startsWith(\"ZUPLO_\")) {\n    return true;\n  }\n  return false;\n}\n\n/**\n * @beta\n * Object exposing environment variables\n */\nconst environment = new Proxy<Record<string, string | undefined>>(\n  {},\n  {\n    get(target, prop) {\n      if (\n        isRestrictedEnvVariableName(String(prop)) &&\n        !isZuploReadableEnvVariableName(String(prop))\n      ) {\n        return undefined;\n      }\n\n      return Environment.instance.runtime[String(prop)];\n    },\n  }\n);\n\nexport { environment };\n", "export class AsyncLocalStorage {\n  getStore() {\n    return {};\n  }\n  run(store, fn) {\n    return fn();\n  }\n}\n", "/* eslint-disable import/no-nodejs-modules */\nimport { AsyncLocalStorage } from \"node:async_hooks\";\nimport { SystemError } from \"./errors\";\nimport { RequestContext } from \"./interfaces\";\n\nexport const stores = {\n  request: new AsyncLocalStorage<RequestContext>(),\n};\n\nexport function getRequestContext(): RequestContext {\n  const context = stores.request.getStore();\n  if (!context) {\n    throw new SystemError(\n      \"Context not set in store. This should never happen.\"\n    );\n  }\n  return context;\n}\n", "/* eslint-disable @typescript-eslint/no-explicit-any */\n\nimport {\n  LEGACY_REQUEST_ID_HEADER,\n  RAY_ID_HEADER,\n  REQUEST_ID_HEADER,\n} from \"./constants\";\nimport { RequestHandlerFunction, proxyHandler } from \"./diagnostics/telemetry\";\nimport { ConfigurationError } from \"./errors\";\nimport { RuntimeExtensionsFunction, initializeRuntime } from \"./extensions\";\nimport { Gateway } from \"./gateway\";\nimport {\n  BuildEnvironment,\n  RequestContext,\n  RuntimeEnvironment,\n  RuntimeSettings,\n  ServiceProvider,\n  ZuploEventContext,\n} from \"./interfaces\";\nimport { RouteData } from \"./router/interfaces\";\nimport { stores } from \"./stores\";\nimport { Environment } from \"./utils/environment\";\n\n/**\n * Purge the Gateway cache used Handler.requestHandler\n * @internal\n */\nexport const purgeGatewayCache = () => {\n  Gateway.purgeGatewayCache();\n};\n\nconst GATEWAY_ERROR_DETAIL =\n  \"Error initializing gateway. Check your configuration for errors or contact support.\";\nconst INIT_ERROR_DETAIL =\n  \"Error initializing gateway. Check your 'zuplo.runtime.ts' for errors or contact support.\";\n/**\n * @internal\n */\nexport class Handler {\n  constructor(\n    public routeLoader: () => RouteData,\n    public buildEnvironment: BuildEnvironment,\n    public runtimeSettings: RuntimeSettings,\n    private serviceProvider: ServiceProvider,\n    private schemaValidations: any,\n    private runtimeInit: RuntimeExtensionsFunction | undefined\n  ) {}\n\n  requestHandler = async (\n    request: Request,\n    runtimeEnvironment: RuntimeEnvironment,\n    event: ZuploEventContext\n  ): Promise<Response> => {\n    const requestId =\n      request.headers.get(REQUEST_ID_HEADER) ??\n      request.headers.get(LEGACY_REQUEST_ID_HEADER) ??\n      crypto.randomUUID();\n    const rayId = request.headers.get(RAY_ID_HEADER);\n\n    const requestContext: RequestContext = { requestId, rayId };\n\n    return stores.request.run(requestContext, async () => {\n      // This needs to be initialized before the gateway\n      Environment.initialize({\n        build: this.buildEnvironment,\n        runtime: runtimeEnvironment,\n      });\n\n      try {\n        // This needs to happen first because telemetry plugins\n        //  set the proxyHandler function\n        await initializeRuntime(this.runtimeInit);\n      } catch (err) {\n        this.handleError(err, INIT_ERROR_DETAIL, request);\n      }\n\n      const innerHandler: RequestHandlerFunction = async (request, event) => {\n        let gateway: Gateway;\n\n        try {\n          gateway = await Gateway.initialize(\n            this.routeLoader,\n            this.runtimeSettings,\n            this.serviceProvider,\n            this.schemaValidations\n          );\n        } catch (err) {\n          return this.handleError(err, GATEWAY_ERROR_DETAIL, request);\n        }\n\n        return gateway.handleRequest(request, requestContext, event);\n      };\n\n      return proxyHandler(innerHandler)(request, event);\n    });\n  };\n\n  handleError(err: Error, detail: string, request: Request) {\n    // Useful in CloudFlare et al\n    // eslint-disable-next-line no-console\n    console.error(\"Error initializing gateway.\", err);\n\n    if (err instanceof ConfigurationError) {\n      detail = err.message;\n    }\n\n    // Can't use real problem details lib, too high in the stack\n    const problem = {\n      status: 500,\n      title: \"Gateway Initialization Error\",\n      type: \"https://httpproblems.com/http-status/500\",\n      detail,\n      instance: request.url,\n      trace: {\n        timestamp: Date.now(),\n        rayId: request.headers.get(\"cf-ray\") ?? undefined,\n        buildId: this.buildEnvironment.BUILD_ID,\n      },\n      // It's too risky to show details of the error to the user in production\n      // Arguably OK in working-copy\n      message: Environment.instance.isWorkingCopy ? err.message : undefined,\n    };\n    return new Response(JSON.stringify(problem, null, 2), {\n      status: 500,\n      headers: {\n        \"content-type\": \"application/json\",\n      },\n    });\n  }\n}\n", "/**\n * Tokenizer results.\n */\ninterface LexToken {\n  type:\n    | \"OPEN\"\n    | \"CLOSE\"\n    | \"PATTERN\"\n    | \"NAME\"\n    | \"CHAR\"\n    | \"ESCAPED_CHAR\"\n    | \"MODIFIER\"\n    | \"END\";\n  index: number;\n  value: string;\n}\n\n/**\n * Tokenize input string.\n */\nfunction lexer(str: string): LexToken[] {\n  const tokens: LexToken[] = [];\n  let i = 0;\n\n  while (i < str.length) {\n    const char = str[i];\n\n    if (char === \"*\" || char === \"+\" || char === \"?\") {\n      tokens.push({ type: \"MODIFIER\", index: i, value: str[i++] });\n      continue;\n    }\n\n    if (char === \"\\\\\") {\n      tokens.push({ type: \"ESCAPED_CHAR\", index: i++, value: str[i++] });\n      continue;\n    }\n\n    if (char === \"{\") {\n      tokens.push({ type: \"OPEN\", index: i, value: str[i++] });\n      continue;\n    }\n\n    if (char === \"}\") {\n      tokens.push({ type: \"CLOSE\", index: i, value: str[i++] });\n      continue;\n    }\n\n    if (char === \":\") {\n      let name = \"\";\n      let j = i + 1;\n\n      while (j < str.length) {\n        const code = str.charCodeAt(j);\n\n        if (\n          // `0-9`\n          (code >= 48 && code <= 57) ||\n          // `A-Z`\n          (code >= 65 && code <= 90) ||\n          // `a-z`\n          (code >= 97 && code <= 122) ||\n          // `_`\n          code === 95\n        ) {\n          name += str[j++];\n          continue;\n        }\n\n        break;\n      }\n\n      if (!name) throw new TypeError(`Missing parameter name at ${i}`);\n\n      tokens.push({ type: \"NAME\", index: i, value: name });\n      i = j;\n      continue;\n    }\n\n    if (char === \"(\") {\n      let count = 1;\n      let pattern = \"\";\n      let j = i + 1;\n\n      if (str[j] === \"?\") {\n        throw new TypeError(`Pattern cannot start with \"?\" at ${j}`);\n      }\n\n      while (j < str.length) {\n        if (str[j] === \"\\\\\") {\n          pattern += str[j++] + str[j++];\n          continue;\n        }\n\n        if (str[j] === \")\") {\n          count--;\n          if (count === 0) {\n            j++;\n            break;\n          }\n        } else if (str[j] === \"(\") {\n          count++;\n          if (str[j + 1] !== \"?\") {\n            throw new TypeError(`Capturing groups are not allowed at ${j}`);\n          }\n        }\n\n        pattern += str[j++];\n      }\n\n      if (count) throw new TypeError(`Unbalanced pattern at ${i}`);\n      if (!pattern) throw new TypeError(`Missing pattern at ${i}`);\n\n      tokens.push({ type: \"PATTERN\", index: i, value: pattern });\n      i = j;\n      continue;\n    }\n\n    tokens.push({ type: \"CHAR\", index: i, value: str[i++] });\n  }\n\n  tokens.push({ type: \"END\", index: i, value: \"\" });\n\n  return tokens;\n}\n\nexport interface ParseOptions {\n  /**\n   * Set the default delimiter for repeat parameters. (default: `'/'`)\n   */\n  delimiter?: string;\n  /**\n   * List of characters to automatically consider prefixes when parsing.\n   */\n  prefixes?: string;\n}\n\n/**\n * Parse a string for the raw tokens.\n */\nexport function parse(str: string, options: ParseOptions = {}): Token[] {\n  const tokens = lexer(str);\n  const { prefixes = \"./\" } = options;\n  const defaultPattern = `[^${escapeString(options.delimiter || \"/#?\")}]+?`;\n  const result: Token[] = [];\n  let key = 0;\n  let i = 0;\n  let path = \"\";\n\n  const tryConsume = (type: LexToken[\"type\"]): string | undefined => {\n    if (i < tokens.length && tokens[i].type === type) return tokens[i++].value;\n  };\n\n  const mustConsume = (type: LexToken[\"type\"]): string => {\n    const value = tryConsume(type);\n    if (value !== undefined) return value;\n    const { type: nextType, index } = tokens[i];\n    throw new TypeError(`Unexpected ${nextType} at ${index}, expected ${type}`);\n  };\n\n  const consumeText = (): string => {\n    let result = \"\";\n    let value: string | undefined;\n    while ((value = tryConsume(\"CHAR\") || tryConsume(\"ESCAPED_CHAR\"))) {\n      result += value;\n    }\n    return result;\n  };\n\n  while (i < tokens.length) {\n    const char = tryConsume(\"CHAR\");\n    const name = tryConsume(\"NAME\");\n    const pattern = tryConsume(\"PATTERN\");\n\n    if (name || pattern) {\n      let prefix = char || \"\";\n\n      if (prefixes.indexOf(prefix) === -1) {\n        path += prefix;\n        prefix = \"\";\n      }\n\n      if (path) {\n        result.push(path);\n        path = \"\";\n      }\n\n      result.push({\n        name: name || key++,\n        prefix,\n        suffix: \"\",\n        pattern: pattern || defaultPattern,\n        modifier: tryConsume(\"MODIFIER\") || \"\",\n      });\n      continue;\n    }\n\n    const value = char || tryConsume(\"ESCAPED_CHAR\");\n    if (value) {\n      path += value;\n      continue;\n    }\n\n    if (path) {\n      result.push(path);\n      path = \"\";\n    }\n\n    const open = tryConsume(\"OPEN\");\n    if (open) {\n      const prefix = consumeText();\n      const name = tryConsume(\"NAME\") || \"\";\n      const pattern = tryConsume(\"PATTERN\") || \"\";\n      const suffix = consumeText();\n\n      mustConsume(\"CLOSE\");\n\n      result.push({\n        name: name || (pattern ? key++ : \"\"),\n        pattern: name && !pattern ? defaultPattern : pattern,\n        prefix,\n        suffix,\n        modifier: tryConsume(\"MODIFIER\") || \"\",\n      });\n      continue;\n    }\n\n    mustConsume(\"END\");\n  }\n\n  return result;\n}\n\nexport interface TokensToFunctionOptions {\n  /**\n   * When `true` the regexp will be case sensitive. (default: `false`)\n   */\n  sensitive?: boolean;\n  /**\n   * Function for encoding input strings for output.\n   */\n  encode?: (value: string, token: Key) => string;\n  /**\n   * When `false` the function can produce an invalid (unmatched) path. (default: `true`)\n   */\n  validate?: boolean;\n}\n\n/**\n * Compile a string to a template function for the path.\n */\nexport function compile<P extends object = object>(\n  str: string,\n  options?: ParseOptions & TokensToFunctionOptions\n) {\n  return tokensToFunction<P>(parse(str, options), options);\n}\n\nexport type PathFunction<P extends object = object> = (data?: P) => string;\n\n/**\n * Expose a method for transforming tokens into the path function.\n */\nexport function tokensToFunction<P extends object = object>(\n  tokens: Token[],\n  options: TokensToFunctionOptions = {}\n): PathFunction<P> {\n  const reFlags = flags(options);\n  const { encode = (x: string) => x, validate = true } = options;\n\n  // Compile all the tokens into regexps.\n  const matches = tokens.map((token) => {\n    if (typeof token === \"object\") {\n      return new RegExp(`^(?:${token.pattern})$`, reFlags);\n    }\n  });\n\n  return (data: Record<string, any> | null | undefined) => {\n    let path = \"\";\n\n    for (let i = 0; i < tokens.length; i++) {\n      const token = tokens[i];\n\n      if (typeof token === \"string\") {\n        path += token;\n        continue;\n      }\n\n      const value = data ? data[token.name] : undefined;\n      const optional = token.modifier === \"?\" || token.modifier === \"*\";\n      const repeat = token.modifier === \"*\" || token.modifier === \"+\";\n\n      if (Array.isArray(value)) {\n        if (!repeat) {\n          throw new TypeError(\n            `Expected \"${token.name}\" to not repeat, but got an array`\n          );\n        }\n\n        if (value.length === 0) {\n          if (optional) continue;\n\n          throw new TypeError(`Expected \"${token.name}\" to not be empty`);\n        }\n\n        for (let j = 0; j < value.length; j++) {\n          const segment = encode(value[j], token);\n\n          if (validate && !(matches[i] as RegExp).test(segment)) {\n            throw new TypeError(\n              `Expected all \"${token.name}\" to match \"${token.pattern}\", but got \"${segment}\"`\n            );\n          }\n\n          path += token.prefix + segment + token.suffix;\n        }\n\n        continue;\n      }\n\n      if (typeof value === \"string\" || typeof value === \"number\") {\n        const segment = encode(String(value), token);\n\n        if (validate && !(matches[i] as RegExp).test(segment)) {\n          throw new TypeError(\n            `Expected \"${token.name}\" to match \"${token.pattern}\", but got \"${segment}\"`\n          );\n        }\n\n        path += token.prefix + segment + token.suffix;\n        continue;\n      }\n\n      if (optional) continue;\n\n      const typeOfMessage = repeat ? \"an array\" : \"a string\";\n      throw new TypeError(`Expected \"${token.name}\" to be ${typeOfMessage}`);\n    }\n\n    return path;\n  };\n}\n\nexport interface RegexpToFunctionOptions {\n  /**\n   * Function for decoding strings for params.\n   */\n  decode?: (value: string, token: Key) => string;\n}\n\n/**\n * A match result contains data about the path match.\n */\nexport interface MatchResult<P extends object = object> {\n  path: string;\n  index: number;\n  params: P;\n}\n\n/**\n * A match is either `false` (no match) or a match result.\n */\nexport type Match<P extends object = object> = false | MatchResult<P>;\n\n/**\n * The match function takes a string and returns whether it matched the path.\n */\nexport type MatchFunction<P extends object = object> = (\n  path: string\n) => Match<P>;\n\n/**\n * Create path match function from `path-to-regexp` spec.\n */\nexport function match<P extends object = object>(\n  str: Path,\n  options?: ParseOptions & TokensToRegexpOptions & RegexpToFunctionOptions\n) {\n  const keys: Key[] = [];\n  const re = pathToRegexp(str, keys, options);\n  return regexpToFunction<P>(re, keys, options);\n}\n\n/**\n * Create a path match function from `path-to-regexp` output.\n */\nexport function regexpToFunction<P extends object = object>(\n  re: RegExp,\n  keys: Key[],\n  options: RegexpToFunctionOptions = {}\n): MatchFunction<P> {\n  const { decode = (x: string) => x } = options;\n\n  return function (pathname: string) {\n    const m = re.exec(pathname);\n    if (!m) return false;\n\n    const { 0: path, index } = m;\n    const params = Object.create(null);\n\n    for (let i = 1; i < m.length; i++) {\n      if (m[i] === undefined) continue;\n\n      const key = keys[i - 1];\n\n      if (key.modifier === \"*\" || key.modifier === \"+\") {\n        params[key.name] = m[i].split(key.prefix + key.suffix).map((value) => {\n          return decode(value, key);\n        });\n      } else {\n        params[key.name] = decode(m[i], key);\n      }\n    }\n\n    return { path, index, params };\n  };\n}\n\n/**\n * Escape a regular expression string.\n */\nfunction escapeString(str: string) {\n  return str.replace(/([.+*?=^!:${}()[\\]|/\\\\])/g, \"\\\\$1\");\n}\n\n/**\n * Get the flags for a regexp from the options.\n */\nfunction flags(options?: { sensitive?: boolean }) {\n  return options && options.sensitive ? \"\" : \"i\";\n}\n\n/**\n * Metadata about a key.\n */\nexport interface Key {\n  name: string | number;\n  prefix: string;\n  suffix: string;\n  pattern: string;\n  modifier: string;\n}\n\n/**\n * A token is a string (nothing special) or key metadata (capture group).\n */\nexport type Token = string | Key;\n\n/**\n * Pull out keys from a regexp.\n */\nfunction regexpToRegexp(path: RegExp, keys?: Key[]): RegExp {\n  if (!keys) return path;\n\n  const groupsRegex = /\\((?:\\?<(.*?)>)?(?!\\?)/g;\n\n  let index = 0;\n  let execResult = groupsRegex.exec(path.source);\n  while (execResult) {\n    keys.push({\n      // Use parenthesized substring match if available, index otherwise\n      name: execResult[1] || index++,\n      prefix: \"\",\n      suffix: \"\",\n      modifier: \"\",\n      pattern: \"\",\n    });\n    execResult = groupsRegex.exec(path.source);\n  }\n\n  return path;\n}\n\n/**\n * Transform an array into a regexp.\n */\nfunction arrayToRegexp(\n  paths: Array<string | RegExp>,\n  keys?: Key[],\n  options?: TokensToRegexpOptions & ParseOptions\n): RegExp {\n  const parts = paths.map((path) => pathToRegexp(path, keys, options).source);\n  return new RegExp(`(?:${parts.join(\"|\")})`, flags(options));\n}\n\n/**\n * Create a path regexp from string input.\n */\nfunction stringToRegexp(\n  path: string,\n  keys?: Key[],\n  options?: TokensToRegexpOptions & ParseOptions\n) {\n  return tokensToRegexp(parse(path, options), keys, options);\n}\n\nexport interface TokensToRegexpOptions {\n  /**\n   * When `true` the regexp will be case sensitive. (default: `false`)\n   */\n  sensitive?: boolean;\n  /**\n   * When `true` the regexp won't allow an optional trailing delimiter to match. (default: `false`)\n   */\n  strict?: boolean;\n  /**\n   * When `true` the regexp will match to the end of the string. (default: `true`)\n   */\n  end?: boolean;\n  /**\n   * When `true` the regexp will match from the beginning of the string. (default: `true`)\n   */\n  start?: boolean;\n  /**\n   * Sets the final character for non-ending optimistic matches. (default: `/`)\n   */\n  delimiter?: string;\n  /**\n   * List of characters that can also be \"end\" characters.\n   */\n  endsWith?: string;\n  /**\n   * Encode path tokens for use in the `RegExp`.\n   */\n  encode?: (value: string) => string;\n}\n\n/**\n * Expose a function for taking tokens and returning a RegExp.\n */\nexport function tokensToRegexp(\n  tokens: Token[],\n  keys?: Key[],\n  options: TokensToRegexpOptions = {}\n) {\n  const {\n    strict = false,\n    start = true,\n    end = true,\n    encode = (x: string) => x,\n    delimiter = \"/#?\",\n    endsWith = \"\",\n  } = options;\n  const endsWithRe = `[${escapeString(endsWith)}]|$`;\n  const delimiterRe = `[${escapeString(delimiter)}]`;\n  let route = start ? \"^\" : \"\";\n\n  // Iterate over the tokens and create our regexp string.\n  for (const token of tokens) {\n    if (typeof token === \"string\") {\n      route += escapeString(encode(token));\n    } else {\n      const prefix = escapeString(encode(token.prefix));\n      const suffix = escapeString(encode(token.suffix));\n\n      if (token.pattern) {\n        if (keys) keys.push(token);\n\n        if (prefix || suffix) {\n          if (token.modifier === \"+\" || token.modifier === \"*\") {\n            const mod = token.modifier === \"*\" ? \"?\" : \"\";\n            route += `(?:${prefix}((?:${token.pattern})(?:${suffix}${prefix}(?:${token.pattern}))*)${suffix})${mod}`;\n          } else {\n            route += `(?:${prefix}(${token.pattern})${suffix})${token.modifier}`;\n          }\n        } else {\n          if (token.modifier === \"+\" || token.modifier === \"*\") {\n            route += `((?:${token.pattern})${token.modifier})`;\n          } else {\n            route += `(${token.pattern})${token.modifier}`;\n          }\n        }\n      } else {\n        route += `(?:${prefix}${suffix})${token.modifier}`;\n      }\n    }\n  }\n\n  if (end) {\n    if (!strict) route += `${delimiterRe}?`;\n\n    route += !options.endsWith ? \"$\" : `(?=${endsWithRe})`;\n  } else {\n    const endToken = tokens[tokens.length - 1];\n    const isEndDelimited =\n      typeof endToken === \"string\"\n        ? delimiterRe.indexOf(endToken[endToken.length - 1]) > -1\n        : endToken === undefined;\n\n    if (!strict) {\n      route += `(?:${delimiterRe}(?=${endsWithRe}))?`;\n    }\n\n    if (!isEndDelimited) {\n      route += `(?=${delimiterRe}|${endsWithRe})`;\n    }\n  }\n\n  return new RegExp(route, flags(options));\n}\n\n/**\n * Supported `path-to-regexp` input types.\n */\nexport type Path = string | RegExp | Array<string | RegExp>;\n\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n */\nexport function pathToRegexp(\n  path: Path,\n  keys?: Key[],\n  options?: TokensToRegexpOptions & ParseOptions\n) {\n  if (path instanceof RegExp) return regexpToRegexp(path, keys);\n  if (Array.isArray(path)) return arrayToRegexp(path, keys, options);\n  return stringToRegexp(path, keys, options);\n}\n", "/**\n * License MIT https://opensource.org/licenses/MIT\n * Copyright Michael Hart 2018\n * https://raw.githubusercontent.com/mhart/aws4fetch/master/src/main.js\n */\nimport { debug } from \"@zuplo/debug\";\nimport { ConfigurationError, RuntimeError } from \"../errors\";\nimport internals from \"../internals\";\nconst log = debug(\"zuplo:runtime\");\n\nconst encoder = new TextEncoder();\n\nconst HOST_SERVICES: { [key: string]: string } = {\n  appstream2: \"appstream\",\n  cloudhsmv2: \"cloudhsm\",\n  email: \"ses\",\n  marketplace: \"aws-marketplace\",\n  mobile: \"AWSMobileHubService\",\n  pinpoint: \"mobiletargeting\",\n  queue: \"sqs\",\n  \"git-codecommit\": \"codecommit\",\n  \"mturk-requester-sandbox\": \"mturk-requester\",\n  \"personalize-runtime\": \"personalize\",\n};\n\n// https://github.com/aws/aws-sdk-js/blob/cc29728c1c4178969ebabe3bbe6b6f3159436394/lib/signers/v4.js#L190-L198\nconst UNSIGNABLE_HEADERS = [\n  \"authorization\",\n  \"content-type\",\n  \"content-length\",\n  \"user-agent\",\n  \"presigned-expires\",\n  \"expect\",\n  \"x-amzn-trace-id\",\n  \"range\",\n  \"connection\",\n];\n\nexport interface AwsRequestInit extends Omit<RequestInit, \"body\"> {\n  body: ArrayBuffer | string | null;\n  aws?: {\n    accessKeyId?: string;\n    secretAccessKey?: string;\n    sessionToken?: string;\n    service?: string;\n    region?: string;\n    cache?: Map<string, ArrayBuffer>;\n    datetime?: string;\n    signQuery?: boolean;\n    appendSessionToken?: boolean;\n    allHeaders?: boolean;\n    singleEncode?: boolean;\n  };\n}\n\nexport class AwsClient {\n  accessKeyId: string;\n  secretAccessKey: string;\n  sessionToken?: string;\n  service?: string;\n  region?: string;\n  cache: Map<string, ArrayBuffer>;\n  private retries: number;\n  private initRetryMs: number;\n\n  constructor({\n    accessKeyId,\n    secretAccessKey,\n    sessionToken,\n    service,\n    region,\n    cache,\n    retries,\n    initRetryMs,\n  }: {\n    accessKeyId: string;\n    secretAccessKey: string;\n    sessionToken?: string;\n    service?: string;\n    region?: string;\n    cache?: Map<string, ArrayBuffer>;\n    retries?: number;\n    initRetryMs?: number;\n  }) {\n    if (accessKeyId == null)\n      throw new TypeError(\"accessKeyId is a required option\");\n    if (secretAccessKey == null)\n      throw new TypeError(\"secretAccessKey is a required option\");\n    this.accessKeyId = accessKeyId;\n    this.secretAccessKey = secretAccessKey;\n    this.sessionToken = sessionToken;\n    this.service = service;\n    this.region = region;\n    this.cache = cache || new Map();\n    this.retries = retries != null ? retries : 0;\n    this.initRetryMs = initRetryMs || 50;\n  }\n\n  async sign(lambdaUrl: string, init: AwsRequestInit) {\n    const signer = new AwsV4Signer(\n      Object.assign({ url: lambdaUrl }, init, this, init && init.aws)\n    );\n    const signed = Object.assign({}, init, await signer.sign());\n    delete signed.aws;\n    return { url: signed.url.toString(), request: signed };\n  }\n\n  async fetch(lambdaUrl: string, init: AwsRequestInit) {\n    log(\"AWS fetch\", lambdaUrl);\n    for (let i = 0; i <= this.retries; i++) {\n      const { url, request } = await this.sign(lambdaUrl, init);\n      const fetched = internals.fetch(url, request);\n      if (i === this.retries) {\n        return fetched; // No need to await if we're returning anyway\n      }\n      const res = await fetched;\n      if (res.status < 500 && res.status !== 429) {\n        return res;\n      }\n      await new Promise((resolve) =>\n        setTimeout(resolve, Math.random() * this.initRetryMs * Math.pow(2, i))\n      );\n    }\n    throw new ConfigurationError(\n      \"An unknown error occurred, ensure retries is not negative\"\n    );\n  }\n}\n\nexport class AwsV4Signer {\n  private method: string;\n  private url: URL;\n  private headers: Headers;\n  private body?: BodyInit | null;\n  private accessKeyId: string;\n  private secretAccessKey: string;\n  private sessionToken?: string;\n  private service: string;\n  private region: string;\n  private cache: Map<string, ArrayBuffer>;\n  private datetime: string;\n  private signQuery?: boolean;\n  private appendSessionToken?: boolean;\n  private signableHeaders: string[];\n  private signedHeaders: string;\n  private canonicalHeaders: string;\n  private credentialString: string;\n  private encodedPath: string;\n  private encodedSearch: string;\n\n  constructor({\n    method,\n    url,\n    headers,\n    body,\n    accessKeyId,\n    secretAccessKey,\n    sessionToken,\n    service,\n    region,\n    cache,\n    datetime,\n    signQuery,\n    appendSessionToken,\n    allHeaders,\n    singleEncode,\n  }: {\n    method?: string;\n    url: string;\n    headers?: HeadersInit;\n    body?: BodyInit | null;\n    accessKeyId: string;\n    secretAccessKey: string;\n    sessionToken?: string;\n    service?: string;\n    region?: string;\n    cache?: Map<string, ArrayBuffer>;\n    datetime?: string;\n    signQuery?: boolean;\n    appendSessionToken?: boolean;\n    allHeaders?: boolean;\n    singleEncode?: boolean;\n  }) {\n    if (url == null) throw new TypeError(\"url is a required option\");\n    if (accessKeyId == null)\n      throw new TypeError(\"accessKeyId is a required option\");\n    if (secretAccessKey == null)\n      throw new TypeError(\"secretAccessKey is a required option\");\n\n    this.method = method || (body ? \"POST\" : \"GET\");\n    this.url = new URL(url);\n    this.headers = new Headers(headers || {});\n    this.body = body;\n\n    this.accessKeyId = accessKeyId;\n    this.secretAccessKey = secretAccessKey;\n    this.sessionToken = sessionToken;\n\n    let guessedService, guessedRegion;\n    if (!service || !region) {\n      [guessedService, guessedRegion] = guessServiceRegion(\n        this.url,\n        this.headers\n      );\n    }\n\n    this.service = service || guessedService || \"\";\n    this.region = region || guessedRegion || \"us-east-1\";\n\n    this.cache = cache || new Map();\n    this.datetime =\n      datetime || new Date().toISOString().replace(/[:-]|\\.\\d{3}/g, \"\");\n    this.signQuery = signQuery;\n    this.appendSessionToken =\n      appendSessionToken || this.service === \"iotdevicegateway\";\n\n    this.headers.delete(\"Host\"); // Can't be set in insecure env anyway\n\n    const params = this.signQuery ? this.url.searchParams : this.headers;\n    if (this.service === \"s3\" && !this.headers.has(\"X-Amz-Content-Sha256\")) {\n      this.headers.set(\"X-Amz-Content-Sha256\", \"UNSIGNED-PAYLOAD\");\n    }\n\n    params.set(\"X-Amz-Date\", this.datetime);\n    if (this.sessionToken && !this.appendSessionToken) {\n      params.set(\"X-Amz-Security-Token\", this.sessionToken);\n    }\n\n    // headers are always lowercase in keys()\n    this.signableHeaders = [\"host\", ...this.headers.keys()]\n      .filter((header) => allHeaders || !UNSIGNABLE_HEADERS.includes(header))\n      .sort();\n\n    this.signedHeaders = this.signableHeaders.join(\";\");\n\n    // headers are always trimmed:\n    // https://fetch.spec.whatwg.org/#concept-header-value-normalize\n    this.canonicalHeaders = this.signableHeaders\n      .map(\n        (header) =>\n          header +\n          \":\" +\n          (header === \"host\"\n            ? this.url.host\n            : (this.headers.get(header) || \"\").replace(/\\s+/g, \" \"))\n      )\n      .join(\"\\n\");\n\n    this.credentialString = [\n      this.datetime.slice(0, 8),\n      this.region,\n      this.service,\n      \"aws4_request\",\n    ].join(\"/\");\n\n    if (this.signQuery) {\n      if (this.service === \"s3\" && !params.has(\"X-Amz-Expires\")) {\n        params.set(\"X-Amz-Expires\", \"86400\"); // 24 hours\n      }\n      params.set(\"X-Amz-Algorithm\", \"AWS4-HMAC-SHA256\");\n      params.set(\n        \"X-Amz-Credential\",\n        this.accessKeyId + \"/\" + this.credentialString\n      );\n      params.set(\"X-Amz-SignedHeaders\", this.signedHeaders);\n    }\n\n    if (this.service === \"s3\") {\n      try {\n        this.encodedPath = decodeURIComponent(\n          this.url.pathname.replace(/\\+/g, \" \")\n        );\n      } catch (e) {\n        this.encodedPath = this.url.pathname;\n      }\n    } else {\n      this.encodedPath = this.url.pathname.replace(/\\/+/g, \"/\");\n    }\n    if (!singleEncode) {\n      this.encodedPath = encodeURIComponent(this.encodedPath).replace(\n        /%2F/g,\n        \"/\"\n      );\n    }\n    this.encodedPath = encodeRfc3986(this.encodedPath);\n\n    const seenKeys = new Set();\n    this.encodedSearch = [...this.url.searchParams]\n      .filter(([k]) => {\n        if (!k) return false; // no empty keys\n        if (this.service === \"s3\") {\n          if (seenKeys.has(k)) return false; // first val only for S3\n          seenKeys.add(k);\n        }\n        return true;\n      })\n      .map((pair) => pair.map((p) => encodeRfc3986(encodeURIComponent(p))))\n      .sort(([k1, v1], [k2, v2]) =>\n        k1 < k2 ? -1 : k1 > k2 ? 1 : v1 < v2 ? -1 : v1 > v2 ? 1 : 0\n      )\n      .map((pair) => pair.join(\"=\"))\n      .join(\"&\");\n  }\n\n  async sign(): Promise<{\n    method: string;\n    url: URL;\n    headers: Headers;\n    body?: BodyInit | null;\n  }> {\n    if (this.signQuery) {\n      this.url.searchParams.set(\"X-Amz-Signature\", await this.signature());\n      if (this.sessionToken && this.appendSessionToken) {\n        this.url.searchParams.set(\"X-Amz-Security-Token\", this.sessionToken);\n      }\n    } else {\n      this.headers.set(\"Authorization\", await this.authHeader());\n    }\n\n    return {\n      method: this.method,\n      url: this.url,\n      headers: this.headers,\n      body: this.body,\n    };\n  }\n\n  async authHeader(): Promise<string> {\n    return [\n      \"AWS4-HMAC-SHA256 Credential=\" +\n        this.accessKeyId +\n        \"/\" +\n        this.credentialString,\n      \"SignedHeaders=\" + this.signedHeaders,\n      \"Signature=\" + (await this.signature()),\n    ].join(\", \");\n  }\n\n  async signature(): Promise<string> {\n    const date = this.datetime.slice(0, 8);\n    const cacheKey = [\n      this.secretAccessKey,\n      date,\n      this.region,\n      this.service,\n    ].join();\n    let kCredentials = this.cache.get(cacheKey);\n    if (!kCredentials) {\n      const kDate = await hmac(\"AWS4\" + this.secretAccessKey, date);\n      const kRegion = await hmac(kDate, this.region);\n      const kService = await hmac(kRegion, this.service);\n      kCredentials = await hmac(kService, \"aws4_request\");\n      this.cache.set(cacheKey, kCredentials);\n    }\n    return buf2hex(await hmac(kCredentials, await this.stringToSign()));\n  }\n\n  async stringToSign(): Promise<string> {\n    return [\n      \"AWS4-HMAC-SHA256\",\n      this.datetime,\n      this.credentialString,\n      buf2hex(await hash(await this.canonicalString())),\n    ].join(\"\\n\");\n  }\n\n  async canonicalString(): Promise<string> {\n    return [\n      this.method.toUpperCase(),\n      this.encodedPath,\n      this.encodedSearch,\n      this.canonicalHeaders + \"\\n\",\n      this.signedHeaders,\n      await this.hexBodyHash(),\n    ].join(\"\\n\");\n  }\n\n  async hexBodyHash(): Promise<string> {\n    let hashHeader = this.headers.get(\"X-Amz-Content-Sha256\");\n    if (hashHeader == null) {\n      if (\n        this.body &&\n        typeof this.body !== \"string\" &&\n        !(\"byteLength\" in this.body)\n      ) {\n        throw new RuntimeError(\n          \"body must be a string, ArrayBuffer or ArrayBufferView, unless you include the X-Amz-Content-Sha256 header\"\n        );\n      }\n      hashHeader = buf2hex(await hash(this.body || \"\"));\n    }\n    return hashHeader;\n  }\n}\n\nasync function hmac(\n  key: string | ArrayBuffer,\n  val: string\n): Promise<ArrayBuffer> {\n  const cryptoKey = await crypto.subtle.importKey(\n    \"raw\",\n    typeof key === \"string\" ? encoder.encode(key) : key,\n    { name: \"HMAC\", hash: { name: \"SHA-256\" } },\n    false,\n    [\"sign\"]\n  );\n  return crypto.subtle.sign(\"HMAC\", cryptoKey, encoder.encode(val));\n}\n\nasync function hash(\n  content: string | ArrayBuffer | ArrayBufferView\n): Promise<ArrayBuffer> {\n  return crypto.subtle.digest(\n    \"SHA-256\",\n    typeof content === \"string\" ? encoder.encode(content) : content\n  );\n}\n\nfunction buf2hex(\n  buffer: ArrayBuffer | ArrayLike<number> | SharedArrayBuffer\n): string {\n  return Array.prototype.map\n    .call(new Uint8Array(buffer), (x) => (\"0\" + x.toString(16)).slice(-2))\n    .join(\"\");\n}\n\nfunction encodeRfc3986(urlEncodedStr: string): string {\n  return urlEncodedStr.replace(\n    /[!'()*]/g,\n    (c) => \"%\" + c.charCodeAt(0).toString(16).toUpperCase()\n  );\n}\n\nfunction guessServiceRegion(url: URL, headers: Headers): string[] {\n  const { hostname, pathname } = url;\n  const match = hostname\n    .replace(\"dualstack.\", \"\")\n    .match(/([^.]+)\\.(?:([^.]*)\\.)?amazonaws\\.com(?:\\.cn)?$/);\n  let [service, region] = (match || [\"\", \"\"]).slice(1, 3);\n\n  if (region === \"us-gov\") {\n    region = \"us-gov-west-1\";\n  } else if (region === \"s3\" || region === \"s3-accelerate\") {\n    region = \"us-east-1\";\n    service = \"s3\";\n  } else if (service === \"iot\") {\n    if (hostname.startsWith(\"iot.\")) {\n      service = \"execute-api\";\n    } else if (hostname.startsWith(\"data.jobs.iot.\")) {\n      service = \"iot-jobs-data\";\n    } else {\n      service = pathname === \"/mqtt\" ? \"iotdevicegateway\" : \"iotdata\";\n    }\n  } else if (service === \"autoscaling\") {\n    const targetPrefix = (headers.get(\"X-Amz-Target\") || \"\").split(\".\")[0];\n    if (targetPrefix === \"AnyScaleFrontendService\") {\n      service = \"application-autoscaling\";\n    } else if (targetPrefix === \"AnyScaleScalingPlannerFrontendService\") {\n      service = \"autoscaling-plans\";\n    }\n  } else if (region == null && service.startsWith(\"s3-\")) {\n    region = service.slice(3).replace(/^fips-|^external-1/, \"\");\n    service = \"s3\";\n  } else if (service.endsWith(\"-fips\")) {\n    service = service.slice(0, -5);\n  } else if (region && /-\\d$/.test(service) && !/-\\d$/.test(region)) {\n    [service, region] = [region, service];\n  }\n\n  if (service in HOST_SERVICES) {\n    return [HOST_SERVICES[service], region];\n  }\n\n  return [service, region];\n}\n", "// Utilities for converting binary to and from Base64\n// SOURCE: https://developer.mozilla.org/en-US/docs/Glossary/Base64\n\n// Array of bytes to Base64 string decoding\nfunction b64ToUint6(nChr: number) {\n  return nChr > 64 && nChr < 91\n    ? nChr - 65\n    : nChr > 96 && nChr < 123\n    ? nChr - 71\n    : nChr > 47 && nChr < 58\n    ? nChr + 4\n    : nChr === 43\n    ? 62\n    : nChr === 47\n    ? 63\n    : 0;\n}\n\n/**\n * Base64 encoded string to UTF8 array\n */\nexport function base64Decode(\n  sBase64: string,\n  nBlocksSize?: number\n): Uint8Array {\n  const sB64Enc = sBase64.replace(/[^A-Za-z0-9+/]/g, \"\"); // Remove any non-base64 characters, such as trailing \"=\", whitespace, and more.\n  const nInLen = sB64Enc.length;\n  const nOutLen = nBlocksSize\n    ? Math.ceil(((nInLen * 3 + 1) >> 2) / nBlocksSize) * nBlocksSize\n    : (nInLen * 3 + 1) >> 2;\n  const taBytes = new Uint8Array(nOutLen);\n\n  let nMod3;\n  let nMod4;\n  let nUint24 = 0;\n  let nOutIdx = 0;\n  for (let nInIdx = 0; nInIdx < nInLen; nInIdx++) {\n    nMod4 = nInIdx & 3;\n    nUint24 |= b64ToUint6(sB64Enc.charCodeAt(nInIdx)) << (6 * (3 - nMod4));\n    if (nMod4 === 3 || nInLen - nInIdx === 1) {\n      nMod3 = 0;\n      while (nMod3 < 3 && nOutIdx < nOutLen) {\n        taBytes[nOutIdx] = (nUint24 >>> ((16 >>> nMod3) & 24)) & 255;\n        nMod3++;\n        nOutIdx++;\n      }\n      nUint24 = 0;\n    }\n  }\n\n  return taBytes;\n}\n\n/* Base64 string to array encoding */\nfunction uint6ToB64(nUint6: number) {\n  return nUint6 < 26\n    ? nUint6 + 65\n    : nUint6 < 52\n    ? nUint6 + 71\n    : nUint6 < 62\n    ? nUint6 - 4\n    : nUint6 === 62\n    ? 43\n    : nUint6 === 63\n    ? 47\n    : 65;\n}\n\n/**\n * UTF8 array to base64 encoded string\n */\nexport function base64Encode(aBytes: Uint8Array) {\n  let nMod3 = 2;\n  let sB64Enc = \"\";\n\n  const nLen = aBytes.length;\n  let nUint24 = 0;\n  for (let nIdx = 0; nIdx < nLen; nIdx++) {\n    nMod3 = nIdx % 3;\n    // To break your base64 into several 80-character lines, add:\n    //   if (nIdx > 0 && ((nIdx * 4) / 3) % 76 === 0) {\n    //      sB64Enc += \"\\r\\n\";\n    //    }\n\n    nUint24 |= aBytes[nIdx] << ((16 >>> nMod3) & 24);\n    if (nMod3 === 2 || aBytes.length - nIdx === 1) {\n      sB64Enc += String.fromCodePoint(\n        uint6ToB64((nUint24 >>> 18) & 63),\n        uint6ToB64((nUint24 >>> 12) & 63),\n        uint6ToB64((nUint24 >>> 6) & 63),\n        uint6ToB64(nUint24 & 63)\n      );\n      nUint24 = 0;\n    }\n  }\n  return (\n    sB64Enc.substring(0, sB64Enc.length - 2 + nMod3) +\n    (nMod3 === 2 ? \"\" : nMod3 === 1 ? \"=\" : \"==\")\n  );\n}\n\n/**\n * Convert UTF8 array string\n */\nexport function convertUtf8ArrayToString(aBytes: Uint8Array): string {\n  let sView = \"\";\n  let nPart;\n  const nLen = aBytes.length;\n  for (let nIdx = 0; nIdx < nLen; nIdx++) {\n    nPart = aBytes[nIdx];\n    sView += String.fromCodePoint(\n      nPart > 251 && nPart < 254 && nIdx + 5 < nLen /* six bytes */\n        ? /* (nPart - 252 << 30) may be not so safe in ECMAScript! So\u2026: */\n          (nPart - 252) * 1073741824 +\n            ((aBytes[++nIdx] - 128) << 24) +\n            ((aBytes[++nIdx] - 128) << 18) +\n            ((aBytes[++nIdx] - 128) << 12) +\n            ((aBytes[++nIdx] - 128) << 6) +\n            aBytes[++nIdx] -\n            128\n        : nPart > 247 && nPart < 252 && nIdx + 4 < nLen /* five bytes */\n        ? ((nPart - 248) << 24) +\n          ((aBytes[++nIdx] - 128) << 18) +\n          ((aBytes[++nIdx] - 128) << 12) +\n          ((aBytes[++nIdx] - 128) << 6) +\n          aBytes[++nIdx] -\n          128\n        : nPart > 239 && nPart < 248 && nIdx + 3 < nLen /* four bytes */\n        ? ((nPart - 240) << 18) +\n          ((aBytes[++nIdx] - 128) << 12) +\n          ((aBytes[++nIdx] - 128) << 6) +\n          aBytes[++nIdx] -\n          128\n        : nPart > 223 && nPart < 240 && nIdx + 2 < nLen /* three bytes */\n        ? ((nPart - 224) << 12) +\n          ((aBytes[++nIdx] - 128) << 6) +\n          aBytes[++nIdx] -\n          128\n        : nPart > 191 && nPart < 224 && nIdx + 1 < nLen /* two bytes */\n        ? ((nPart - 192) << 6) + aBytes[++nIdx] - 128\n        : /* nPart < 127 ? */ /* one byte */\n          nPart\n    );\n  }\n  return sView;\n}\n\n/**\n * Convert string encoded UTF8 array\n */\nexport function convertStringToUtf8Array(sDOMStr: string): Uint8Array {\n  let nChr;\n  const nStrLen = sDOMStr.length;\n  let nArrLen = 0;\n\n  /* mapping\u2026 */\n  for (let nMapIdx = 0; nMapIdx < nStrLen; nMapIdx++) {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    nChr = sDOMStr.codePointAt(nMapIdx)!;\n\n    if (nChr >= 0x10000) {\n      nMapIdx++;\n    }\n\n    nArrLen +=\n      nChr < 0x80\n        ? 1\n        : nChr < 0x800\n        ? 2\n        : nChr < 0x10000\n        ? 3\n        : nChr < 0x200000\n        ? 4\n        : nChr < 0x4000000\n        ? 5\n        : 6;\n  }\n\n  const aBytes = new Uint8Array(nArrLen);\n\n  /* transcription\u2026 */\n  let nIdx = 0;\n  let nChrIdx = 0;\n  while (nIdx < nArrLen) {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    nChr = sDOMStr.codePointAt(nChrIdx)!;\n    if (nChr < 128) {\n      /* one byte */\n      aBytes[nIdx++] = nChr;\n    } else if (nChr < 0x800) {\n      /* two bytes */\n      aBytes[nIdx++] = 192 + (nChr >>> 6);\n      aBytes[nIdx++] = 128 + (nChr & 63);\n    } else if (nChr < 0x10000) {\n      /* three bytes */\n      aBytes[nIdx++] = 224 + (nChr >>> 12);\n      aBytes[nIdx++] = 128 + ((nChr >>> 6) & 63);\n      aBytes[nIdx++] = 128 + (nChr & 63);\n    } else if (nChr < 0x200000) {\n      /* four bytes */\n      aBytes[nIdx++] = 240 + (nChr >>> 18);\n      aBytes[nIdx++] = 128 + ((nChr >>> 12) & 63);\n      aBytes[nIdx++] = 128 + ((nChr >>> 6) & 63);\n      aBytes[nIdx++] = 128 + (nChr & 63);\n      nChrIdx++;\n    } else if (nChr < 0x4000000) {\n      /* five bytes */\n      aBytes[nIdx++] = 248 + (nChr >>> 24);\n      aBytes[nIdx++] = 128 + ((nChr >>> 18) & 63);\n      aBytes[nIdx++] = 128 + ((nChr >>> 12) & 63);\n      aBytes[nIdx++] = 128 + ((nChr >>> 6) & 63);\n      aBytes[nIdx++] = 128 + (nChr & 63);\n      nChrIdx++;\n    } /* if (nChr <= 0x7fffffff) */ else {\n      /* six bytes */\n      aBytes[nIdx++] = 252 + (nChr >>> 30);\n      aBytes[nIdx++] = 128 + ((nChr >>> 24) & 63);\n      aBytes[nIdx++] = 128 + ((nChr >>> 18) & 63);\n      aBytes[nIdx++] = 128 + ((nChr >>> 12) & 63);\n      aBytes[nIdx++] = 128 + ((nChr >>> 6) & 63);\n      aBytes[nIdx++] = 128 + (nChr & 63);\n      nChrIdx++;\n    }\n    nChrIdx++;\n  }\n\n  return aBytes;\n}\n", "/*!\n * Source: https://github.com/lludol/clf-date/blob/master/src/main.js\n *\n * The MIT License (MIT)\n * Copyright (c) 2016 Lerus Ludovic\n *\n */\n\n/**\n * Convert the Number to String with 0 at the beginning.\n */\nfunction numberToString(n: number): string {\n  const str = n.toString();\n  return `${str.length === 1 ? \"0\" : \"\"}${str}`;\n}\n\n/**\n * Return the offset from UTC in CLF format.\n */\nfunction getCLFOffset(date: Date): string {\n  const tzoffset = date.getTimezoneOffset();\n  const abstzoffset = Math.abs(tzoffset);\n  const op = tzoffset > 0 ? \"-\" : \"+\"; // TimezoneOffset is set as subtraction from localtime to UTC,\n  //    on the other hand time in CLF is shown as subtraction from UTC to localtime.\n  const hour = numberToString(Math.floor(abstzoffset / 60));\n  const min = numberToString(abstzoffset % 60);\n  return `${op}${hour}${min}`;\n}\n\nexport function toCLFDate(now = new Date()) {\n  if (!(now instanceof Date)) {\n    throw new Error(\"clf-date: invalid parameter\");\n  }\n\n  const MONTHS = [\n    \"Jan\",\n    \"Feb\",\n    \"Mar\",\n    \"Apr\",\n    \"May\",\n    \"Jun\",\n    \"Jul\",\n    \"Aug\",\n    \"Sep\",\n    \"Oct\",\n    \"Nov\",\n    \"Dec\",\n  ];\n\n  const day = numberToString(now.getDate());\n  const month = MONTHS[now.getMonth()];\n  const year = now.getFullYear();\n\n  const hours = numberToString(now.getHours());\n  const minutes = numberToString(now.getMinutes());\n  const seconds = numberToString(now.getSeconds());\n\n  const offset = getCLFOffset(now);\n\n  return `${day}/${month}/${year}:${hours}:${minutes}:${seconds} ${offset}`;\n}\n", "import { debug } from \"@zuplo/debug\";\nimport { compile, parse } from \"path-to-regexp\";\nimport { ZuploContext } from \"../context\";\nimport { ConfigurationError, RuntimeError } from \"../errors\";\nimport { HttpProblems } from \"../index.worker\";\nimport { ZuploRequest } from \"../request\";\nimport { AwsClient } from \"../utils/aws\";\nimport { base64Decode, base64Encode } from \"../utils/base64\";\nimport { toCLFDate } from \"../utils/clf-date\";\n\nconst log = debug(\"zuplo:runtime\");\n\nconst AMZN_TRACE_ID_HEADER = \"X-Amzn-Trace-Id\";\nconst AMZN_ERROR_TYPE_HEADER = \"x-amzn-errortype\";\n//\n// This handler attempts to replicate the bahaviour of the AWS API Gateway\n// Docs:\n//\n// https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-payload-encodings.html\n// https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-payload-encodings-workflow.html\n// https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop-integrations-lambda.html\n\nexport interface AwsLambdaEventV1 {\n  [key: string]: string | null | undefined | number | boolean | object;\n  version: \"1.0\";\n  resource: string;\n  path: string;\n  httpMethod: string;\n  headers: Record<string, string>;\n  multiValueHeaders: Record<string, string[]>;\n  queryStringParameters: Record<string, string>;\n  multiValueQueryStringParameters: Record<string, string[]>;\n  requestContext: {\n    accountId: string | null;\n    apiId: string | null;\n    authorizer: {\n      claims: Record<string, string>;\n      scopes: string[];\n    };\n    domainName: string;\n    domainPrefix: string | null;\n    extendedRequestId: string;\n    httpMethod: string;\n    identity: {\n      accessKey: null | string;\n      accountId: null | string;\n      caller: null | string;\n      cognitoAuthenticationProvider: null | string;\n      cognitoAuthenticationType: null | string;\n      cognitoIdentityId: null | string;\n      cognitoIdentityPoolId: null | string;\n      principalOrgId: null | string;\n      sourceIp: string | null;\n      user: null | string;\n      userAgent: string | null;\n      userArn: null | string;\n      clientCert: {\n        clientCertPem: null | string;\n        subjectDN: null | string;\n        issuerDN: null | string;\n        serialNumber: null | string;\n        validity: {\n          notBefore: null | string;\n          notAfter: null | string;\n        };\n      };\n    };\n    path: string;\n    protocol: string;\n    requestId: string;\n    requestTime: string;\n    requestTimeEpoch: number;\n    resourceId: string | null;\n    resourcePath: string;\n    stage: null | string;\n  };\n  pathParameters: Record<string, string>;\n  stageVariables: null | Record<string, string>;\n}\n\nexport interface AwsLambdaEventV2 {\n  [key: string]: string | null | undefined | number | boolean | object;\n  version: \"2.0\";\n  routeKey: string | null;\n  rawPath: string;\n  rawQueryString: string;\n  cookies: string[];\n  headers: Record<string, string>;\n  queryStringParameters: Record<string, string>;\n  requestContext: {\n    accountId: string | null;\n    apiId: string | null;\n    authentication: {\n      clientCert: {\n        clientCertPem: string | null;\n        subjectDN: string | null;\n        issuerDN: string | null;\n        serialNumber: string | null;\n        validity: {\n          notBefore: string | null;\n          notAfter: string | null;\n        };\n      };\n    };\n    authorizer: {\n      jwt: {\n        claims: Record<string, string>;\n        scopes: string[];\n      };\n    };\n    domainName: string | null;\n    domainPrefix: string | null;\n    http: {\n      method: string;\n      path: string;\n      protocol: string;\n      sourceIp: string | null;\n      userAgent: string | null;\n    };\n    requestId: string;\n    routeKey: string | null;\n    stage: null;\n    time: string;\n    timeEpoch: number;\n  };\n  pathParameters: Record<string, string>;\n  stageVariables: string | null;\n}\n\nexport interface OnSendingAwsLambdaEventHook {\n  (\n    request: ZuploRequest,\n    context: ZuploContext,\n    event: AwsLambdaEventV1 | AwsLambdaEventV2\n  ): Promise<AwsLambdaEventV1 | AwsLambdaEventV2>;\n}\n\nconst onSendingAwsLambdaEventHooks: OnSendingAwsLambdaEventHook[] = [];\nconst onSendingAwsLambdaEvent: OnSendingAwsLambdaEventHook = async (\n  request,\n  context,\n  event\n) => {\n  let current = event;\n  for await (const hook of onSendingAwsLambdaEventHooks) {\n    current = await hook(request, context, event);\n  }\n  return current;\n};\n\nclass AwsLambdaError extends RuntimeError {\n  traceId: string | undefined;\n  errorType: string | undefined;\n  constructor(message: string, headers: Headers) {\n    super(`Failed to invoke AWS Lambda function. ${message}`);\n    this.traceId = headers.get(AMZN_TRACE_ID_HEADER) ?? undefined;\n    this.errorType = headers.get(AMZN_ERROR_TYPE_HEADER) ?? undefined;\n  }\n}\n\n// Public extension for user's to register the hook\nexport const AwsLambdaHandlerExtensions = {\n  addSendingAwsLambdaEventHook: (hook: OnSendingAwsLambdaEventHook) => {\n    onSendingAwsLambdaEventHooks.push(hook);\n  },\n};\n\n/**\n * @beta\n */\ninterface AwsLambdaHandlerOptions {\n  accessKeyId: string;\n  secretAccessKey: string;\n  region: string;\n  functionName: string;\n  /**\n   * Requests will be proxied to Lambda with request\n   * details available in the `event` of your handler function.\n   */\n  useLambdaProxyIntegration?: boolean;\n  payloadFormatVersion?: \"1.0\" | \"2.0\";\n  useAwsResourcePathStyle?: boolean;\n  /**\n   * The mime types to convert to base64 encoded binary strings.\n   */\n  binaryMediaTypes?: string[];\n  /**\n   * Include the X-Amzn-Trace-Id header in the response\n   */\n  returnAmazonTraceIdHeader?: boolean;\n}\n\n/**\n * Proxy requests to a different url\n * @param request - The ZuploRequest\n * @param context - The ZuploContext\n * @returns\n * @beta\n */\nexport async function awsLambdaHandler(\n  request: ZuploRequest,\n  context: ZuploContext\n) {\n  const {\n    accessKeyId,\n    secretAccessKey,\n    region,\n    functionName,\n    useLambdaProxyIntegration = true,\n    useAwsResourcePathStyle = false,\n    binaryMediaTypes,\n  } = context.route.handler.options as AwsLambdaHandlerOptions;\n  if (!accessKeyId) {\n    throw new ConfigurationError(\n      \"awsAccessKeyId is not set in the handler options\"\n    );\n  }\n  if (!secretAccessKey) {\n    throw new ConfigurationError(\n      \"secretAccessKey is not set in the handler options\"\n    );\n  }\n  if (!region) {\n    throw new ConfigurationError(\"region is not set in the handler options\");\n  }\n  if (!functionName) {\n    throw new ConfigurationError(\n      \"functionName is not set in the handler options\"\n    );\n  }\n\n  const aws = new AwsClient({\n    accessKeyId,\n    secretAccessKey,\n  });\n\n  // https://docs.aws.amazon.com/lambda/latest/dg/API_Invoke.html\n  const lambdaApiUrl = `https://lambda.${region}.amazonaws.com/2015-03-31/functions/${functionName}/invocations`;\n  log(`AWS Lambda URL: ${lambdaApiUrl}`);\n\n  if (!useLambdaProxyIntegration) {\n    return aws.fetch(lambdaApiUrl, {\n      body: await request.arrayBuffer(),\n    });\n  }\n\n  const [body, isBase64Encoded] = await getBodyResult(request, {\n    binaryMediaTypes,\n  });\n\n  const { options } = context.route.handler;\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  let event: any;\n  if (\n    options &&\n    typeof options === \"object\" &&\n    \"payloadFormatVersion\" in options &&\n    options.payloadFormatVersion === \"2.0\"\n  ) {\n    event = buildEventVersion2(request, context);\n  } else {\n    event = await buildEventVersion1(request, context, {\n      useAwsResourcePathStyle,\n    });\n  }\n\n  log(\"Calling onSendingAwsLambdaEvent hook\");\n  const modifiedEvent = await onSendingAwsLambdaEvent(request, context, event);\n\n  // add the body to the event\n  modifiedEvent.body = body;\n  modifiedEvent.isBase64Encoded = isBase64Encoded;\n\n  const lambdaResponse = await aws.fetch(lambdaApiUrl, {\n    body: JSON.stringify(modifiedEvent),\n  });\n\n  try {\n    return getResponse(lambdaResponse);\n  } catch (err) {\n    if (err instanceof AwsLambdaError) {\n      const headers =\n        options &&\n        typeof options === \"object\" &&\n        \"returnAmazonTraceIdHeader\" in options &&\n        options.returnAmazonTraceIdHeader &&\n        err.traceId\n          ? { AMZN_TRACE_ID_HEADER: err.traceId }\n          : undefined;\n      return HttpProblems.internalServerError(\n        request,\n        context,\n        undefined,\n        headers\n      );\n    }\n    throw err;\n  }\n}\n\nexport async function getResponse(lambdaResponse: Response) {\n  let json: unknown;\n  try {\n    json = await lambdaResponse.json();\n  } catch (err) {\n    throw new AwsLambdaError(\n      `Lambda response did not contain valid JSON`,\n      lambdaResponse.headers\n    );\n  }\n\n  if (lambdaResponse.status !== 200) {\n    // 1. If the status code is not 200, then this is an error calling\n    // the AWS API. https://docs.aws.amazon.com/lambda/latest/dg/API_Invoke.html\n    if (\n      json &&\n      typeof json === \"object\" &&\n      \"message\" in json &&\n      typeof json.message === \"string\"\n    ) {\n      throw new AwsLambdaError(json.message, lambdaResponse.headers);\n    }\n    throw new AwsLambdaError(\n      `Status: ${lambdaResponse.statusText}`,\n      lambdaResponse.headers\n    );\n  } else if (\n    json &&\n    typeof json === \"object\" &&\n    \"errorMessage\" in json &&\n    typeof json.errorMessage === \"string\"\n  ) {\n    // 2. If the response is a 200 and the body has a errorMessage value,\n    // the API call to AWS was okay, but there was an error invoking the\n    // function. (i.e. the Lambda call timed out, etc.)\n    throw new AwsLambdaError(json.errorMessage, lambdaResponse.headers);\n  } else if (\n    !json ||\n    typeof json !== \"object\" ||\n    !(\"statusCode\" in json) ||\n    typeof json.statusCode !== \"number\"\n  ) {\n    // 3. No statusCode so the response is treated as the body\n    // and the content type is assumed to be JSON.\n    return new Response(JSON.stringify(json), {\n      status: lambdaResponse.status,\n      headers: {\n        \"content-type\": \"application/json\",\n      },\n    });\n  }\n\n  // 4. The response contains a statusCode so it is expected that the\n  // json object is in the Lambda response format:\n  // {\n  //     \"cookies\" : [\"cookie1\", \"cookie2\"],\n  //     \"isBase64Encoded\": true|false,\n  //     \"bodyEncoding\": \"gzip|deflate\",\n  //     \"statusCode\": httpStatusCode,\n  //     \"headers\": { \"headername\": \"headervalue\", ... },\n  //     \"body\": \"Hello from Lambda!\"\n  // }\n\n  const headers = new Headers();\n  if (\"headers\" in json && json.headers) {\n    if (typeof json.headers !== \"object\") {\n      throw new AwsLambdaError(\n        `Response headers must be an object. Received ${typeof json.headers}`,\n        lambdaResponse.headers\n      );\n    }\n    for (const [key, value] of Object.entries(json.headers)) {\n      headers.set(key, value as string);\n    }\n  }\n\n  if (\"cookies\" in json && json.cookies) {\n    if (!Array.isArray(json.cookies)) {\n      throw new AwsLambdaError(\n        `Response cookies must be an array. Received ${typeof json.cookies}`,\n        lambdaResponse.headers\n      );\n    }\n    headers.set(\"cookie\", json.cookies.join(\";\"));\n  }\n\n  let body: string | ArrayBuffer | null;\n  if (\"isBase64Encoded\" in json && typeof json.isBase64Encoded !== \"boolean\") {\n    throw new AwsLambdaError(\n      `Response property isBase64Encoded must be a boolean. Received ${typeof json.isBase64Encoded}`,\n      lambdaResponse.headers\n    );\n  } else if (\"isBase64Encoded\" in json && json.isBase64Encoded === true) {\n    if (!(\"body\" in json)) {\n      throw new AwsLambdaError(\n        \"Response was set to base64 encoded but no body was set\",\n        lambdaResponse.headers\n      );\n    }\n    if (typeof json.body !== \"string\") {\n      throw new AwsLambdaError(\n        \"Response was set to base64 encoded but body was not a string\",\n        lambdaResponse.headers\n      );\n    }\n    body = base64Decode(json.body);\n  } else if (\"body\" in json && typeof json.body === \"string\") {\n    // In the event that the body is an empty string and the status code\n    // is 204, force the body to be null. Arguably we should let this throw\n    // Need to check if API Gateway behaves this way\n    body = json.statusCode === 204 && json.body === \"\" ? null : json.body;\n  } else if (\"body\" in json && json.body !== null && json.body !== undefined) {\n    body = JSON.stringify(json.body);\n  } else {\n    body = null;\n  }\n\n  if (body !== null && \"bodyEncoding\" in json) {\n    if (\n      typeof json.bodyEncoding !== \"string\" ||\n      !(json.bodyEncoding === \"gzip\" || json.bodyEncoding === \"deflate\")\n    ) {\n      throw new AwsLambdaError(\n        `Response property bodyEncoding can only be set to 'gzip' or 'deflate'. Received ${json.bodyEncoding}`,\n        lambdaResponse.headers\n      );\n    }\n    // If the body is compressed, create a stream and pipe through\n    // DecompressionStream to extra on the way out\n    // A bit silly because cloudflare will compress this again\n    // if the Accept-Encoding header is set to gzip or br, but we can't\n    // do anything about that in workers.\n    // Also this is going to cause a lot of memory exceptions\n    const blob = new Blob([body])\n      .stream()\n      .pipeThrough(new DecompressionStream(json.bodyEncoding));\n    body = await new Response(blob).arrayBuffer();\n  }\n\n  return new Response(body, {\n    headers,\n    status: json.statusCode,\n  });\n}\n\n// Build the v1.0 event object\n//\nasync function buildEventVersion1(\n  request: ZuploRequest,\n  context: ZuploContext,\n  {\n    useAwsResourcePathStyle,\n  }: {\n    useAwsResourcePathStyle: boolean;\n  }\n) {\n  const headers: Record<string, string> = {};\n  const multiValueHeaders: Record<string, string[]> = {};\n  request.headers.forEach((value, key) => {\n    headers[key] = value;\n    multiValueHeaders[key] = [value];\n  });\n\n  const queryStringParameters = request.query;\n  const multiValueQueryStringParameters: Record<string, string[]> = {};\n  for (const [key, value] of Object.entries(queryStringParameters)) {\n    multiValueQueryStringParameters[key] = [value];\n  }\n\n  const url = new URL(request.url);\n\n  const event: AwsLambdaEventV1 = {\n    version: \"1.0\",\n    resource: url.pathname,\n    path: url.pathname,\n    httpMethod: request.method,\n    headers,\n    multiValueHeaders,\n    queryStringParameters,\n    multiValueQueryStringParameters,\n    requestContext: {\n      accountId: null,\n      apiId: null,\n      authorizer: {\n        claims: {},\n        scopes: [],\n      },\n      domainName: url.hostname,\n      domainPrefix: null,\n      extendedRequestId: context.requestId,\n      httpMethod: request.method,\n      identity: {\n        accessKey: null,\n        accountId: null,\n        caller: null,\n        cognitoAuthenticationProvider: null,\n        cognitoAuthenticationType: null,\n        cognitoIdentityId: null,\n        cognitoIdentityPoolId: null,\n        principalOrgId: null,\n        sourceIp: request.headers.get(\"CF-Connecting-IP\"),\n        user: null,\n        userAgent: request.headers.get(\"user-agent\"),\n        userArn: null,\n        clientCert: {\n          clientCertPem: null,\n          subjectDN: null,\n          issuerDN: null,\n          serialNumber: null,\n          validity: {\n            notBefore: null,\n            notAfter: null,\n          },\n        },\n      },\n      path: url.pathname,\n      protocol: \"HTTP/1.1\",\n      requestId: context.requestId,\n      requestTime: toCLFDate(),\n      requestTimeEpoch: new Date().valueOf(),\n      resourceId: context.route.operationId ?? null,\n      resourcePath: getResourcePath(\n        context.route.path,\n        useAwsResourcePathStyle\n      ),\n      stage: null,\n    },\n    pathParameters: request.params,\n    stageVariables: null,\n  };\n  return event;\n}\n\n// Build the v2.0 event object\nfunction buildEventVersion2(\n  request: ZuploRequest,\n  context: ZuploContext\n): AwsLambdaEventV2 {\n  const headers: Record<string, string> = {};\n  request.headers.forEach((value, key) => {\n    headers[key] = value;\n  });\n\n  const url = new URL(request.url);\n\n  const event: AwsLambdaEventV2 = {\n    version: \"2.0\",\n    routeKey: null,\n    rawPath: url.pathname,\n    rawQueryString: url.search,\n    cookies: [],\n    headers,\n    queryStringParameters: request.query,\n    requestContext: {\n      accountId: null,\n      apiId: null,\n      authentication: {\n        clientCert: {\n          clientCertPem: null,\n          subjectDN: null,\n          issuerDN: null,\n          serialNumber: null,\n          validity: {\n            notBefore: null,\n            notAfter: null,\n          },\n        },\n      },\n      authorizer: {\n        jwt: {\n          claims: {},\n          scopes: [],\n        },\n      },\n      domainName: url.hostname,\n      domainPrefix: null,\n      http: {\n        method: request.method,\n        path: url.pathname,\n        protocol: \"HTTP/1.1\",\n        sourceIp: request.headers.get(\"CF-Connecting-IP\"),\n        userAgent: request.headers.get(\"user-agent\"),\n      },\n      requestId: context.requestId,\n      routeKey: null,\n      stage: null,\n      time: toCLFDate(),\n      timeEpoch: new Date().valueOf(),\n    },\n    pathParameters: request.params,\n    stageVariables: null,\n  };\n  return event;\n}\n\nasync function getBodyResult(\n  request: Request,\n  {\n    binaryMediaTypes,\n  }: {\n    binaryMediaTypes?: string[];\n  }\n): Promise<[string | null, boolean]> {\n  // TODO: This should be something more universal, but its fine for now\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  let body: string | null;\n  let isBase64Encoded = false;\n  const contentType = request.headers.get(\"content-type\");\n  if (request.method === \"GET\" || request.method === \"HEAD\") {\n    // GET and HEAD requests never have a body\n    body = null;\n  } else if (\n    binaryMediaTypes &&\n    contentType &&\n    matchesContentType(binaryMediaTypes, contentType)\n  ) {\n    // If the content type is included in the list of binary types, then it\n    // needs to be base64 encoded\n    const buffer = await request.arrayBuffer();\n    body = base64Encode(new Uint8Array(buffer));\n    isBase64Encoded = true;\n  } else {\n    body = await request.clone().text();\n  }\n  return [body, isBase64Encoded];\n}\n\n// TODO: this would be a good spot for LRU caching\nfunction matchesContentType(\n  binaryMediaTypes: string[],\n  contentType: string\n): boolean {\n  const normalizedMimeType = contentType.split(\";\")[0].trim().toLowerCase();\n  return (\n    binaryMediaTypes.findIndex((item) => {\n      if (item === \"*/*\") {\n        // If there is a full wildcard, then every content type\n        return true;\n      } else {\n        return item.toLowerCase() === normalizedMimeType;\n      }\n    }) > -1\n  );\n}\n\nfunction getResourcePath(routePath: string, useAwsResourcePathStyle = false) {\n  if (!useAwsResourcePathStyle) {\n    return routePath;\n  }\n\n  const tokens = parse(routePath);\n  const toPath = compile(routePath);\n\n  const params: Record<string, string> = {};\n  tokens.forEach((token) => {\n    if (typeof token === \"string\") {\n      params[token] = `{${token}}`;\n    } else {\n      params[token.name] = `{${token.name}}`;\n    }\n  });\n\n  return toPath(params);\n}\n", "import { LogLevel, ZuploContext } from \"../index.worker\";\nimport { SystemLogMap } from \"../system-log-map\";\nimport { Environment } from \"../utils/environment\";\n\nconst BAD_CODES = [502, 503, 504];\n\nexport async function logBadGatewayResponses(\n  response: Response,\n  context: ZuploContext\n) {\n  // If we get a Bad Gateway, Gateway Timeout or Service Unavailable\n  // we log as much information as possible to help customers debug. These\n  // responses should be non sensitive so we also log the body\n  // (which usually contains important information to debug this situation)\n  if (BAD_CODES.includes(response.status)) {\n    const systemLogger = SystemLogMap.getLogger(context);\n    const clone = response.clone();\n    const body = await clone.text();\n    const headers: Record<string, string> = {};\n    for (const [key, value] of response.headers) {\n      headers[key] = value;\n    }\n    systemLogger.warn(`BadGatewayResponse ${response.status}`, {\n      status: response.status,\n      statusText: response.statusText,\n      body,\n      headers,\n    });\n  }\n}\n\n// \uD83D\uDEA8\uD83D\uDEA8 HACK \uD83D\uDEA8\uD83D\uDEA8\n// This is some temp code to help customers debug their own response codes\n// when using the most popular handlers by upping the write level of our 'debug'\n// logs\nlet writeLogLevel: LogLevel;\n\nexport function getHandlerUserLogFunction(context: ZuploContext) {\n  if (writeLogLevel === undefined) {\n    let level = Environment.instance.runtime.ZUPLO_HANDLER_WRITE_LOG_LEVEL;\n\n    if (![\"debug\", \"info\", \"warn\", \"error\"].includes(level ?? \"\")) {\n      level = \"debug\";\n    }\n\n    writeLogLevel = level as LogLevel;\n  }\n\n  const handlerLogFunction = context.log[writeLogLevel];\n\n  return handlerLogFunction;\n}\n", "import { ZuploContext } from \"../context\";\nimport { ConfigurationError } from \"../errors\";\nimport internals from \"../internals\";\nimport { HttpProblems } from \"../problem-responses/http-problems\";\nimport { ZuploRequest } from \"../request\";\nimport { Environment } from \"../utils/environment\";\nimport { logBadGatewayResponses } from \"./util\";\n\n/**\n * @beta\n */\nexport interface OpenApiSpecHandlerOptions {\n  openApiFilePath: string;\n}\n\n/**\n * @beta\n * @param request - The ZuploRequest\n * @param context - The ZuploContext\n * @returns ZuploResponse\n */\nexport async function openApiSpecHandler(\n  request: ZuploRequest,\n  context: ZuploContext\n) {\n  const buildId = Environment.instance.build.BUILD_ID;\n  const { buildAssetsUrl } = Environment.instance;\n  const options = context.route.handler.options as OpenApiSpecHandlerOptions;\n  const { openApiFilePath } = options;\n\n  if (!openApiFilePath) {\n    throw new ConfigurationError(\n      `Open API Spec Handler must have 'openApiFilePath' specified`\n    );\n  }\n\n  const pathValidationResult = validateOpenApiPath(openApiFilePath);\n  if (!pathValidationResult.isValid) {\n    throw new ConfigurationError(pathValidationResult.error);\n  }\n\n  let openApiFileUrl: string;\n\n  if (Environment.instance.isLocalDevelopment) {\n    openApiFileUrl = `${buildAssetsUrl}/${openApiFilePath.substring(\n      1 // remove leading dot\n    )}`;\n  } else {\n    openApiFileUrl = `${buildAssetsUrl}/${buildId}${openApiFilePath.substring(\n      1 // remove leading dot\n    )}`;\n  }\n\n  const response = await internals.fetch(openApiFileUrl, {\n    method: request.method,\n    body: request.body,\n    headers: request.headers,\n  });\n\n  if (response.status !== 200) {\n    return HttpProblems.notFound(request, context, {\n      detail: \"OpenAPI file could not be found.\",\n    });\n  }\n\n  // We clear the existing headers to prevent browsers from caching the response\n  const headersRemovedResponse = new Response(response.body, {\n    headers: { \"content-type\": \"application/json\" },\n    status: response.status,\n    statusText: response.statusText,\n  });\n\n  void logBadGatewayResponses(headersRemovedResponse, context);\n\n  return headersRemovedResponse;\n}\n\nconst validateOpenApiPath = (\n  path: string\n): { isValid: true } | { isValid: false; error: string } => {\n  if (!path.startsWith(\"./\")) {\n    return { isValid: false, error: \"'openApiFilePath' must start with './'\" };\n  }\n\n  if (!path.startsWith(\"./config\")) {\n    return {\n      isValid: false,\n      error: \"'openApiFilePath' must point to a file in your /config directory\",\n    };\n  }\n\n  if (!path.endsWith(\".oas.json\")) {\n    return {\n      isValid: false,\n      error: \"'openApiFilePath' must point to a file ending in '.oas.json'\",\n    };\n  }\n\n  return { isValid: true };\n};\n", "import { ZuploContext } from \"../context\";\nimport { ConfigurationError } from \"../errors\";\nimport { ZuploRequest } from \"../request\";\n\n/**\n * @beta\n */\nexport interface RedirectHandlerOptions {\n  location: string;\n  status: number;\n}\n\n/**\n * @beta\n * @param request - The ZuploRequest\n * @param context - The ZuploContext\n * @returns ZuploResponse\n */\nexport async function redirectHandler(\n  request: ZuploRequest,\n  context: ZuploContext\n) {\n  const options = context.route.handler.options as RedirectHandlerOptions;\n\n  if (!options.location) {\n    throw new ConfigurationError(\n      `Redirect Handler must have 'location' specified`\n    );\n  }\n\n  const status = options.status ?? 302;\n\n  return new Response(null, {\n    status,\n    headers: {\n      location: options.location,\n    },\n  });\n}\n", "import { ZuploContext, ZuploForwardContext } from \"../context\";\nimport { ConfigurationError } from \"../errors\";\nimport internals from \"../internals\";\nimport { ZuploRequest } from \"../request\";\nimport { getHandlerUserLogFunction, logBadGatewayResponses } from \"./util\";\n\n/**\n * @beta\n */\nexport interface UrlForwardHandlerOptions {\n  baseUrl?: string;\n  forwardSearch?: boolean;\n  __rewriteFunction: (\n    request: ZuploRequest,\n    context: ZuploForwardContext\n  ) => string;\n}\n\nfunction join(base: string, path: string) {\n  const baseEndsSlash = base.endsWith(\"/\");\n  const pathStartsSlash = path.startsWith(\"/\");\n  if (baseEndsSlash && pathStartsSlash) {\n    return `${base.substring(0, base.length - 1)}${path}`;\n  }\n  if (!baseEndsSlash && !pathStartsSlash) {\n    return `${base}/${path}`;\n  }\n  // only one has a /\n  return `${base}${path}`;\n}\n\n/**\n * @beta\n * @param request - The ZuploRequest\n * @param context - The ZuploContext\n * @returns ZuploResponse\n */\nexport async function urlForwardHandler(\n  request: ZuploRequest,\n  context: ZuploContext\n) {\n  // TEMP - to be removed with logging upgrades\n  const userLogFunction = getHandlerUserLogFunction(context);\n\n  const options = context.route.handler.options as UrlForwardHandlerOptions;\n  // default to true unless explicitly false\n  const forwardSearch = options.forwardSearch === false ? false : true;\n\n  if (!options.baseUrl) {\n    throw new Error(`URL Forward Handler must have 'baseUrl' specified`);\n  }\n\n  if (!options || typeof options.__rewriteFunction !== \"function\") {\n    throw new ConfigurationError(\"Invalid options for this route\");\n  }\n\n  // Create context without the functions\n  const forwardContext: ZuploForwardContext = {\n    incomingRequestProperties: context.incomingRequestProperties,\n    requestId: context.requestId,\n    route: context.route,\n    custom: context.custom,\n  };\n\n  const incomingUrl = new URL(request.url);\n\n  const rewrittenBaseUrl = options.__rewriteFunction(request, forwardContext);\n  const newUrl = join(rewrittenBaseUrl, incomingUrl.pathname);\n  const newStringUrl = forwardSearch\n    ? `${newUrl}${incomingUrl.search}`\n    : newUrl.toString();\n\n  const start = Date.now();\n  userLogFunction(`URL Forwarding to '${newStringUrl}'`);\n\n  const result = await internals.fetch(newStringUrl, {\n    method: request.method,\n    body: request.body,\n    headers: request.headers,\n  });\n\n  const delta = Date.now() - start;\n  userLogFunction(\n    `URL Forward received response ${result.status} - ${result.statusText} in ${delta}ms`\n  );\n\n  void logBadGatewayResponses(result, context);\n\n  return result;\n}\n", "import { ZuploContext, ZuploRewriteContext } from \"../context\";\nimport { ConfigurationError } from \"../errors\";\nimport internals from \"../internals\";\nimport { ZuploRequest } from \"../request\";\nimport { getHandlerUserLogFunction, logBadGatewayResponses } from \"./util\";\n\n/**\n * @beta\n */\ninterface UrlRewriteHandlerOptions {\n  rewritePattern: string;\n  forwardSearch?: boolean;\n  __rewriteFunction: (\n    request: ZuploRequest,\n    context: ZuploRewriteContext\n  ) => string;\n  followRedirects?: boolean;\n}\n\n// Adds a dictionary of new query string params to a URL. Given the context in\n// which this used (URL Rewrite) - if the incoming urlString already has some\n// query parameters, they take precedent over the addParams.\nconst addQuery = (targetUrl: string, incomingUrl: string): string => {\n  const targetUrlAsURL = new URL(targetUrl);\n  const incomingUrlAsURL = new URL(incomingUrl);\n\n  for (const [key, value] of incomingUrlAsURL.searchParams.entries()) {\n    targetUrlAsURL.searchParams.append(key, value);\n  }\n\n  return targetUrlAsURL.toString();\n};\n\n/**\n * Proxy requests to a different url\n * @param request - The ZuploRequest\n * @param context - The ZuploContext\n * @returns\n * @beta\n */\nexport async function urlRewriteHandler(\n  request: ZuploRequest,\n  context: ZuploContext\n) {\n  // TEMP - to be removed\n  const userLogFunction = getHandlerUserLogFunction(context);\n\n  const options = context.route.handler.options as UrlRewriteHandlerOptions;\n\n  // default to true if not explicitly false\n  const innerForwardSearch = options.forwardSearch === false ? false : true;\n  const shouldFollowRedirects = options.followRedirects ?? false;\n\n  if (!options || typeof options.__rewriteFunction !== \"function\") {\n    throw new ConfigurationError(\"Invalid options for this route\");\n  }\n\n  // Create context without the functions\n  const rewriteContext: ZuploRewriteContext = {\n    incomingRequestProperties: context.incomingRequestProperties,\n    requestId: context.requestId,\n    route: context.route,\n    custom: context.custom,\n  };\n\n  const rewriteUrl = options.__rewriteFunction(request, rewriteContext);\n\n  const url = innerForwardSearch\n    ? addQuery(rewriteUrl, request.url)\n    : rewriteUrl;\n\n  const start = Date.now();\n  userLogFunction(`URL Rewriting to '${url}'`);\n\n  const result = await internals.fetch(url.toString(), {\n    method: request.method,\n    body: request.body,\n    headers: request.headers,\n    redirect: shouldFollowRedirects ? \"follow\" : \"manual\",\n  });\n\n  const delta = Date.now() - start;\n  userLogFunction(\n    `URL Rewrite received response ${result.status} - ${result.statusText} in ${delta}ms`\n  );\n\n  void logBadGatewayResponses(result, context);\n\n  return result;\n}\n", "import { ZuploContext, ZuploRewriteContext } from \"../context\";\nimport { ConfigurationError } from \"../errors\";\nimport { externalServiceTunnelConfig } from \"../external-services\";\nimport { HttpProblems } from \"../index.worker\";\nimport internals from \"../internals\";\nimport { ZuploRequest } from \"../request\";\nimport { Environment } from \"../utils/environment\";\nimport { getHandlerUserLogFunction } from \"./util\";\n/**\n * @beta\n */\ninterface WebSocketHandlerOptions {\n  rewritePattern: string;\n  __rewriteFunction: (\n    request: ZuploRequest,\n    context: ZuploRewriteContext\n  ) => string;\n}\n\n/**\n * Handle websocket requests to a different url\n * @param request - The ZuploRequest\n * @param context - The ZuploContext\n * @returns\n * @beta\n */\nexport async function webSocketHandler(\n  request: ZuploRequest,\n  context: ZuploContext\n): Promise<Response> {\n  const env = Environment.instance;\n  const options = context.route.handler.options as WebSocketHandlerOptions;\n  const userLogFunction = getHandlerUserLogFunction(context);\n\n  if (!options || !options.rewritePattern) {\n    throw new ConfigurationError(\n      `WebSocket Handler must have option 'rewritePattern' specified`\n    );\n  }\n\n  const upgradeHeader = request.headers.get(\"Upgrade\");\n  if (!upgradeHeader || upgradeHeader !== \"websocket\") {\n    return HttpProblems.badRequest(request, context, {\n      detail: \"Request must include header 'Upgrade: websocket'\",\n    });\n  }\n\n  if (!options || typeof options.__rewriteFunction !== \"function\") {\n    throw new ConfigurationError(\"Invalid options for this route\");\n  }\n\n  // Create context without the functions\n  const rewriteContext: ZuploRewriteContext = {\n    incomingRequestProperties: context.incomingRequestProperties,\n    requestId: context.requestId,\n    route: context.route,\n    custom: context.custom,\n  };\n\n  let rewriteUrl = options.__rewriteFunction(request, rewriteContext);\n\n  const start = Date.now();\n\n  userLogFunction(`Attempting WebSocket connection to '${rewriteUrl}'`);\n\n  // @NOTE - build a response object with all the data needed to delegate websocket\n  // connection to Deno-Runtime\n  if (env.isDeno) {\n    const headers = new Headers(request.headers);\n\n    // Handle tunnels\n    if (rewriteUrl.startsWith(\"service:\")) {\n      // get tunnel url & headers\n      const tunnelConfig = await externalServiceTunnelConfig(rewriteUrl);\n      const tmpUrl = new URL(rewriteUrl);\n      const tunnelUrl = new URL(\n        `${tunnelConfig.serviceBaseUrl}${tmpUrl.pathname}${tmpUrl.search}`\n      );\n\n      rewriteUrl = tunnelUrl.toString();\n\n      for (const key in tunnelConfig.tunnelHeaders) {\n        headers.set(key, tunnelConfig.tunnelHeaders[key]);\n      }\n    }\n\n    // switch from http to websocket uri\n    rewriteUrl = rewriteUrl.replace(/^(http)/, \"ws\");\n\n    try {\n      // @NOTE - this is a hack that will only work for BD's usecase\n      // we will be updating the handler with a better way to provide auth info\n      if (headers.get(\"Authorization\")) {\n        const apiKey = headers.get(\"Authorization\")?.replace(\"Bearer \", \"\");\n\n        rewriteUrl += `?apiKey=${apiKey}`;\n      }\n    } catch (e) {\n      //\n    }\n\n    const resBody = JSON.stringify({ url: rewriteUrl });\n    return new Response(resBody, { headers });\n  }\n\n  // switch from ws to http uri since websocket connections in CF using fetch must use http protocol\n  rewriteUrl = rewriteUrl.replace(/^(ws)/, \"http\");\n\n  const result = await internals.fetch(rewriteUrl, {\n    method: request.method,\n    headers: request.headers,\n    body: request.body,\n  });\n\n  if (result.status !== 101 || !result.webSocket) {\n    const content = await result.text();\n    const msg = `WebSocket connection error - ${result.status}: ${result.statusText}, content: '${content}'`;\n    throw new Error(msg);\n  }\n\n  const delta = Date.now() - start;\n  userLogFunction(\n    `WebSocket connected, received response ${result.status} - ${result.statusText} in ${delta}ms`\n  );\n\n  return new Response(null, {\n    status: 101,\n    webSocket: result.webSocket,\n  });\n}\n", "import { ZuploContext } from \"../context\";\nimport { ConfigurationError } from \"../errors\";\nimport { ZuploRequest } from \"../request\";\nimport {\n  WebSocketPolicyConfiguration,\n  WebSocketPolicyFunction,\n} from \"./websocket-pipeline-handler\";\n\nexport const getWebSocketPolicyFunctions = (\n  policies: WebSocketPolicyConfiguration[],\n  type: \"inbound\" | \"outbound\"\n): WebSocketPolicyFunction[] => {\n  const policyFunctions = policies.map((policyConfig, index) => {\n    let policyFunction: WebSocketPolicyFunction | undefined;\n    if (typeof policyConfig.module === \"object\") {\n      policyFunction = policyConfig.module[policyConfig.export];\n    }\n\n    if (!policyFunction || typeof policyFunction !== \"function\") {\n      // @TODO - do we need to set a policy name in options or use the export & module data when surfacing errors\n      const policyType =\n        type === \"inbound\"\n          ? \"WebSocketInboundPolicy\"\n          : \"WebSocketOutboundPolicy\";\n      const policyExportPosition = `policy in position: ${\n        index + 1\n      }, export name: ${policyConfig.export}`;\n      throw new ConfigurationError(\n        `${policyType} - Websocket policy must be a valid function (${policyExportPosition})`\n      );\n    }\n\n    return policyFunction;\n  });\n\n  return policyFunctions;\n};\n\nexport const webSocketPolicyProcessor = async (\n  evt: MessageEvent,\n  sourceWS: WebSocket,\n  targetWS: WebSocket,\n  request: ZuploRequest,\n  context: ZuploContext,\n  policies: WebSocketPolicyFunction[]\n) => {\n  let currentEventData = evt.data;\n  if (policies && policies.length > 0) {\n    const localPolicies = [...policies];\n    while (localPolicies.length > 0) {\n      const nextPolicy = localPolicies.shift();\n\n      if (!nextPolicy) {\n        return currentEventData;\n      }\n\n      currentEventData = await nextPolicy(\n        currentEventData,\n        targetWS,\n        sourceWS,\n        request,\n        context\n      );\n\n      if (currentEventData === undefined) {\n        // if receive undefined, just drop out\n        return;\n      }\n    }\n  }\n\n  return currentEventData;\n};\n", "import { ZuploContext, ZuploRewriteContext } from \"../context\";\nimport { ConfigurationError } from \"../errors\";\nimport { HttpProblems } from \"../index.worker\";\nimport internals from \"../internals\";\nimport { ZuploRequest } from \"../request\";\nimport { Environment } from \"../utils/environment\";\nimport { getHandlerUserLogFunction } from \"./util\";\nimport {\n  getWebSocketPolicyFunctions,\n  webSocketPolicyProcessor,\n} from \"./websocket-policy-processor\";\n\n/**\n * @beta\n */\nexport interface WebSocketPolicyConfiguration {\n  module: string;\n  export: string;\n}\n/**\n * @beta\n */\ninterface WSPipelineHandlerPoliciesOptions {\n  inbound?: WebSocketPolicyConfiguration[];\n  outbound?: WebSocketPolicyConfiguration[];\n}\n\n/**\n * @beta\n */\ninterface WebSocketPipelineHandlerOptions {\n  rewritePattern: string;\n  __rewriteFunction: (\n    request: ZuploRequest,\n    context: ZuploRewriteContext\n  ) => string;\n  policies?: WSPipelineHandlerPoliciesOptions;\n}\n\nexport type WebSocketPolicyFunction = (\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  data: any,\n  target: WebSocket,\n  source: WebSocket,\n  request: ZuploRequest,\n  context: ZuploContext\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n) => Promise<any>;\n\n/**\n * Configure the websocket listeners\n */\nfunction wireUpListeners(\n  sourceWS: WebSocket,\n  targetWS: WebSocket,\n  request: ZuploRequest,\n  context: ZuploContext,\n  policies: WebSocketPolicyFunction[]\n) {\n  sourceWS.addEventListener(\"close\", () => {\n    targetWS.close();\n  });\n\n  sourceWS.addEventListener(\"error\", (evt: Event) => {\n    context.log.error(`WebSocket error: `, evt);\n    // Forward error\n    targetWS.send(JSON.stringify(evt));\n  });\n\n  sourceWS.addEventListener(\"message\", (evt: MessageEvent) => {\n    try {\n      const innerPipeline = async (evt: MessageEvent) => {\n        const currentEventData = await webSocketPolicyProcessor(\n          evt,\n          sourceWS,\n          targetWS,\n          request,\n          context,\n          policies\n        );\n\n        if (currentEventData === undefined) {\n          // if receive undefined, just drop out\n          return;\n        }\n\n        targetWS.send(currentEventData);\n      };\n\n      const promise = innerPipeline(evt).catch(context.log.error);\n      context.waitUntil(promise);\n    } catch (err) {\n      context.log.error(err);\n    }\n  });\n}\n\n/**\n * Handle websocket requests to a different url\n * @param request - The ZuploRequest\n * @param context - The ZuploContext\n * @returns\n * @beta\n */\nexport async function webSocketPipelineHandler(\n  request: ZuploRequest,\n  context: ZuploContext\n): Promise<Response> {\n  const env = Environment.instance;\n  const options = context.route.handler\n    .options as WebSocketPipelineHandlerOptions;\n  const userLogFunction = getHandlerUserLogFunction(context);\n\n  if (!options || !options.rewritePattern) {\n    throw new ConfigurationError(\n      `WebSocket Pipeline Handler must have option 'rewritePattern' specified`\n    );\n  }\n\n  const upgradeHeader = request.headers.get(\"Upgrade\");\n  if (!upgradeHeader || upgradeHeader !== \"websocket\") {\n    return HttpProblems.badRequest(request, context, {\n      detail: \"Request must include header 'Upgrade: websocket'\",\n    });\n  }\n\n  if (!options || typeof options.__rewriteFunction !== \"function\") {\n    throw new ConfigurationError(\"Invalid options for this route\");\n  }\n\n  // Create context without the functions\n  const rewriteContext: ZuploRewriteContext = {\n    incomingRequestProperties: context.incomingRequestProperties,\n    requestId: context.requestId,\n    route: context.route,\n    custom: context.custom,\n  };\n\n  let rewriteUrl = options.__rewriteFunction(request, rewriteContext);\n\n  const start = Date.now();\n\n  userLogFunction(`Attempting WebSocket connection to '${rewriteUrl}'`);\n\n  // @TODO - add support for working-copy/deno\n  if (env.isDeno) {\n    throw new ConfigurationError(\n      \"Websocket pipeline handler is currently not supported on working-copy environments\"\n    );\n  }\n\n  // switch from ws to http uri since websocket connections in CF using fetch must use http protocol\n  rewriteUrl = rewriteUrl.replace(/^(ws)/, \"http\");\n\n  const result = await internals.fetch(rewriteUrl, {\n    method: request.method,\n    headers: request.headers,\n    body: request.body,\n  });\n\n  if (result.status !== 101 || !result.webSocket) {\n    const content = await result.text();\n    const msg = `WebSocket connection error - ${result.status}: ${result.statusText}, content: '${content}'`;\n    throw new Error(msg);\n  }\n\n  const webSocketPair = new WebSocketPair();\n  const [client, serverSocket] = Object.values(webSocketPair);\n\n  const delta = Date.now() - start;\n  userLogFunction(\n    `WebSocket connected, received response ${result.status} - ${result.statusText} in ${delta}ms`\n  );\n\n  const outgoingSocket = result.webSocket;\n\n  outgoingSocket.accept();\n  serverSocket.accept();\n\n  const inboundPolicies =\n    options.policies && options.policies.inbound\n      ? getWebSocketPolicyFunctions(options.policies.inbound, \"inbound\")\n      : [];\n\n  const outboundPolicies =\n    options.policies && options.policies.outbound\n      ? getWebSocketPolicyFunctions(options.policies.outbound, \"outbound\")\n      : [];\n\n  wireUpListeners(\n    serverSocket,\n    outgoingSocket,\n    request,\n    context,\n    inboundPolicies\n  );\n\n  wireUpListeners(\n    outgoingSocket,\n    serverSocket,\n    request,\n    context,\n    outboundPolicies\n  );\n\n  return new Response(null, {\n    status: 101,\n    webSocket: client,\n  });\n}\n", "import {\n  LoggingEnvironmentStage,\n  LoggingEnvironmentType,\n} from \"../../../interfaces\";\nimport internals from \"../../../internals\";\nimport { BatchDispatch } from \"../../../utils/batch-dispatch\";\nimport { Environment } from \"../../../utils/environment\";\nimport { serializeError } from \"../../../utils/serialize-error\";\nimport { LogEntry, LogTransport } from \"../interfaces\";\nimport { LogPlugin } from \"../log-plugin\";\nimport { stringifyNonString } from \"../log-serializer-utils\";\nimport type { LoggingContext } from \"../logging-context\";\n\ninterface DynaTraceLoggingOptions {\n  url: string;\n  apiToken: string;\n}\n\nexport class DynaTraceLoggingPlugin extends LogPlugin {\n  constructor(private options: DynaTraceLoggingOptions) {\n    super();\n  }\n\n  /**\n   * @internal\n   */\n  override getTransport(): LogTransport {\n    return new DynaTraceTransport(this.options);\n  }\n}\n\n// Example Batch Payload\n// [\n//   {\n//     \"content\": \"Exception: Custom error log sent via Generic Log Ingest\",\n//     \"log.source\": \"/var/log/syslog\",\n//     \"severity\": \"error\",\n//     \"custom.attribute\": \"attribute value\"\n//   },\n//   {\n//     \"content\": \"Exception: Custom error log sent via Generic Log Ingest\",\n//     \"log.source\": \"/var/log/syslog\"\n//   },\n//   {\n//     \"content\": \"Exception: Custom error log sent via Generic Log Ingest\",\n//     \"log.source\": \"/var/log/syslog\"\n//   },\n//   {\n//     \"content\": \"Exception: Custom error log sent via Generic Log Ingest\"\n//   }\n// ]\n\ninterface RawDynaTraceLogEntry {\n  message: string;\n  timestamp: string;\n  severity: string;\n  \"log.source\": string;\n  requestId: string;\n  \"custom.environment\": string | undefined;\n  \"custom.environmentStage\": string;\n  \"custom.environmentType\": string;\n  \"custom.loggingId\": string;\n  \"custom.rayId\": string | undefined;\n}\n\n/**\n * @internal\n */\nclass DynaTraceTransport implements LogTransport {\n  constructor(options: DynaTraceLoggingOptions) {\n    this.#url = options.url;\n    this.#apiToken = options.apiToken;\n    this.#environmentType = Environment.instance.loggingEnvironmentType;\n    this.#environmentStage = Environment.instance.loggingEnvironmentStage;\n    this.#environment = Environment.instance.deploymentName;\n  }\n\n  #url: string;\n  #apiToken: string;\n  #environment: string | undefined;\n  #environmentType: LoggingEnvironmentType;\n  #environmentStage: LoggingEnvironmentStage;\n\n  log(logEntry: LogEntry, context: LoggingContext): void {\n    logEntry.messages.forEach((message) => {\n      const entry: RawDynaTraceLogEntry = {\n        timestamp: new Date().toISOString(),\n        message: stringifyNonString(serializeError(message)),\n        severity: logEntry.level,\n        \"log.source\": logEntry.logSource,\n        requestId: logEntry.requestId,\n        \"custom.environment\": this.#environment,\n        \"custom.environmentStage\": this.#environmentStage,\n        \"custom.environmentType\": this.#environmentType,\n        \"custom.loggingId\": logEntry.loggingId,\n        \"custom.rayId\": logEntry.rayId === null ? undefined : logEntry.rayId,\n      };\n      this.batcher.enqueue(entry);\n    });\n\n    context.waitUntil(this.batcher.waitUntilFlushed());\n  }\n\n  #dispatchFunction = async (entries: RawDynaTraceLogEntry[]) => {\n    if (entries.length === 0) {\n      return;\n    }\n\n    await internals.fetch(this.#url, {\n      method: \"POST\",\n      body: JSON.stringify(entries),\n      headers: {\n        \"content-type\": \"application/json; charset=utf-8\",\n        authorization: `Api-Token ${this.#apiToken}`,\n      },\n    });\n  };\n\n  batcher = new BatchDispatch<RawDynaTraceLogEntry>(\n    \"dyna-trace-log-transport\",\n    10,\n    this.#dispatchFunction\n  );\n}\n", "import {\n  LoggingEnvironmentStage,\n  LoggingEnvironmentType,\n} from \"../../../interfaces\";\nimport internals from \"../../../internals\";\nimport { BatchDispatch } from \"../../../utils/batch-dispatch\";\nimport { Environment } from \"../../../utils/environment\";\nimport { serializeError } from \"../../../utils/serialize-error\";\nimport { LogLevel } from \"../../interfaces\";\nimport { LogEntry, LogTransport } from \"../interfaces\";\nimport { LogPlugin } from \"../log-plugin\";\nimport { stringifyNonString } from \"../log-serializer-utils\";\nimport type { LoggingContext } from \"../logging-context\";\n\ninterface LokiLoggingPluginOptions {\n  url: string;\n  username: string;\n  password: string;\n}\n\nexport class LokiLoggingPlugin extends LogPlugin {\n  constructor(private options: LokiLoggingPluginOptions) {\n    super();\n  }\n\n  /**\n   * @internal\n   */\n  override getTransport(): LogTransport {\n    return new LokiTransport(this.options);\n  }\n}\n\n// Example Batch Payload\n// {\n//   \"streams\": [\n//     {\n//       \"stream\": {\n//        \"job\": \"zuplo\",\n// \t\t\t\t\"level\": \"error\",\n// \t\t\t\t\"environment\": \"test-main-46af013\",\n// \t\t\t\t\"workingCopy\": true,\n// \t\t\t\t\"requestId\" : \"5220ac25-18f3-4a9b-869f-f9306228f71f\",\n//       },\n//       \"values\": [\n// \t\t\t\t[\"1679502664000000000\", \"something bad\"],\n// \t\t\t\t[\"1679502664000000000\", \"{ \\\"message\\\" : \\\"error msg\\\" }\"],\n// \t\t\t\t[\"1679502664000000008\", \"another error\"],\n// \t\t\t]\n//     },\n// \t\t{\n//       \"stream\": {\n//        \"job\": \"zuplo\",\n// \t\t\t\t\"level\": \"info\",\n// \t\t\t\t\"environment\": \"test-main-46af013\",\n// \t\t\t\t\"workingCopy\": true,\n// \t\t\t\t\"requestId\": \"5220ac25-18f3-4a9b-869f-f9306228f71f\",\n//       },\n//       \"values\": [\n// \t\t\t\t[\"1679502664000000002\", \"hello\"],\n// \t\t\t\t[\"1679502664000000005\", \"foo\"],\n// \t\t\t\t[\"1679502664000000005\", \"{ \\\"bar\\\": 1 }\"]\n// \t\t\t]\n//     },\n//   ]\n// }\n\ninterface RawLokiLogEntry {\n  stream: LokiStream;\n  nanoSecondEpoch: string;\n  message: string;\n}\n\ninterface LokiBatch {\n  streams: { stream: LokiStream; values: string[][] }[];\n}\n\nclass LokiStream {\n  constructor(\n    level: LogLevel,\n    environment: string | undefined,\n    environmentType: LoggingEnvironmentType,\n    environmentStage: LoggingEnvironmentStage,\n    requestId: string\n  ) {\n    this.level = level;\n    this.environment = environment;\n    this.environmentType = environmentType;\n    this.environmentStage = environmentStage;\n    this.requestId = requestId;\n  }\n  job = \"zuplo\";\n  level: LogLevel;\n  environment: string | undefined;\n  environmentType: LoggingEnvironmentType;\n  environmentStage: LoggingEnvironmentStage;\n  requestId: string;\n\n  equals = (entry: LokiStream) => {\n    // job, environment and environment are fixed for any given process\n    // no need to compare\n    return this.level === entry.level && this.requestId === entry.requestId;\n  };\n}\n\nfunction createBasicDigest(username: string, password: string) {\n  const encoded = btoa(`${username}:${password}`);\n  return encoded;\n}\n\n/**\n * @internal\n */\nclass LokiTransport implements LogTransport {\n  constructor(options: LokiLoggingPluginOptions) {\n    // create the authenticated URL - Loki uses url auth,\n    // CloudFlare does not support creds in URL so have to manually create the\n    // Basic auth header\n    this.#url = options.url;\n    this.#basicAuthValue = createBasicDigest(\n      options.username,\n      options.password\n    );\n    this.#environmentType = Environment.instance.loggingEnvironmentType;\n    this.#environmentStage = Environment.instance.loggingEnvironmentStage;\n    this.#environment = Environment.instance.deploymentName;\n  }\n\n  #url: string;\n  #basicAuthValue: string;\n  #environment: string | undefined;\n  #environmentType: LoggingEnvironmentType;\n  #environmentStage: LoggingEnvironmentStage;\n\n  log(logEntry: LogEntry, context: LoggingContext): void {\n    const lokiStream = new LokiStream(\n      logEntry.level,\n      this.#environment,\n      this.#environmentType,\n      this.#environmentStage,\n      logEntry.requestId\n    );\n\n    logEntry.messages.forEach((message) => {\n      const entry: RawLokiLogEntry = {\n        stream: lokiStream,\n        message: stringifyNonString(serializeError(message)),\n        // need nanosecond epoch string - add six 0s\n        nanoSecondEpoch: `${logEntry.timestamp.getTime()}000000`,\n      };\n      this.batcher.enqueue(entry);\n    });\n\n    context.waitUntil(this.batcher.waitUntilFlushed());\n  }\n\n  #convertToLokiStreamsBatch: (entries: RawLokiLogEntry[]) => LokiBatch = (\n    entries\n  ) => {\n    const batch: LokiBatch = { streams: [] };\n\n    entries.forEach((entry) => {\n      let matchingStream = batch.streams.find((s) =>\n        s.stream.equals(entry.stream)\n      );\n      if (!matchingStream) {\n        matchingStream = { stream: entry.stream, values: [] };\n        batch.streams.push(matchingStream);\n      }\n      matchingStream.values.push([entry.nanoSecondEpoch, entry.message]);\n    });\n\n    return batch;\n  };\n\n  #dispatchFunction = async (entries: RawLokiLogEntry[]) => {\n    if (entries.length === 0) {\n      return;\n    }\n\n    const batch = this.#convertToLokiStreamsBatch(entries);\n\n    await internals.fetch(this.#url, {\n      method: \"POST\",\n      body: JSON.stringify(batch),\n      headers: {\n        \"content-type\": \"application/json\",\n        authorization: `Basic ${this.#basicAuthValue}`,\n      },\n    });\n  };\n\n  batcher = new BatchDispatch<RawLokiLogEntry>(\n    \"loki-log-transport\",\n    10,\n    this.#dispatchFunction\n  );\n}\n", "import {\n  LoggingEnvironmentStage,\n  LoggingEnvironmentType,\n} from \"../../../interfaces\";\nimport internals from \"../../../internals\";\nimport { BatchDispatch } from \"../../../utils/batch-dispatch\";\nimport { Environment } from \"../../../utils/environment\";\nimport { serializeError } from \"../../../utils/serialize-error\";\nimport { LogEntry, LogTransport } from \"../interfaces\";\nimport { LogPlugin } from \"../log-plugin\";\nimport { stringifyNonString } from \"../log-serializer-utils\";\nimport type { LoggingContext } from \"../logging-context\";\n\ninterface SumoLogicLoggingOptions {\n  url: string;\n  name?: string;\n  category?: string;\n}\n\nexport class SumoLogicLoggingPlugin extends LogPlugin {\n  constructor(private options: SumoLogicLoggingOptions) {\n    super();\n  }\n\n  /**\n   * @internal\n   */\n  override getTransport(): LogTransport {\n    return new SumoLogicTransport(this.options);\n  }\n}\n\n// Sumologic expects each log to be on its own line in a batched payload\n// each log is JSON with a new line \\n separating each log message\n\n// Example Batch Payload\n//   { \"content\": \"Exception: Custom error log sent via Generic Log Ingest\", \"log.source\": \"/var/log/syslog\", \"severity\": \"error\" }\\n\n//   { \"content\": \"Exception: Custom error log sent via Generic Log Ingest\", \"log.source\": \"/var/log/syslog\" }\\n\n\ninterface RawSumoLogicLogEntry {\n  message: string;\n  /**\n   * https://help.sumologic.com/docs/send-data/reference-information/time-reference/\n   */\n  timestamp: string;\n  severity: string;\n  source: string;\n  requestId: string;\n  environment: string | undefined;\n  environmentType: string;\n  environmentStage: string;\n  rayId: string | undefined;\n}\n\n/**\n * @internal\n */\nclass SumoLogicTransport implements LogTransport {\n  constructor(options: SumoLogicLoggingOptions) {\n    this.#url = options.url;\n    this.#category = options.category;\n    this.#name = options.name;\n    this.#environmentType = Environment.instance.loggingEnvironmentType;\n    this.#environmentStage = Environment.instance.loggingEnvironmentStage;\n    this.#environment = Environment.instance.deploymentName;\n  }\n\n  #url: string;\n  #environment: string | undefined;\n  #environmentType: LoggingEnvironmentType;\n  #environmentStage: LoggingEnvironmentStage;\n  #category?: string;\n  #name?: string;\n\n  log(logEntry: LogEntry, context: LoggingContext): void {\n    logEntry.messages.forEach((message) => {\n      const entry: RawSumoLogicLogEntry = {\n        timestamp: new Date().toISOString(),\n        message: stringifyNonString(serializeError(message)),\n        severity: logEntry.level,\n        source: logEntry.logSource,\n        requestId: logEntry.requestId,\n        environment: this.#environment,\n        environmentType: this.#environmentType,\n        environmentStage: this.#environmentStage,\n        rayId: logEntry.rayId === null ? undefined : logEntry.rayId,\n      };\n      this.batcher.enqueue(entry);\n    });\n\n    context.waitUntil(this.batcher.waitUntilFlushed());\n  }\n\n  #dispatchFunction = async (entries: RawSumoLogicLogEntry[]) => {\n    if (entries.length === 0) {\n      return;\n    }\n\n    const body = entries.map((entry) => JSON.stringify(entry)).join(\"\\n\");\n\n    const headers = new Headers({\n      \"content-type\": \"application/json; charset=utf-8\",\n    });\n    if (this.#name) {\n      headers.set(\"X-Sumo-Name\", this.#name);\n    }\n    if (this.#category) {\n      headers.set(\"X-Sumo-Category\", this.#category);\n    }\n\n    await internals.fetch(this.#url, {\n      method: \"POST\",\n      body,\n      headers,\n    });\n  };\n\n  batcher = new BatchDispatch<RawSumoLogicLogEntry>(\n    \"sumo-logic-log-transport\",\n    10,\n    this.#dispatchFunction\n  );\n}\n", "import { ConfigurationError } from \"../../../errors\";\nimport {\n  LoggingEnvironmentStage,\n  LoggingEnvironmentType,\n} from \"../../../interfaces\";\nimport internals from \"../../../internals\";\nimport { BatchDispatch } from \"../../../utils/batch-dispatch\";\nimport { Environment } from \"../../../utils/environment\";\nimport { Primitive } from \"../../../utils/types\";\nimport { LogEntry, LogTransport } from \"../interfaces\";\nimport { LogPlugin } from \"../log-plugin\";\nimport {\n  messagesToMultilineText,\n  stringifyNonStringToText,\n} from \"../log-serializer-utils\";\nimport type { LoggingContext } from \"../logging-context\";\n\n// Log Insights requires a stable UUID to identify the logging client\n// this seems like its essentially a user agent. I don't think, users\n// need to be able to change this\nconst DEFAULT_AGENT_ID = \"d3a5b78f823648f5b1df4fe269d41172\";\n\ninterface VMWareLogInsightLoggingOptions {\n  url: string;\n  /**\n   * An array of string tuples to replace within the text field of a log entry.\n   * @example\n   * ```\n   * [\n   *  [\"'\", \"\"],\n   *  ['\"', \"\"],\n   *  [\"\\\\n\", \"\"],\n   *  [\"\\\\\", \"\"],\n   *  [\"*\", \"\"],\n   *  [\"&\", \"\"],\n   *  [\":\", \"=\"],\n   * ]\n   * ```\n   */\n  textReplacements?: [string, string][];\n  /**\n   * The unique agent identifier of the logger.\n   */\n  agentId?: string;\n  fields?: Record<string, string | number | boolean>;\n  onMessageSending?: (event: LogInsightLogEntry) => LogInsightLogEntry;\n}\n\nexport class VMWareLogInsightLoggingPlugin extends LogPlugin {\n  constructor(private options: VMWareLogInsightLoggingOptions) {\n    super();\n  }\n\n  /**\n   * @internal\n   */\n  override getTransport(): LogTransport {\n    return new VMWareLogInsightTransport(this.options);\n  }\n}\n\ninterface LogField {\n  name: string;\n  content: Primitive;\n}\n\ninterface LogInsightLogEntry {\n  text: string;\n  timestamp: number;\n  fields: LogField[];\n}\n\n/**\n * @internal\n * API: https://vmw-loginsight.github.io/#Getting-started-with-the-Log-Insight-REST-API\n */\nexport class VMWareLogInsightTransport implements LogTransport {\n  constructor(options: VMWareLogInsightLoggingOptions) {\n    let parsedUrl: URL;\n    try {\n      parsedUrl = new URL(options.url);\n      // If the user didnt provide a path, set the default\n      if (parsedUrl.pathname === \"/\") {\n        parsedUrl.pathname = `/api/v1/events/ingest/${options.agentId ?? DEFAULT_AGENT_ID}`;\n      }\n    } catch (err) {\n      throw new ConfigurationError(\n        `Invalid option 'url' on 'VMWareLogInsightTransport' plugin. Must be a valid URL, received '${options.url}'`\n      );\n    }\n\n    this.#url = parsedUrl.toString();\n    this.#environmentType = Environment.instance.loggingEnvironmentType;\n    this.#environmentStage = Environment.instance.loggingEnvironmentStage;\n    this.#environment = Environment.instance.deploymentName;\n    this.#onMessageSending = options.onMessageSending;\n    this.#textReplacements = options.textReplacements;\n    if (options.fields) {\n      this.#fields = Object.entries(options.fields).map(([name, content]) => ({\n        name,\n        content,\n      }));\n    }\n  }\n\n  #url: string;\n  #textReplacements: [string, string][] | undefined;\n  #environment: string | undefined;\n  #environmentType: LoggingEnvironmentType;\n  #environmentStage: LoggingEnvironmentStage;\n  #onMessageSending?: (entry: LogInsightLogEntry) => LogInsightLogEntry;\n  #fields?: LogField[];\n\n  log(logEntry: LogEntry, context: LoggingContext): void {\n    const entry = this.buildEntry(logEntry, context);\n    this.batcher.enqueue(entry);\n\n    context.waitUntil(this.batcher.waitUntilFlushed());\n  }\n\n  buildEntry(logEntry: LogEntry, context: LoggingContext): LogInsightLogEntry {\n    let text = messagesToMultilineText(logEntry.messages);\n    this.#textReplacements?.forEach((replacement) => {\n      text = text.replaceAll(replacement[0], replacement[1]);\n    });\n    let entry: LogInsightLogEntry = {\n      timestamp: Date.now(),\n      text,\n      fields: [\n        { name: \"severity\", content: logEntry.level.toUpperCase() },\n        { name: \"request_id\", content: logEntry.requestId },\n        { name: \"environment_type\", content: this.#environmentType },\n        { name: \"environment_stage\", content: this.#environmentStage },\n        { name: \"log_source\", content: logEntry.logSource },\n        { name: \"atomic_counter\", content: logEntry.vectorClock },\n      ],\n    };\n\n    if (logEntry.rayId) {\n      entry.fields.push({ name: \"request_ray_id\", content: logEntry.rayId });\n    }\n    if (this.#environment) {\n      entry.fields.push({ name: \"environment\", content: this.#environment });\n    }\n\n    // Add the options fields\n    if (this.#fields) {\n      entry.fields.push(...this.#fields);\n    }\n\n    if (context.custom) {\n      Object.entries(context.custom).forEach(([name, value]) => {\n        // Fields can only contain simple string values\n        const content = stringifyNonStringToText(value);\n        if (content) {\n          entry.fields.push({ name, content });\n        }\n      });\n    }\n\n    if (this.#onMessageSending) {\n      entry = this.#onMessageSending(entry);\n    }\n\n    return entry;\n  }\n\n  #dispatchFunction = async (entries: LogInsightLogEntry[]) => {\n    if (entries.length === 0) {\n      return;\n    }\n\n    const response = await internals.fetch(this.#url, {\n      method: \"POST\",\n      body: JSON.stringify({ events: entries }),\n      headers: {\n        \"content-type\": \"application/json; charset=utf-8\",\n      },\n    });\n    if (response.status !== 200) {\n      try {\n        const result = await response.text();\n        // eslint-disable-next-line no-console\n        console.error(`Error logging to Log Insight`, result);\n      } catch (err) {\n        // eslint-disable-next-line no-console\n        console.error(err);\n      }\n    }\n  };\n\n  batcher = new BatchDispatch<LogInsightLogEntry>(\n    \"vmware-log-insights-log-transport\",\n    10,\n    this.#dispatchFunction\n  );\n}\n", "import { LoggingEnvironmentType } from \"../../../interfaces\";\nimport { AwsClient } from \"../../../utils/aws\";\nimport { BatchDispatch } from \"../../../utils/batch-dispatch\";\nimport { Environment } from \"../../../utils/environment\";\nimport { serializeError } from \"../../../utils/serialize-error\";\nimport { LogEntry, LogTransport } from \"../interfaces\";\nimport { LogPlugin } from \"../log-plugin\";\nimport { stringifyNonString } from \"../log-serializer-utils\";\nimport type { LoggingContext } from \"../logging-context\";\n\ninterface AWSLoggingOptions {\n  region: string;\n  accessKeyId: string;\n  secretAccessKey: string;\n  logGroupName: string;\n  logStreamName: string;\n}\n\nexport class AWSLoggingPlugin extends LogPlugin {\n  constructor(private options: AWSLoggingOptions) {\n    super();\n  }\n\n  /**\n   * @internal\n   */\n  override getTransport(): LogTransport {\n    return new AWSLogTransport(this.options);\n  }\n}\n\ninterface AWSLogEntry {\n  message: string;\n  timestamp: number;\n}\n\nexport class AWSLogTransport implements LogTransport {\n  private readonly awsClient: AwsClient;\n  private readonly environment: string | undefined;\n  private readonly environmentType: LoggingEnvironmentType;\n  private readonly logGroupName: string;\n  private readonly logStreamName: string;\n  private readonly region: string;\n\n  private readonly batcher = new BatchDispatch<AWSLogEntry>(\n    \"aws-log-transport\",\n    10,\n    async (entries: AWSLogEntry[]) => {\n      if (entries.length === 0) {\n        return;\n      }\n\n      const body = JSON.stringify({\n        logGroupName: this.logGroupName,\n        logStreamName: this.logStreamName,\n        logEvents: entries,\n      });\n\n      await this.awsClient.fetch(`https://logs.${this.region}.amazonaws.com`, {\n        headers: {\n          \"Content-Type\": \"application/x-amz-json-1.1\",\n          \"x-amz-Target\": \"Logs_20140328.PutLogEvents\",\n        },\n        body,\n        aws: {\n          accessKeyId: this.awsClient.accessKeyId,\n          secretAccessKey: this.awsClient.secretAccessKey,\n          service: this.awsClient.service,\n          region: this.awsClient.region,\n        },\n      });\n    }\n  );\n\n  constructor({\n    accessKeyId,\n    logStreamName,\n    logGroupName,\n    secretAccessKey,\n    region,\n  }: AWSLoggingOptions) {\n    this.awsClient = new AwsClient({\n      accessKeyId,\n      secretAccessKey,\n      service: \"logs\",\n      region,\n    });\n\n    this.logGroupName = logGroupName;\n    this.logStreamName = logStreamName;\n    this.region = region;\n    this.environmentType = Environment.instance.loggingEnvironmentType;\n    this.environment = Environment.instance.deploymentName;\n  }\n\n  log(logEntry: LogEntry, context: LoggingContext): void {\n    logEntry.messages.forEach((message) => {\n      const entry: AWSLogEntry = {\n        timestamp: new Date().getTime(),\n        message: JSON.stringify({\n          data: stringifyNonString(serializeError(message)),\n          severity: logEntry.level,\n          source: logEntry.logSource,\n          environment: this.environment,\n          requestId: logEntry.requestId,\n          environmentType: this.environmentType,\n          rayId: logEntry.rayId === null ? undefined : logEntry.rayId,\n        }),\n      };\n      this.batcher.enqueue(entry);\n    });\n\n    context.waitUntil(this.batcher.waitUntilFlushed());\n  }\n}\n", "export { DataDogLoggingPlugin } from \"./data-dog-transport\";\nexport { DynaTraceLoggingPlugin } from \"./dynatrace-transport\";\nexport { GoogleCloudLoggingPlugin } from \"./google-transport\";\nexport { LokiLoggingPlugin } from \"./loki-transport\";\nexport { SumoLogicLoggingPlugin } from \"./sumologic-transport\";\nexport { VMWareLogInsightLoggingPlugin } from \"./vmware-log-insight-transport\";\nexport { AWSLoggingPlugin } from \"./aws-transport\";\n", "import { ZuploContext } from \"../../../context\";\nimport internals from \"../../../internals\";\nimport { MetricsData } from \"../../../processors/metrics-processor\";\nimport { SystemLogMap } from \"../../../system-log-map\";\nimport { BatchDispatch } from \"../../../utils/batch-dispatch\";\nimport { MetricsTransport } from \"../interfaces\";\nimport { MetricsPlugin } from \"../metrics-plugin\";\nimport { IncludeMetrics, MetricsType } from \"./common\";\n\ninterface DataDogMetricsOptions {\n  url?: string;\n  apiKey: string;\n  tags?: string[];\n  metrics?: MetricsType;\n  include?: IncludeMetrics;\n}\n\nexport interface DataDogMetricsContext {\n  tags: string[];\n}\n\nconst contextMap = new WeakMap<ZuploContext, DataDogMetricsContext>();\nconst defaultDataDogContextTemplate: DataDogMetricsContext = { tags: [] };\n\n// See https://docs.datadoghq.com/api/latest/metrics/#submit-metrics\n/**\n * @internal\n */\ninterface DataDogMetricsEntry {\n  metric: string;\n  // 0 (unspecified), 1 (count), 2 (rate), and 3 (gauge). Allowed enum values: 0,1,2,3\n  type: number;\n  points: [\n    {\n      timestamp: number;\n      value: number;\n    },\n  ];\n  tags: string[];\n  [other: string]: unknown;\n}\n\nexport class DataDogMetricsPlugin extends MetricsPlugin {\n  constructor(private options: DataDogMetricsOptions) {\n    super();\n  }\n\n  /**\n   * @internal\n   */\n  override getTransport(): MetricsTransport {\n    return new DataDogMetricsTransport(this.options);\n  }\n\n  static setContext(context: ZuploContext, data: DataDogMetricsContext) {\n    let ddContext = contextMap.get(context);\n    if (!ddContext) {\n      ddContext = defaultDataDogContextTemplate;\n    }\n    const merged = Object.assign({ ...ddContext }, data);\n    contextMap.set(context, merged);\n  }\n}\n\n/**\n * @internal\n */\nexport class DataDogMetricsTransport implements MetricsTransport {\n  readonly #apiKey: string;\n  readonly #baseUrl: string;\n  readonly #metrics: MetricsType;\n  readonly #tags: string[];\n  readonly #includes: IncludeMetrics;\n\n  #batcher: BatchDispatch<DataDogMetricsEntry> | undefined = undefined;\n\n  constructor(options: DataDogMetricsOptions) {\n    this.#apiKey = options.apiKey;\n    this.#baseUrl = options.url ?? \"https://api.datadoghq.com/api/v2/series\";\n    this.#metrics = Object.assign(\n      {\n        latency: true,\n        requestContentLength: true,\n        responseContentLength: true,\n      },\n      options.metrics\n    );\n    this.#includes = options.include ?? {};\n    this.#tags = options.tags ?? [];\n  }\n\n  pushMetrics(entry: MetricsData, context: ZuploContext): void {\n    if (this.#batcher === undefined) {\n      this.#batcher = new BatchDispatch<DataDogMetricsEntry>(\n        \"data-dog-metrics-transport\",\n        10,\n        this.dispatchFunction,\n        SystemLogMap.getLogger(context)\n      );\n    }\n\n    const timestamp = Math.floor(entry.timestamp.getTime() / 1000);\n    // Tags can be a list of strings of either value or <KEY>:<VALUE>\n    // We do not dedup since the user can specify the same key multiple times\n    const tags = this.#tags.concat(contextMap.get(context)?.tags ?? []);\n    if (this.#includes.country) {\n      tags.push(`country:${entry.country}`);\n    }\n    if (this.#includes.httpMethod) {\n      tags.push(`httpMethod:${entry.method}`);\n    }\n    if (this.#includes.statusCode) {\n      tags.push(`statusCode:${entry.statusCode}`);\n    }\n    if (this.#includes.path) {\n      const path = entry.systemRouteName || entry.routePath;\n      tags.push(`path:${path}`);\n    }\n\n    // Push latency\n    if (this.#metrics.latency) {\n      this.#batcher.enqueue({\n        metric: \"zuplo.request.latency\",\n        type: 3,\n        points: [\n          {\n            timestamp,\n            value: entry.durationMs,\n          },\n        ],\n        tags,\n      });\n    }\n\n    // Push request content-length\n    if (this.#metrics.requestContentLength && entry.requestContentLength) {\n      this.#batcher.enqueue({\n        metric: \"zuplo.request.content_length\",\n        type: 3,\n        points: [\n          {\n            timestamp,\n            value: entry.requestContentLength,\n          },\n        ],\n        tags,\n      });\n    }\n\n    // Push response content-length\n    if (this.#metrics.responseContentLength && entry.responseContentLength) {\n      this.#batcher.enqueue({\n        metric: \"zuplo.response.content_length\",\n        type: 3,\n        points: [\n          {\n            timestamp,\n            value: entry.responseContentLength,\n          },\n        ],\n        tags,\n      });\n    }\n\n    context.waitUntil(this.#batcher.waitUntilFlushed());\n  }\n\n  dispatchFunction = async (entries: DataDogMetricsEntry[]) => {\n    if (entries.length === 0) {\n      return;\n    }\n\n    const body = JSON.stringify({\n      series: entries,\n    });\n\n    const response = await internals.fetch(this.#baseUrl, {\n      method: \"POST\",\n      body,\n      headers: {\n        \"content-type\": \"application/json\",\n        \"DD-API-KEY\": this.#apiKey,\n      },\n    });\n\n    if (!response.ok) {\n      // Do not try to parse as JSON because it could be any error (including network)\n      // Let's just get the body as text and log it to the system logger\n      throw new DataDogMetricsError(await response.text());\n    }\n  };\n}\n\nexport class DataDogMetricsError extends Error {\n  constructor(message: string) {\n    super(message);\n    Object.setPrototypeOf(this, DataDogMetricsError.prototype);\n  }\n}\n", "import { ZuploContext } from \"../../../context\";\nimport internals from \"../../../internals\";\nimport { MetricsData } from \"../../../processors/metrics-processor\";\nimport { SystemLogMap } from \"../../../system-log-map\";\nimport { BatchDispatch } from \"../../../utils/batch-dispatch\";\nimport { MetricsTransport } from \"../interfaces\";\nimport { MetricsPlugin } from \"../metrics-plugin\";\nimport { IncludeMetrics, MetricsType } from \"./common\";\n\ninterface DynatraceMetricsOptions {\n  url: string;\n  apiToken: string;\n  dimensions?: string[];\n  metrics?: MetricsType;\n  include?: IncludeMetrics;\n}\n\nexport interface DynatraceMetricsContext {\n  dimensions: string[];\n}\n\nconst contextMap = new WeakMap<ZuploContext, DynatraceMetricsContext>();\nconst defaultDynatraceContextTemplate: DynatraceMetricsContext = {\n  dimensions: [],\n};\n\n// See https://www.dynatrace.com/support/help/dynatrace-api/environment-api/metric-v2/post-ingest-metrics\n\nexport class DynatraceMetricsPlugin extends MetricsPlugin {\n  constructor(private options: DynatraceMetricsOptions) {\n    super();\n  }\n\n  /**\n   * @internal\n   */\n  override getTransport(): MetricsTransport {\n    return new DynaTraceMetricsTransport(this.options);\n  }\n\n  static setContext(context: ZuploContext, data: DynatraceMetricsContext) {\n    let dynaContext = contextMap.get(context);\n    if (!dynaContext) {\n      dynaContext = defaultDynatraceContextTemplate;\n    }\n    const merged = Object.assign({ ...dynaContext }, data);\n    contextMap.set(context, merged);\n  }\n}\n\n/**\n * @internal\n */\nexport class DynaTraceMetricsTransport implements MetricsTransport {\n  readonly apiToken: string;\n  readonly #baseUrl: string;\n  readonly #metrics: MetricsType;\n  readonly dimensions: string[];\n  readonly #includes: IncludeMetrics;\n\n  #batcher: BatchDispatch<string> | undefined = undefined;\n\n  constructor(options: DynatraceMetricsOptions) {\n    this.apiToken = options.apiToken;\n    this.#baseUrl = options.url;\n    this.#metrics = Object.assign(\n      {\n        latency: true,\n        requestContentLength: true,\n        responseContentLength: true,\n      },\n      options.metrics\n    );\n    this.#includes = options.include ?? {};\n    this.dimensions = options.dimensions ?? [];\n  }\n\n  pushMetrics(entry: MetricsData, context: ZuploContext): void {\n    if (this.#batcher === undefined) {\n      this.#batcher = new BatchDispatch<string>(\n        \"dynatrace-metrics-transport\",\n        10,\n        this.dispatchFunction,\n        SystemLogMap.getLogger(context)\n      );\n    }\n\n    // This needs to be in milliseconds\n    const timestamp = Math.floor(entry.timestamp.getTime());\n    // Tags can be a list of strings of either key=\"value\"\n    // We do not dedup since the user can specify the same key multiple times\n    // TODO: We do not do any escaping today, and rely on the user conforming to\n    // https://www.dynatrace.com/support/help/extend-dynatrace/extend-metrics/reference/metric-ingestion-protocol#dimension\n    const dimensions = this.dimensions.concat(\n      contextMap.get(context)?.dimensions ?? []\n    );\n    if (this.#includes.country) {\n      dimensions.push(`country=\"${entry.country}\"`);\n    }\n    if (this.#includes.httpMethod) {\n      dimensions.push(`http_method=\"${entry.method}\"`);\n    }\n    if (this.#includes.statusCode) {\n      dimensions.push(`status_code=\"${entry.statusCode}\"`);\n    }\n    if (this.#includes.path) {\n      const path = entry.systemRouteName || entry.routePath;\n      dimensions.push(`path=\"${path}\"`);\n    }\n\n    const formattedDimensions = dimensions.join(\",\");\n\n    // Push latency\n    if (this.#metrics.latency) {\n      this.#batcher.enqueue(\n        `zuplo.request.latency,${formattedDimensions} ${entry.durationMs} ${timestamp}`\n      );\n    }\n\n    // Push request content-length\n    if (this.#metrics.requestContentLength && entry.requestContentLength) {\n      this.#batcher.enqueue(\n        `zuplo.request.content_length,${formattedDimensions} ${entry.requestContentLength} ${timestamp}`\n      );\n    }\n\n    // Push response content-length\n    if (this.#metrics.responseContentLength && entry.responseContentLength) {\n      this.#batcher.enqueue(\n        `zuplo.response.content_length,${formattedDimensions} ${entry.responseContentLength} ${timestamp}`\n      );\n    }\n\n    context.waitUntil(this.#batcher.waitUntilFlushed());\n  }\n\n  dispatchFunction = async (entries: string[]) => {\n    if (entries.length === 0) {\n      return;\n    }\n\n    const body = entries.join(\"\\n\");\n\n    const response = await internals.fetch(this.#baseUrl, {\n      method: \"POST\",\n      body,\n      headers: {\n        \"content-type\": \"text/plain\",\n        Authorization: `Api-Token ${this.apiToken}`,\n      },\n    });\n\n    if (!response.ok) {\n      // Do not try to parse as JSON because it could be any error (including network)\n      // Let's just get the body as text and log it to the system logger\n      throw new DynaTraceMetricsError(await response.text());\n    }\n  };\n}\n\nexport class DynaTraceMetricsError extends Error {\n  constructor(message: string) {\n    super(message);\n    Object.setPrototypeOf(this, DynaTraceMetricsError.prototype);\n  }\n}\n", "export { DataDogMetricsPlugin } from \"./data-dog-metrics\";\nexport { DynatraceMetricsPlugin } from \"./dynatrace-metrics\";\n", "import internals from \"../../internals\";\nimport { AuditLogEntry, AuditLogOutputProvider } from \"../audit-log-plugin\";\n\nexport interface AuditLogDataStaxInit {\n  url: string;\n  xCassandraToken: string;\n}\n\nexport class AuditLogDataStaxProvider implements AuditLogOutputProvider {\n  constructor(options: AuditLogDataStaxInit) {\n    this.#options = options;\n  }\n\n  #options: AuditLogDataStaxInit;\n\n  writeLogBatch = async (entries: AuditLogEntry[]) => {\n    // TODO: this should batch as one, need to workout how to do that\n    // with datastax\n    await Promise.allSettled(\n      entries.map(async (entry) => {\n        await internals.fetch(this.#options.url, {\n          method: \"POST\",\n          headers: {\n            \"X-Cassandra-Token\": this.#options.xCassandraToken,\n            \"content-type\": \"application/json\",\n          },\n          body: JSON.stringify(entry),\n        });\n      })\n    );\n  };\n}\n", "import { ZuploContext } from \"../context\";\nimport { RuntimeExtensions } from \"../extensions\";\nimport { ZuploRequest } from \"../request\";\nimport { HttpMethod } from \"../router/interfaces.generated\";\nimport { BatchDispatch, DispatchFunction } from \"../utils/batch-dispatch\";\nimport { SystemRuntimePlugin } from \"./plugins\";\n\nexport class AuditLogPlugin extends SystemRuntimePlugin {\n  constructor(outputProvider: AuditLogOutputProvider, init?: AuditLogInit) {\n    super();\n    this.#outputProvider = outputProvider;\n    this.#init = init;\n  }\n\n  #outputProvider: AuditLogOutputProvider;\n  #init?: AuditLogInit;\n\n  override async initialize(runtimeInit: RuntimeExtensions): Promise<void> {\n    new AuditPluginImpl(runtimeInit, this.#outputProvider, this.#init);\n  }\n}\n\nexport interface AuditLogRequestFilter {\n  (request: ZuploRequest, context: ZuploContext): Promise<boolean>;\n}\n\nexport interface AuditLogEntry {\n  timestamp: Date;\n  durationMs: number;\n  routePath: string;\n  requestId: string;\n  userSub?: string;\n  request: {\n    url: string;\n    method: HttpMethod;\n    headers?: Record<string, string>;\n    body?: string;\n  };\n  response: {\n    status: number;\n    statusText: string;\n    headers?: Record<string, string>;\n    body?: string;\n  };\n}\n\nexport interface AuditLogOutputProvider {\n  writeLogBatch: (entries: AuditLogEntry[]) => Promise<void>;\n}\n\nconst serializableHeaders = (headers: Headers) => {\n  const output: Record<string, string> = {};\n  headers.forEach((value, key) => {\n    output[key] = value;\n  });\n  return output;\n};\n\nexport interface AuditLogInit {\n  requestFilter?: AuditLogRequestFilter;\n  include?: {\n    request?: {\n      headers?: boolean;\n      body?: boolean;\n    };\n    response?: {\n      headers?: boolean;\n      body?: boolean;\n    };\n  };\n}\n\nconst defaultAuditOutputOptions: Required<AuditLogInit> = {\n  requestFilter: async () => true,\n  include: {\n    request: {\n      headers: true,\n      body: true,\n    },\n    response: {\n      headers: true,\n      body: true,\n    },\n  },\n};\n\nclass AuditPluginImpl {\n  constructor(\n    runtime: RuntimeExtensions,\n    outputProvider: AuditLogOutputProvider,\n    options?: AuditLogInit\n  ) {\n    this.#outputProvider = outputProvider;\n    // start with default options and copy stuff over from\n    // the specified\n    const init: Required<AuditLogInit> = { ...defaultAuditOutputOptions };\n    if (options?.requestFilter) {\n      init.requestFilter = options.requestFilter;\n    }\n    if (options?.include?.request) {\n      Object.assign(init, options.include.request);\n    }\n    if (options?.include?.response) {\n      Object.assign(init, options.include.response);\n    }\n    this.#init = init;\n    runtime.addRequestHook(this.#auditHook);\n\n    this.#batchDispatcher = new BatchDispatch(`audit-log`, 10, this.#dispatch);\n  }\n\n  #init: Required<AuditLogInit>;\n  #outputProvider: AuditLogOutputProvider;\n  #batchDispatcher: BatchDispatch<AuditLogEntry>;\n\n  #dispatch: DispatchFunction<AuditLogEntry> = async (\n    entries: AuditLogEntry[]\n  ) => {\n    await this.#outputProvider.writeLogBatch(entries);\n  };\n\n  #asyncPrepLogs = async (\n    clonedResponse: Response,\n    clonedRequest: Request,\n    context: ZuploContext,\n    timestamp: Date,\n    durationMs: number,\n    userSub: string | undefined\n  ) => {\n    try {\n      const auditLogEntry: AuditLogEntry = {\n        timestamp,\n        durationMs,\n        routePath: context.route.path,\n        requestId: context.requestId,\n        userSub,\n        request: {\n          url: clonedRequest.url,\n          method: clonedRequest.method as HttpMethod,\n          headers: this.#init.include?.request?.headers\n            ? serializableHeaders(clonedRequest.headers)\n            : undefined,\n          body: this.#init.include?.request?.body\n            ? await clonedRequest.text()\n            : undefined,\n        },\n        response: {\n          status: clonedResponse.status,\n          statusText: clonedResponse.statusText,\n          headers: this.#init.include?.response?.headers\n            ? serializableHeaders(clonedResponse.headers)\n            : undefined,\n          body: this.#init.include?.response?.body\n            ? await clonedResponse.text()\n            : undefined,\n        },\n      };\n\n      // TODO need to use Dispatcher\n      this.#batchDispatcher.enqueue(auditLogEntry);\n      context.waitUntil(this.#batchDispatcher.waitUntilFlushed());\n    } catch (err) {\n      context.log.error(err);\n    }\n  };\n\n  #auditHook = async (request: ZuploRequest, context: ZuploContext) => {\n    try {\n      const shouldLog = await this.#init.requestFilter(request, context);\n      if (!shouldLog) {\n        return request;\n      }\n\n      const timestamp = new Date();\n      const start = Date.now();\n      const requestClone = request.clone();\n\n      context.addResponseSendingFinalHook(async (response, latestRequest) => {\n        const end = Date.now();\n        const responseClone = response.clone();\n\n        // Now we go asynchronous\n        const promise = this.#asyncPrepLogs(\n          responseClone,\n          requestClone,\n          context,\n          timestamp,\n          end - start,\n          latestRequest.user?.sub\n        ).catch((err) => {\n          context.log.error(err);\n        });\n        context.waitUntil(promise);\n      });\n\n      return request;\n    } catch (err) {\n      context.log.error(err);\n      // auditing should not break the gateway\n      return request;\n    }\n  };\n}\n", "/* eslint-disable @typescript-eslint/no-explicit-any */\n\n/**\n * StripeError is the base error from which all other more specific Stripe errors derive.\n * Specifically for errors returned from Stripe's REST API.\n */\nexport class StripeError extends Error {\n  override readonly message: string;\n  readonly type: string;\n  readonly raw: unknown;\n  readonly rawType?: RawErrorType;\n  readonly headers?: { [header: string]: string };\n  readonly requestId?: string;\n\n  readonly code?: string;\n  readonly doc_url?: string;\n  readonly param?: string;\n  readonly detail?: string | Error;\n  readonly statusCode?: number;\n  readonly charge?: string;\n  readonly decline_code?: string;\n  readonly payment_method_type?: string;\n\n  readonly payment_intent?: any;\n  readonly payment_method?: any;\n  readonly setup_intent?: any;\n  readonly source?: any;\n\n  constructor(raw: StripeRawError = {}) {\n    super(raw.message);\n    this.type = this.constructor.name;\n\n    this.raw = raw;\n    this.rawType = raw.type;\n    this.code = raw.code;\n    this.doc_url = raw.doc_url;\n    this.param = raw.param;\n    this.detail = raw.detail;\n    this.headers = raw.headers;\n    this.requestId = raw.requestId;\n    this.statusCode = raw.statusCode;\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    this.message = raw.message;\n\n    this.charge = raw.charge;\n    this.decline_code = raw.decline_code;\n    this.payment_intent = raw.payment_intent;\n    this.payment_method = raw.payment_method;\n    this.payment_method_type = raw.payment_method_type;\n    this.setup_intent = raw.setup_intent;\n    this.source = raw.source;\n  }\n}\n\nexport class StripeSignatureVerificationError extends StripeError {\n  header: string | Uint8Array;\n  payload: string | Uint8Array;\n\n  constructor(\n    header: string | Uint8Array,\n    payload: string | Uint8Array,\n    raw: StripeRawError = {}\n  ) {\n    super(raw);\n    this.header = header;\n    this.payload = payload;\n  }\n}\n\nexport type RawErrorType =\n  | \"card_error\"\n  | \"invalid_request_error\"\n  | \"api_error\"\n  | \"idempotency_error\"\n  | \"rate_limit_error\"\n  | \"authentication_error\"\n  | \"invalid_grant\";\n\nexport interface StripeRawError {\n  message?: string;\n  type?: RawErrorType;\n  headers?: { [header: string]: string };\n  statusCode?: number;\n  requestId?: string;\n  code?: string;\n  doc_url?: string;\n  decline_code?: string;\n  param?: string;\n  detail?: string | Error;\n  charge?: string;\n  payment_method_type?: string;\n  payment_intent?: any;\n  payment_method?: any;\n  setup_intent?: any;\n  source?: any;\n  exception?: any;\n}\n", "// Source: https://github.com/stripe/stripe-node/blob/master/src/Webhooks.ts\nimport { StripeSignatureVerificationError } from \"./error\";\n\ntype WebhookHeader = string | Uint8Array;\nexport type WebhookEvent = Record<string, unknown>;\ntype WebhookPayload = string | Uint8Array;\ninterface WebhookParsedHeader {\n  signatures: Array<string>;\n  timestamp: number;\n}\ninterface WebhookParsedEvent {\n  details: WebhookParsedHeader;\n  decodedPayload: WebhookHeader;\n  decodedHeader: WebhookPayload;\n  suspectPayloadType: boolean;\n}\n\nconst EXPECTED_SCHEME = \"v1\";\nconst DEFAULT_TOLERANCE = 300; // 5 minutes\nexport async function constructEventAsync(\n  payload: WebhookPayload,\n  header: WebhookHeader,\n  secret: string,\n  tolerance: number = DEFAULT_TOLERANCE,\n  receivedAt?: number\n): Promise<WebhookEvent> {\n  await verifyHeaderAsync(payload, header, secret, tolerance, receivedAt);\n\n  const jsonPayload =\n    payload instanceof Uint8Array\n      ? JSON.parse(new TextDecoder(\"utf8\").decode(payload))\n      : JSON.parse(payload);\n  return jsonPayload;\n}\n\nfunction makeHMACContent(\n  payload: WebhookPayload,\n  details: WebhookParsedHeader\n): string {\n  return `${details.timestamp}.${payload}`;\n}\n\nasync function verifyHeaderAsync(\n  encodedPayload: WebhookPayload,\n  encodedHeader: WebhookHeader,\n  secret: string,\n  tolerance: number,\n  receivedAt?: number\n): Promise<boolean> {\n  const {\n    decodedHeader: header,\n    decodedPayload: payload,\n    details,\n    suspectPayloadType,\n  } = parseEventDetails(encodedPayload, encodedHeader, EXPECTED_SCHEME);\n  const secretContainsWhitespace = /\\s/.test(secret);\n\n  const expectedSignature = await computeHMACSignatureAsync(\n    makeHMACContent(payload, details),\n    secret\n  );\n\n  return validateComputedSignature(\n    payload,\n    header,\n    details,\n    expectedSignature,\n    tolerance,\n    suspectPayloadType,\n    secretContainsWhitespace,\n    receivedAt\n  );\n}\n\nfunction parseEventDetails(\n  encodedPayload: WebhookPayload,\n  encodedHeader: WebhookHeader,\n  expectedScheme: string\n): WebhookParsedEvent {\n  if (!encodedPayload) {\n    throw new StripeSignatureVerificationError(encodedHeader, encodedPayload, {\n      message: \"No webhook payload was provided.\",\n    });\n  }\n\n  const suspectPayloadType =\n    typeof encodedPayload != \"string\" &&\n    !(encodedPayload instanceof Uint8Array);\n\n  const textDecoder = new TextDecoder(\"utf8\");\n  const decodedPayload =\n    encodedPayload instanceof Uint8Array\n      ? textDecoder.decode(encodedPayload)\n      : encodedPayload;\n\n  // Express's type for `Request#headers` is `string | []string`\n  // which is because the `set-cookie` header is an array,\n  // but no other headers are an array (docs: https://nodejs.org/api/http.html#http_message_headers)\n  // (Express's Request class is an extension of http.IncomingMessage, and doesn't appear to be relevantly modified: https://github.com/expressjs/express/blob/master/lib/request.js#L31)\n  if (Array.isArray(encodedHeader)) {\n    throw new Error(\n      \"Unexpected: An array was passed as a header, which should not be possible for the stripe-signature header.\"\n    );\n  }\n\n  if (encodedHeader == null || encodedHeader == \"\") {\n    throw new StripeSignatureVerificationError(encodedHeader, encodedPayload, {\n      message: \"No stripe-signature header value was provided.\",\n    });\n  }\n\n  const decodedHeader =\n    encodedHeader instanceof Uint8Array\n      ? textDecoder.decode(encodedHeader)\n      : encodedHeader;\n\n  const details = parseHeader(decodedHeader, expectedScheme);\n\n  if (!details || details.timestamp === -1) {\n    throw new StripeSignatureVerificationError(decodedHeader, decodedPayload, {\n      message: \"Unable to extract timestamp and signatures from header\",\n    });\n  }\n\n  if (!details.signatures.length) {\n    throw new StripeSignatureVerificationError(decodedHeader, decodedPayload, {\n      message: \"No signatures found with expected scheme\",\n    });\n  }\n\n  return {\n    decodedPayload,\n    decodedHeader,\n    details,\n    suspectPayloadType,\n  };\n}\n\nfunction validateComputedSignature(\n  payload: WebhookPayload,\n  header: WebhookHeader,\n  details: WebhookParsedHeader,\n  expectedSignature: string,\n  tolerance: number,\n  suspectPayloadType: boolean,\n  secretContainsWhitespace: boolean,\n  receivedAt?: number\n): boolean {\n  const signatureFound = !!details.signatures.filter((sig) =>\n    secureCompare(sig, expectedSignature)\n  ).length;\n\n  const docsLocation =\n    \"\\nLearn more about webhook signing and explore webhook integration examples for various frameworks at \" +\n    \"https://github.com/stripe/stripe-node#webhook-signing\";\n\n  const whitespaceMessage = secretContainsWhitespace\n    ? \"\\n\\nNote: The provided signing secret contains whitespace. This often indicates an extra newline or space is in the value\"\n    : \"\";\n\n  if (!signatureFound) {\n    if (suspectPayloadType) {\n      throw new StripeSignatureVerificationError(header, payload, {\n        message:\n          \"Webhook payload must be provided as a string or a Buffer (https://nodejs.org/api/buffer.html) instance representing the _raw_ request body.\" +\n          \"Payload was provided as a parsed JavaScript object instead. \\n\" +\n          \"Signature verification is impossible without access to the original signed material. \\n\" +\n          docsLocation +\n          \"\\n\" +\n          whitespaceMessage,\n      });\n    }\n    throw new StripeSignatureVerificationError(header, payload, {\n      message:\n        \"No signatures found matching the expected signature for payload.\" +\n        \" Are you passing the raw request body you received from Stripe? \\n\" +\n        \" If a webhook request is being forwarded by a third-party tool,\" +\n        \" ensure that the exact request body, including JSON formatting and new line style, is preserved.\\n\" +\n        docsLocation +\n        \"\\n\" +\n        whitespaceMessage,\n    });\n  }\n\n  const timestampAge =\n    Math.floor(\n      (typeof receivedAt === \"number\" ? receivedAt : Date.now()) / 1000\n    ) - details.timestamp;\n\n  if (tolerance > 0 && timestampAge > tolerance) {\n    throw new StripeSignatureVerificationError(header, payload, {\n      message: \"Timestamp outside the tolerance zone\",\n    });\n  }\n\n  return true;\n}\n\nfunction parseHeader(\n  header: WebhookHeader,\n  scheme: string\n): WebhookParsedHeader | null {\n  if (typeof header !== \"string\") {\n    return null;\n  }\n\n  return header.split(\",\").reduce<WebhookParsedHeader>(\n    (accum, item) => {\n      const kv = item.split(\"=\");\n\n      if (kv[0] === \"t\") {\n        accum.timestamp = parseInt(kv[1], 10);\n      }\n\n      if (kv[0] === scheme) {\n        accum.signatures.push(kv[1]);\n      }\n\n      return accum;\n    },\n    {\n      timestamp: -1,\n      signatures: [],\n    }\n  );\n}\n\n/**\n * Compares strings in constant time.\n */\nfunction secureCompare(a: string, b: string): boolean {\n  // return early here if buffer lengths are not equal\n  if (a.length !== b.length) {\n    return false;\n  }\n  const len = a.length;\n  let result = 0;\n  for (let i = 0; i < len; ++i) {\n    result |= a.charCodeAt(i) ^ b.charCodeAt(i);\n  }\n  return result === 0;\n}\n\n/** @override */\nexport async function computeHMACSignatureAsync(\n  payload: string,\n  secret: string\n): Promise<string> {\n  const encoder = new TextEncoder();\n\n  const key = await crypto.subtle.importKey(\n    \"raw\",\n    encoder.encode(secret),\n    {\n      name: \"HMAC\",\n      hash: { name: \"SHA-256\" },\n    },\n    false,\n    [\"sign\"]\n  );\n\n  const signatureBuffer = await crypto.subtle.sign(\n    \"hmac\",\n    key,\n    encoder.encode(payload)\n  );\n\n  // crypto.subtle returns the signature in base64 format. This must be\n  // encoded in hex to match the CryptoProvider contract. We map each byte in\n  // the buffer to its corresponding hex octet and then combine into a string.\n  const signatureBytes = new Uint8Array(signatureBuffer);\n  const signatureHexCodes = new Array(signatureBytes.length);\n\n  for (let i = 0; i < signatureBytes.length; i++) {\n    signatureHexCodes[i] = byteHexMapping[signatureBytes[i]];\n  }\n\n  return signatureHexCodes.join(\"\");\n}\n\n// Cached mapping of byte to hex representation. We do this once to avoid re-\n// computing every time we need to convert the result of a signature to hex.\nconst byteHexMapping = new Array(256);\nfor (let i = 0; i < byteHexMapping.length; i++) {\n  byteHexMapping[i] = i.toString(16).padStart(2, \"0\");\n}\n", "import { ConfigurationError } from \"../errors\";\nimport { isObject } from \"./types\";\n\ntype ExpectedType = \"string\" | \"number\" | \"boolean\" | \"object\" | \"array\";\n\nexport function optionValidator<TOptions>(\n  options: TOptions,\n  sourceName: string,\n  sourceType = \"policy\"\n) {\n  const optionSourceName = `${sourceType} '${sourceName}'`;\n  if (!isObject(options)) {\n    throw new ConfigurationError(\n      `Options on ${optionSourceName} is expected to be an object. Received the type '${typeof options}'.`\n    );\n  }\n\n  const validate = (\n    optionName: keyof TOptions,\n    expectedType: ExpectedType,\n    optional: boolean\n  ) => {\n    // The isObject validation above will insure this is okay\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const optionValue = (options as any)[optionName];\n    // 1. Check for undefined\n    if (optional && optionValue === undefined) {\n      return;\n    } else if (optionValue === undefined) {\n      throw new ConfigurationError(\n        `Value of '${String(\n          optionName\n        )}' on ${optionSourceName} is required, but no value was set. If using an environment variable, check that it is set correctly.`\n      );\n    }\n\n    // Check the type is correct\n    if (expectedType === \"array\" && Array.isArray(optionValue)) {\n      throw new ConfigurationError(\n        `Value of '${String(\n          optionName\n        )}' on ${optionSourceName} must be an array. Received type ${typeof optionValue}.`\n      );\n    } else if (typeof optionValue !== expectedType) {\n      throw new ConfigurationError(\n        `Value of '${String(\n          optionName\n        )}' on ${optionSourceName} must be of type ${expectedType}. Received type ${typeof optionValue}.`\n      );\n    }\n\n    // Additional type specific validation\n    if (typeof optionValue === \"string\" && optionValue.length === 0) {\n      throw new ConfigurationError(\n        `Value of '${String(\n          optionName\n        )}' on ${optionSourceName} must be a non-empty string. The value received is empty. If using an environment variable, check that it is set correctly.`\n      );\n    } else if (typeof optionValue === \"number\" && isNaN(optionValue)) {\n      throw new ConfigurationError(\n        `Value of '${String(\n          optionName\n        )}' on ${optionSourceName} must be valid number. If using an environment variable, check that it is set correctly.`\n      );\n    }\n  };\n\n  const optional = (optionName: keyof TOptions, expectedType: ExpectedType) => {\n    validate(optionName, expectedType, true);\n    return { optional, required };\n  };\n  const required = (optionName: keyof TOptions, expectedType: ExpectedType) => {\n    validate(optionName, expectedType, false);\n    return { optional, required };\n  };\n\n  return { optional, required };\n}\n", "import { ZuploContext } from \"../../context\";\nimport { InboundPolicy } from \"../../policies\";\nimport { HttpProblems } from \"../../problem-responses/http-problems\";\nimport { ZuploRequest } from \"../../request\";\nimport { constructEventAsync } from \"../../utils/stripe/webhook\";\nimport { optionValidator } from \"../../utils/validator\";\nimport { StripeWebhookVerificationInboundPolicyOptions } from \"./options\";\n\nexport { StripeWebhookVerificationInboundPolicyOptions };\n\n/**\n * The Stripe Webhook policy validates the authenticity of an incoming Stripe webhook.\n *\n * @remarks\n * The Stripe Webhook policy secures your incoming webhooks by validating that\n * the request was sent by Stripe.\n *\n * @title Stripe Webhook Auth\n * @public\n * @param request - The ZuploRequest\n * @param context - The ZuploContext\n * @param options - The policy options set in policies.json\n * @param policyName - The name of the policy as set in policies.json\n * @returns A Request or a Response\n */\nexport class StripeWebhookVerificationInboundPolicy extends InboundPolicy<StripeWebhookVerificationInboundPolicyOptions> {\n  async handler(request: ZuploRequest, context: ZuploContext) {\n    optionValidator(this.options, this.policyName)\n      .required(\"signingSecret\", \"string\")\n      .optional(\"tolerance\", \"number\");\n\n    const sig = request.headers.get(\"stripe-signature\");\n\n    try {\n      const body = await request.clone().text();\n      await constructEventAsync(\n        body,\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        sig!,\n        this.options.signingSecret\n      );\n    } catch (err) {\n      let erroMessage = err.message;\n      if (err.type && err.type === \"StripeSignatureVerificationError\") {\n        const message: string = err.message;\n        const regex = /Note:(.*)/g;\n        const match = regex.exec(message);\n        erroMessage = match ? match[1].trim() : message;\n\n        if (\n          erroMessage.startsWith(\n            \"No signatures found matching the expected signature for payload\"\n          )\n        ) {\n          erroMessage =\n            \"The Stripe Webhook Signature Secret provided is incorrect and does not match to the signature on the event received. Make sure your Zuplo configuration is correct.\";\n        }\n      }\n\n      context.log.error(`Error validating stripe webhook`, erroMessage);\n      return HttpProblems.badRequest(request, context, {\n        title: \"Webhook Error\",\n        detail: erroMessage,\n      });\n    }\n\n    return request;\n  }\n}\n", "import { isString } from \"../types\";\nimport { StripeWebhookEvent } from \"./interfaces\";\n\nexport function isStripeWebhookEvent(\n  event: unknown\n): event is StripeWebhookEvent {\n  return (\n    event !== null &&\n    typeof event === \"object\" &&\n    \"id\" in event &&\n    isString(event.id) &&\n    \"type\" in event &&\n    isString(event.type)\n  );\n}\n", "import { RuntimeError } from \"../../errors\";\nimport internals from \"../../internals\";\nimport { Logger } from \"../../logging/interfaces\";\nimport { StripeSubscription, StripeUpcomingInvoice } from \"./interfaces\";\n\nconst StripeApi = {\n  getSubscription: async ({\n    subscriptionId,\n    stripeSecretKey,\n    logger,\n  }: {\n    subscriptionId: string;\n    stripeSecretKey: string;\n    logger: Logger;\n  }) => {\n    const response = await internals.fetch(\n      `https://api.stripe.com/v1/subscriptions/${subscriptionId}`,\n      {\n        headers: {\n          Authorization: `Bearer ${stripeSecretKey}`,\n        },\n      }\n    );\n\n    const subscriptionResult = await response.json();\n    if (response.status !== 200) {\n      const message = `Error retrieving subscription from Stripe API.`;\n      logger.error(message, subscriptionResult);\n      throw new RuntimeError(message);\n    }\n\n    return subscriptionResult as StripeSubscription;\n  },\n  getCustomer: async ({\n    customerId,\n    stripeSecretKey,\n    logger,\n  }: {\n    customerId: string;\n    stripeSecretKey: string;\n    logger: Logger;\n  }) => {\n    const response = await internals.fetch(\n      `https://api.stripe.com/v1/customers/${customerId}`,\n      {\n        headers: {\n          Authorization: `Bearer ${stripeSecretKey}`,\n        },\n      }\n    );\n\n    const customerResult = await response.json();\n    if (response.status !== 200) {\n      const message = `Error retrieving customer from Stripe API.`;\n      logger.error(message, customerResult);\n      throw new RuntimeError(message);\n    }\n\n    return customerResult as { email: string };\n  },\n  getUpcomingInvoice: async ({\n    customerId,\n    stripeSecretKey,\n    logger,\n  }: {\n    customerId: string;\n    stripeSecretKey: string;\n    logger: Logger;\n  }) => {\n    const response = await internals.fetch(\n      `https://api.stripe.com/v1/invoices/upcoming?customer=${customerId}`,\n      {\n        headers: {\n          Authorization: `Bearer ${stripeSecretKey}`,\n        },\n      }\n    );\n\n    const invoiceResult = await response.json();\n    if (response.status !== 200) {\n      const message = `Error retrieving customer upcoming invoice from Stripe API.`;\n      logger.error(message, invoiceResult);\n      throw new RuntimeError(message);\n    }\n\n    return invoiceResult as StripeUpcomingInvoice;\n  },\n};\n\nexport default StripeApi;\n", "import { ZuploContext } from \"../../context\";\nimport { RuntimeError } from \"../../errors\";\nimport { SystemLogMap } from \"../../system-log-map\";\nimport { Environment } from \"../../utils/environment\";\nimport { fetchRetry } from \"../../utils/retry\";\n\n// This needs to be direct and not apikeys.zuplo.com since the management backend is not exposed there\nconst API_KEY_MANAGEMENT_SERVICE_URL =\n  \"https://api-key-management-service-eq7z4lly2a-ue.a.run.app\";\nconst MONETIZATION_CONSUMER_LABEL = \"My API Key\";\n\n/**\n * Creates an API Key Consumer\n */\nexport async function createConsumer({\n  apiKeyBucketName,\n  stripeSubscriptionId,\n  stripeProductId,\n  stripeCustomerId,\n  managerEmail,\n  managerSub,\n  context,\n}: {\n  apiKeyBucketName: string;\n  stripeSubscriptionId: string;\n  stripeProductId: string;\n  stripeCustomerId: string;\n  managerEmail: string;\n  managerSub: string;\n  context: ZuploContext;\n}) {\n  const { authApiJWT } = Environment.instance;\n\n  const url = new URL(\n    `/v1/buckets/${apiKeyBucketName}/consumers`,\n    API_KEY_MANAGEMENT_SERVICE_URL\n  );\n  url.searchParams.set(\"with-api-key\", \"true\");\n\n  const consumerId = crypto.randomUUID();\n\n  const body = {\n    name: consumerId,\n    description: MONETIZATION_CONSUMER_LABEL,\n    tags: {\n      // Adding as tags so we can query the API\n      subscriptionExternalId: stripeSubscriptionId,\n      planExternalIds: [stripeProductId],\n    },\n    metadata: {\n      // Metadata so the customer can use it if they want\n      stripeSubscriptionId,\n      stripeProductId,\n      stripeCustomerId,\n    },\n    managers: [{ sub: managerSub, email: managerEmail }],\n  };\n\n  const response = await fetchRetry(\n    {\n      retryDelayMs: 5,\n      retries: 2,\n      logger: SystemLogMap.getLogger(context),\n    },\n    url.toString(),\n    {\n      method: \"POST\",\n      headers: {\n        Authorization: `Bearer ${authApiJWT}`,\n        \"content-type\": \"application/json\",\n      },\n      body: JSON.stringify(body),\n    }\n  );\n\n  const result = await response.json();\n\n  if (response.status !== 200) {\n    const message = `Error creating API Key Consumer`;\n    context.log.error(message, result);\n    throw new RuntimeError(message);\n  }\n\n  context.log.info(`Successfully created API Key Consumer`, {\n    consumerId,\n    stripeSubscriptionId,\n    stripeProductId,\n  });\n  return consumerId;\n}\n\n/**\n * Creates an API Key Consumer and Manager Invite\n */\nexport async function createConsumerInvite({\n  apiKeyBucketName,\n  stripeSubscriptionId,\n  stripeProductId,\n  stripeCustomerId,\n  managerEmail,\n  context,\n}: {\n  apiKeyBucketName: string;\n  stripeSubscriptionId: string;\n  stripeProductId: string;\n  stripeCustomerId: string;\n  managerEmail: string;\n  context: ZuploContext;\n}) {\n  const { authApiJWT } = Environment.instance;\n\n  const url = new URL(\n    `/v1/buckets/${apiKeyBucketName}/consumers`,\n    API_KEY_MANAGEMENT_SERVICE_URL\n  );\n  url.searchParams.set(\"with-api-key\", \"true\");\n\n  const consumerId = crypto.randomUUID();\n\n  const body = {\n    name: consumerId,\n    description: MONETIZATION_CONSUMER_LABEL,\n    tags: {\n      // Adding as tags so we can query the API\n      subscriptionExternalId: stripeSubscriptionId,\n      planExternalIds: [stripeProductId],\n    },\n    metadata: {\n      // Metadata so the customer can use it if they want\n      stripeSubscriptionId,\n      stripeProductId,\n      stripeCustomerId,\n    },\n    managers: [managerEmail],\n  };\n\n  const response = await fetchRetry(\n    {\n      retryDelayMs: 5,\n      retries: 2,\n      logger: SystemLogMap.getLogger(context),\n    },\n    url.toString(),\n    {\n      method: \"POST\",\n      headers: {\n        Authorization: `Bearer ${authApiJWT}`,\n        \"content-type\": \"application/json\",\n      },\n      body: JSON.stringify(body),\n    }\n  );\n\n  const result = await response.json();\n\n  if (response.status !== 200) {\n    const message = `Error creating API Key Consumer`;\n    context.log.error(message, result);\n    throw new RuntimeError(message);\n  }\n\n  context.log.info(\n    `Successfully created API Key Consumer with Manager Invite`,\n    {\n      consumerId,\n      stripeSubscriptionId,\n      stripeProductId,\n    }\n  );\n  return consumerId;\n}\n\n/**\n * Deletes an API Key Consumer\n */\nexport async function deleteConsumer({\n  apiKeyBucketName,\n  consumerId,\n  context,\n}: {\n  apiKeyBucketName: string;\n  consumerId: string;\n  context: ZuploContext;\n}) {\n  const { authApiJWT } = Environment.instance;\n\n  const url = new URL(\n    `/v1/buckets/${apiKeyBucketName}/consumers/${consumerId}`,\n    API_KEY_MANAGEMENT_SERVICE_URL\n  );\n  url.searchParams.set(\"with-api-key\", \"true\");\n\n  const response = await fetchRetry(\n    {\n      retryDelayMs: 5,\n      retries: 2,\n      logger: SystemLogMap.getLogger(context),\n    },\n    url.toString(),\n    {\n      method: \"DELETE\",\n      headers: {\n        Authorization: `Bearer ${authApiJWT}`,\n        \"content-type\": \"application/json\",\n      },\n      body: JSON.stringify({}),\n    }\n  );\n\n  if (response.status !== 204) {\n    const result = await response.json();\n    const message = `Error invalidating API Key Consumer`;\n    context.log.error(message, result);\n    throw new RuntimeError(message);\n  }\n\n  context.log.info(`Successfully invalidated API Key Consumer '${consumerId}`);\n  return consumerId;\n}\n", "import { ZuploContext } from \"../../context\";\nimport { RuntimeError, SystemError } from \"../../errors\";\nimport {\n  MeteringRegions,\n  MeteringSubscription,\n  MeteringSubscriptionStatus,\n  StoredMeteringSubscriptionWithQuotas,\n} from \"../../metering-interfaces\";\nimport { ProblemDetails } from \"../../problem-responses/problem\";\nimport { SystemLogMap } from \"../../system-log-map\";\nimport { Environment } from \"../../utils/environment\";\nimport { fetchRetry } from \"../../utils/retry\";\nimport { isNonEmptyString } from \"../../utils/types\";\n\n/**\n * Creates a Metering subscription\n */\nexport async function createSubscription({\n  context,\n  stripeSubscriptionId,\n  stripeProductId,\n  customerKey,\n  meteringBucketId,\n  meteringBucketRegion,\n  customerExternalId,\n  subscriptionStatus,\n  metadata,\n}: {\n  context: ZuploContext;\n  stripeSubscriptionId: string;\n  stripeProductId: string;\n  customerKey: string;\n  meteringBucketId: string;\n  meteringBucketRegion: MeteringRegions;\n  customerExternalId: string;\n  subscriptionStatus: MeteringSubscriptionStatus;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  metadata?: Record<string, any>;\n}) {\n  const body: MeteringSubscription = {\n    status: subscriptionStatus,\n    type: \"periodic\",\n    renewalStrategy: \"monthly\",\n    region: meteringBucketRegion,\n    subscriptionExternalId: stripeSubscriptionId,\n    planExternalIds: [stripeProductId],\n    customerKey,\n    customerExternalId,\n    metadata,\n  };\n\n  const { authApiJWT, meteringServiceUrl } = Environment.instance;\n  if (!isNonEmptyString(authApiJWT)) {\n    throw new SystemError(\"No Zuplo JWT token set.\");\n  }\n\n  const response = await fetchRetry(\n    {\n      retryDelayMs: 5,\n      retries: 2,\n      logger: SystemLogMap.getLogger(context),\n    },\n    `${meteringServiceUrl}/internal/v1/metering/${meteringBucketId}/subscriptions`,\n    {\n      headers: {\n        Authorization: `Bearer ${authApiJWT}`,\n        \"Content-Type\": \"application/json\",\n        \"zp-rid\": context.requestId,\n      },\n      method: \"POST\",\n      body: JSON.stringify(body),\n    }\n  );\n\n  if (!response.ok) {\n    const message = `Unable to create a monetization subscription for Stripe subscription '${stripeSubscriptionId}'.`;\n    let problem: ProblemDetails;\n    let additionalErrorInformation: string = \"\";\n    try {\n      problem = (await response.json()) as ProblemDetails;\n      additionalErrorInformation = problem.detail ?? problem.title;\n    } catch (err) {\n      problem = {\n        type: \"https://zup.fail/http-status/500\",\n        title: \"Internal Server Error\",\n        status: response.status,\n        detail: response.statusText,\n      };\n    }\n\n    context.log.error(message, problem);\n    throw new RuntimeError(`${message} ${additionalErrorInformation}`);\n  }\n  context.log.info(`Successfully created monetization subscription.`, body);\n}\n\n/**\n * Update a Metering subscription\n */\nexport async function updateSubscription({\n  context,\n  meteringSubscriptionId,\n  meteringBucketId,\n  requestBody,\n}: {\n  context: ZuploContext;\n  meteringSubscriptionId: string;\n  meteringBucketId: string;\n  requestBody: {\n    status: MeteringSubscriptionStatus;\n    planExternalIds: string[];\n    prorate?: number;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    metadata?: Record<string, any>;\n  };\n}) {\n  const { authApiJWT, meteringServiceUrl } = Environment.instance;\n  if (!isNonEmptyString(authApiJWT)) {\n    throw new SystemError(\"No Zuplo JWT token set.\");\n  }\n\n  const updateSubscription = await fetchRetry(\n    {\n      retryDelayMs: 5,\n      retries: 2,\n      logger: SystemLogMap.getLogger(context),\n    },\n    `${meteringServiceUrl}/internal/v1/metering/${meteringBucketId}/subscriptions/${meteringSubscriptionId}`,\n    {\n      headers: {\n        Authorization: `Bearer ${authApiJWT}`,\n        \"Content-Type\": \"application/json\",\n        \"zp-rid\": context.requestId,\n      },\n      method: \"PATCH\",\n      body: JSON.stringify(requestBody),\n    }\n  );\n\n  if (!updateSubscription.ok) {\n    const message = `Unable to update monetization subscription with: '${JSON.stringify(\n      requestBody\n    )}'.`;\n    let problem: ProblemDetails;\n    let additionalErrorInformation: string = \"\";\n    try {\n      problem = (await updateSubscription.json()) as ProblemDetails;\n      additionalErrorInformation = problem.detail ?? problem.title;\n    } catch (err) {\n      problem = {\n        type: \"https://zup.fail/http-status/500\",\n        title: \"Internal Server Error\",\n        status: updateSubscription.status,\n        detail: updateSubscription.statusText,\n      };\n    }\n    context.log.error(message, problem);\n    throw new RuntimeError(`${message} ${additionalErrorInformation}`);\n  }\n\n  context.log.info(\n    `Successfully updated monetization subscription with: '${JSON.stringify(\n      requestBody\n    )}'.`\n  );\n}\n\n/**\n * Query for Metering subscriptions\n */\nexport async function getSubscription({\n  context,\n  stripeSubscriptionId,\n  stripeCustomerId,\n  meteringBucketId,\n}: {\n  context: ZuploContext;\n  stripeSubscriptionId: string;\n  stripeCustomerId: string;\n  meteringBucketId: string;\n}): Promise<StoredMeteringSubscriptionWithQuotas> {\n  const { authApiJWT, meteringServiceUrl } = Environment.instance;\n  if (!isNonEmptyString(authApiJWT)) {\n    throw new SystemError(\"No Zuplo JWT token set.\");\n  }\n\n  const response = await fetchRetry(\n    {\n      retryDelayMs: 5,\n      retries: 2,\n      logger: SystemLogMap.getLogger(context),\n    },\n    `${meteringServiceUrl}/internal/v1/metering/${meteringBucketId}/subscriptions?subscriptionExternalId=${stripeSubscriptionId}`,\n    {\n      headers: {\n        Authorization: `Bearer ${authApiJWT}`,\n        \"zp-rid\": context.requestId,\n      },\n      method: \"GET\",\n    }\n  );\n\n  if (!response.ok) {\n    const message = `Unable to retrieve the monetization subscription for Stripe subscription '${stripeSubscriptionId}'.`;\n    let problem: ProblemDetails;\n    let additionalErrorInformation: string = \"\";\n    try {\n      problem = (await response.json()) as ProblemDetails;\n      additionalErrorInformation = problem.detail ?? problem.title;\n    } catch (err) {\n      problem = {\n        type: \"https://zup.fail/http-status/500\",\n        title: \"Internal Server Error\",\n        status: response.status,\n        detail: response.statusText,\n      };\n    }\n    context.log.error(message, problem);\n    throw new RuntimeError(`${message} ${additionalErrorInformation}`);\n  }\n\n  const bucketSubscriptions = (await response.json()) as {\n    data: StoredMeteringSubscriptionWithQuotas[];\n  };\n\n  if (bucketSubscriptions.data.length === 0) {\n    const message = `Subscription was not found for Stripe subscription '${stripeSubscriptionId}' and the event was ignored by Zuplo.`;\n    context.log.error(message);\n    throw new RuntimeError(message);\n  }\n\n  if (bucketSubscriptions.data[0].customerExternalId !== stripeCustomerId) {\n    const message = `Subscription was not found for Stripe customer '${stripeCustomerId}' and the event was ignored by Zuplo.`;\n    context.log.error(message);\n    throw new RuntimeError(message);\n  }\n\n  return bucketSubscriptions.data[0];\n}\n", "import { MeteringSubscriptionStatus } from \"../../metering-interfaces\";\nimport { StripeSubscriptionStatus } from \"../../utils/stripe/interfaces\";\n\nexport const UNABLE_PROCESS_WEBHOOK_EVENT = \"Unable to process webhook event.\";\nexport const SUCCESS_PROCESSING_WEBHOOK_EVENT =\n  \"Successfully processed webhook event\";\nexport const MONETIZATION_DOC_ERROR_DETAIL =\n  \"See https://zuplo.com/docs/articles/monetization-troubleshooting for more details.\";\n\nexport function stripeStatusToMeteringStatus(\n  stripeStatus: StripeSubscriptionStatus\n) {\n  return stripeStatus.replaceAll(\"_\", \"-\") as MeteringSubscriptionStatus;\n}\n\n/**\n * Converts Stripe unix epoch timestamps to ISO 8601 datetime string in UTC\n * e.g. 1713548757 to 2024-04-19T17:45:57.000Z\n * @param timestamp - number\n * @returns\n */\nexport function unixTimestampToISOString(timestamp: number): string {\n  const date = new Date(timestamp * 1000);\n  return date.toISOString();\n}\n", "import { ZuploContext } from \"../../context\";\nimport { MeteringRegions } from \"../../metering-interfaces\";\nimport { HttpProblems } from \"../../problem-responses/http-problems\";\nimport { ZuploRequest } from \"../../request\";\nimport { Environment } from \"../../utils/environment\";\nimport StripeApi from \"../../utils/stripe/api\";\nimport { StripeCustomerSubscriptionCreatedWebHookEvent } from \"../../utils/stripe/interfaces\";\nimport {\n  createConsumer,\n  createConsumerInvite,\n  deleteConsumer,\n} from \"./apikey-mgmt-service-operations\";\nimport { createSubscription } from \"./metering-service-operations\";\nimport {\n  MONETIZATION_DOC_ERROR_DETAIL,\n  SUCCESS_PROCESSING_WEBHOOK_EVENT,\n  UNABLE_PROCESS_WEBHOOK_EVENT,\n  stripeStatusToMeteringStatus,\n} from \"./utils\";\n\nexport default async function onCustomerSubscriptionCreated(\n  request: ZuploRequest,\n  context: ZuploContext,\n  subscriptionEvent: StripeCustomerSubscriptionCreatedWebHookEvent,\n  options: {\n    meteringBucketId: string;\n    apiKeyBucketName: string;\n    meteringBucketRegion: MeteringRegions;\n    stripeSecretKey: string;\n  }\n): Promise<HttpProblems> {\n  const stripeSubscriptionId = subscriptionEvent.data.object.id;\n\n  if (!stripeSubscriptionId) {\n    context.log.warn(\n      `Invalid Stripe webhook event. Expected event '${subscriptionEvent.id}' to have '.data.object.id' be the subscription ID.`\n    );\n    return HttpProblems.badRequest(request, context, {\n      title: UNABLE_PROCESS_WEBHOOK_EVENT,\n      detail:\n        \"Invalid Stripe webhook event. Expected '.data.object.id' to be the subscription ID.\",\n    });\n  }\n\n  const planItem = subscriptionEvent.data.object.plan;\n\n  if (!planItem || !planItem.product) {\n    context.log.warn(\n      `Invalid Stripe API result. Expected event '${subscriptionEvent.id}' to have a plan data.`\n    );\n    return HttpProblems.badRequest(request, context, {\n      title: UNABLE_PROCESS_WEBHOOK_EVENT,\n      detail: \"Invalid Stripe API result. Expected event to have a plan data.\",\n    });\n  }\n\n  const stripeCustomerId = subscriptionEvent.data.object.customer;\n  if (!stripeCustomerId) {\n    context.log.warn(\n      `Invalid Stripe webhook event. Expected '.data.object.customer' to be provided by event '${subscriptionEvent.id}'`\n    );\n    return HttpProblems.badRequest(request, context, {\n      title: UNABLE_PROCESS_WEBHOOK_EVENT,\n      detail:\n        \"Invalid Stripe webhook event. Expected '.data.object.customer' to be provided\",\n    });\n  }\n\n  // @NOTE - we will try to ignore events that are not issued for the Zups deploymentName\n  // but there are scenarios in which this info cannot be found on the Stripe subscription\n  if (\n    subscriptionEvent.data.object.metadata &&\n    subscriptionEvent.data.object.metadata.zuplo_created_by_deploymentName &&\n    subscriptionEvent.data.object.metadata.zuplo_created_by_deploymentName !==\n      Environment.instance.deploymentName\n  ) {\n    context.log.warn(\n      `Subscription event '${subscriptionEvent.id}' will not be handled since it was not issued for this Zuplo environment. It was intended for '${subscriptionEvent.data.object.metadata.zuplo_created_by_deploymentName}'.`\n    );\n\n    return HttpProblems.badRequest(request, context, {\n      title: UNABLE_PROCESS_WEBHOOK_EVENT,\n      detail:\n        \"This subscription event is not meant to be handled by this environment's Stripe monetization plugin. \" +\n        `It was intended for '${subscriptionEvent.data.object.metadata.zuplo_created_by_deploymentName}'. ` +\n        \"This can happen because of a misconfiguration of Stripe or your Zuplo API.\" +\n        MONETIZATION_DOC_ERROR_DETAIL,\n    });\n  }\n\n  const stripeProductId = planItem.product;\n\n  let customerKey: string;\n  let managerEmail: string | undefined;\n  let managerSub: string | undefined;\n  if (\n    subscriptionEvent.data.object.metadata &&\n    subscriptionEvent.data.object.metadata.zuplo_created_by_email &&\n    subscriptionEvent.data.object.metadata.zuplo_created_by_sub\n  ) {\n    managerEmail =\n      subscriptionEvent.data.object.metadata.zuplo_created_by_email;\n    managerSub = subscriptionEvent.data.object.metadata.zuplo_created_by_sub;\n\n    // @NOTE - Use metadata added by Dev Portal and create a consumer + manager\n    customerKey = await createConsumer({\n      apiKeyBucketName: options.apiKeyBucketName,\n      stripeProductId,\n      stripeSubscriptionId,\n      stripeCustomerId,\n      managerEmail,\n      managerSub,\n      context,\n    });\n  } else {\n    // @NOTE - Get the full stripe customer since this event does not have consumer info\n    // and create a consumer + manager invite\n    const stripeCustomer = await StripeApi.getCustomer({\n      logger: context.log,\n      stripeSecretKey: options.stripeSecretKey,\n      customerId: stripeCustomerId,\n    });\n\n    if (!stripeCustomer.email) {\n      context.log.warn(\n        `Invalid Stripe API result. Expected customer '${stripeCustomerId}' to contain email address.`\n      );\n      return HttpProblems.badRequest(request, context, {\n        title: UNABLE_PROCESS_WEBHOOK_EVENT,\n        detail:\n          \"Invalid Stripe API result. Expected customer to contain email address.\",\n      });\n    }\n\n    customerKey = await createConsumerInvite({\n      apiKeyBucketName: options.apiKeyBucketName,\n      stripeProductId,\n      stripeSubscriptionId,\n      stripeCustomerId,\n      managerEmail: stripeCustomer.email,\n      context,\n    });\n  }\n\n  if (!customerKey) {\n    // TODO: Check if consumer already exists for user?\n    return HttpProblems.internalServerError(request, context, {\n      title: UNABLE_PROCESS_WEBHOOK_EVENT,\n      detail: `No API Key Consumer was created, skipping creation of subscription.`,\n    });\n  }\n\n  try {\n    const subscriptionStatus = stripeStatusToMeteringStatus(\n      subscriptionEvent.data.object.status\n    );\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let metadata: Record<string, any> | undefined;\n    if (managerEmail && managerSub) {\n      metadata = {\n        subscriber: {\n          sub: managerSub,\n          email: managerEmail,\n        },\n      };\n    }\n\n    await createSubscription({\n      context,\n      stripeProductId,\n      stripeSubscriptionId,\n      customerKey,\n      meteringBucketId: options.meteringBucketId,\n      meteringBucketRegion: options.meteringBucketRegion,\n      customerExternalId: stripeCustomerId,\n      subscriptionStatus,\n      metadata,\n    });\n  } catch (err) {\n    // Rollback/delete created consumer first\n    await deleteConsumer({\n      apiKeyBucketName: options.apiKeyBucketName,\n      consumerId: customerKey,\n      context,\n    });\n\n    return HttpProblems.internalServerError(request, context, {\n      title: UNABLE_PROCESS_WEBHOOK_EVENT,\n      detail: err.message,\n    });\n  }\n\n  return HttpProblems.ok(request, context, {\n    title: SUCCESS_PROCESSING_WEBHOOK_EVENT,\n  });\n}\n", "import { ZuploContext } from \"../../context\";\nimport { HttpProblems } from \"../../problem-responses/http-problems\";\nimport { ZuploRequest } from \"../../request\";\nimport { Environment } from \"../../utils/environment\";\nimport { StripeCustomerSubscriptionDeletedWebHookEvent } from \"../../utils/stripe/interfaces\";\nimport {\n  getSubscription,\n  updateSubscription,\n} from \"./metering-service-operations\";\nimport {\n  MONETIZATION_DOC_ERROR_DETAIL,\n  SUCCESS_PROCESSING_WEBHOOK_EVENT,\n  UNABLE_PROCESS_WEBHOOK_EVENT,\n} from \"./utils\";\n\n// Docs: https://stripe.com/docs/billing/subscriptions/cancel?dashboard-or-api=api#events\nexport default async function onCustomerSubscriptionDeleted(\n  request: ZuploRequest,\n  context: ZuploContext,\n  deleteEvent: StripeCustomerSubscriptionDeletedWebHookEvent,\n  options: {\n    meteringBucketId: string;\n  }\n): Promise<HttpProblems> {\n  const stripeSubscriptionId = deleteEvent.data.object.id;\n\n  if (!stripeSubscriptionId) {\n    context.log.warn(\n      `Invalid Stripe webhook event. Expected event '${deleteEvent.id}' to have '.data.object.id' be the subscription ID.`\n    );\n    return HttpProblems.badRequest(request, context, {\n      title: UNABLE_PROCESS_WEBHOOK_EVENT,\n      detail:\n        \"Invalid Stripe webhook event. Expected '.data.object.id' to be the subscription ID.\",\n    });\n  }\n\n  const stripeCustomerId = deleteEvent.data.object.customer;\n  if (!stripeCustomerId) {\n    context.log.warn(\n      `Invalid Stripe webhook event. Expected '.data.object.customer' to be provided by event '${deleteEvent.id}'`\n    );\n    return HttpProblems.badRequest(request, context, {\n      title: UNABLE_PROCESS_WEBHOOK_EVENT,\n      detail:\n        \"Invalid Stripe webhook event. Expected '.data.object.customer' to be provided\",\n    });\n  }\n\n  // @NOTE - we will try to ignore events that are not issued for the Zups deploymentName\n  // but there are scenarios in which this info cannot be found on the Stripe subscription\n  if (\n    deleteEvent.data.object.metadata &&\n    deleteEvent.data.object.metadata.zuplo_created_by_deploymentName &&\n    deleteEvent.data.object.metadata.zuplo_created_by_deploymentName !==\n      Environment.instance.deploymentName\n  ) {\n    context.log.warn(\n      `Subscription event '${deleteEvent.id}' will not be handled since it was not issued for this Zuplo environment. It was intended for '${deleteEvent.data.object.metadata.zuplo_created_by_deploymentName}'.`\n    );\n    return HttpProblems.badRequest(request, context, {\n      title: UNABLE_PROCESS_WEBHOOK_EVENT,\n      detail:\n        \"This 'customer.subscription.deleted' event is not meant to be handled by this environment's Stripe monetization plugin. \" +\n        `It was intended for '${deleteEvent.data.object.metadata.zuplo_created_by_deploymentName}'.` +\n        \"This can happen because of a misconfiguration of Stripe or your Zuplo API.\" +\n        MONETIZATION_DOC_ERROR_DETAIL,\n    });\n  }\n\n  try {\n    const currentSubscription = await getSubscription({\n      context,\n      stripeSubscriptionId,\n      stripeCustomerId,\n      meteringBucketId: options.meteringBucketId,\n    });\n\n    // Update subscription to canceled status\n    await updateSubscription({\n      context,\n      meteringSubscriptionId: currentSubscription.id,\n      meteringBucketId: options.meteringBucketId,\n      requestBody: {\n        status: \"canceled\",\n        planExternalIds: currentSubscription.planExternalIds,\n      },\n    });\n  } catch (err) {\n    return HttpProblems.internalServerError(request, context, {\n      title: UNABLE_PROCESS_WEBHOOK_EVENT,\n      detail:\n        \"The event 'customer.subscription.deleted' could not be processed. \" +\n        `${err.message} ` +\n        \"This can happen because of a misconfiguration of Stripe or your Zuplo API. \" +\n        MONETIZATION_DOC_ERROR_DETAIL,\n    });\n  }\n\n  return HttpProblems.ok(request, context, {\n    title: SUCCESS_PROCESSING_WEBHOOK_EVENT,\n  });\n}\n", "import { ZuploContext } from \"../../context\";\nimport { MeteringRegions } from \"../../metering-interfaces\";\nimport { HttpProblems } from \"../../problem-responses/http-problems\";\nimport { ZuploRequest } from \"../../request\";\nimport { Environment } from \"../../utils/environment\";\nimport StripeApi from \"../../utils/stripe/api\";\nimport { StripeCustomerSubscriptionUpdatedWebHookEvent } from \"../../utils/stripe/interfaces\";\nimport {\n  getSubscription,\n  updateSubscription,\n} from \"./metering-service-operations\";\nimport {\n  MONETIZATION_DOC_ERROR_DETAIL,\n  SUCCESS_PROCESSING_WEBHOOK_EVENT,\n  UNABLE_PROCESS_WEBHOOK_EVENT,\n  stripeStatusToMeteringStatus,\n  unixTimestampToISOString,\n} from \"./utils\";\n\n// Docs: https://stripe.com/docs/billing/subscriptions/webhooks#events\nexport default async function onCustomerSubscriptionUpdated(\n  request: ZuploRequest,\n  context: ZuploContext,\n  subscriptionEvent: StripeCustomerSubscriptionUpdatedWebHookEvent,\n  options: {\n    meteringBucketId: string;\n    apiKeyBucketName: string;\n    meteringBucketRegion: MeteringRegions;\n    stripeSecretKey: string;\n  }\n): Promise<HttpProblems> {\n  const stripeSubscriptionId = subscriptionEvent.data.object.id;\n\n  if (!stripeSubscriptionId) {\n    context.log.warn(\n      `Invalid Stripe webhook event. Expected event '${subscriptionEvent.id}' to include '.data.object.id' as the subscription ID.`\n    );\n    return HttpProblems.badRequest(request, context, {\n      title: UNABLE_PROCESS_WEBHOOK_EVENT,\n      detail:\n        \"Invalid Stripe webhook event. Expected '.data.object.id' to be the subscription ID.\",\n    });\n  }\n\n  const stripeCustomerId = subscriptionEvent.data.object.customer;\n  if (!stripeCustomerId) {\n    context.log.warn(\n      `Invalid Stripe webhook event. Expected '.data.object.customer' to be provided by event '${subscriptionEvent.id}'`\n    );\n    return HttpProblems.badRequest(request, context, {\n      title: UNABLE_PROCESS_WEBHOOK_EVENT,\n      detail:\n        \"Invalid Stripe webhook event. Expected '.data.object.customer' to be provided\",\n    });\n  }\n\n  // @NOTE - we will try to ignore events that are not issued for the Zups deploymentName\n  // but there are scenarios in which this info cannot be found on the Stripe subscription\n  if (\n    subscriptionEvent.data.object.metadata &&\n    subscriptionEvent.data.object.metadata.zuplo_created_by_deploymentName &&\n    subscriptionEvent.data.object.metadata.zuplo_created_by_deploymentName !==\n      Environment.instance.deploymentName\n  ) {\n    context.log.warn(\n      `Subscription event '${subscriptionEvent.id}' will not be handled since it was not issued for this Zuplo environment. It was intended for '${subscriptionEvent.data.object.metadata.zuplo_created_by_deploymentName}'.`\n    );\n    return HttpProblems.badRequest(request, context, {\n      title: UNABLE_PROCESS_WEBHOOK_EVENT,\n      detail:\n        \"This 'customer.subscription.updated' event is not meant to be handled by this environment's Stripe monetization plugin. \" +\n        `It was intended for '${subscriptionEvent.data.object.metadata.zuplo_created_by_deploymentName}'.` +\n        \"This can happen because of a misconfiguration of Stripe or your Zuplo API.\" +\n        MONETIZATION_DOC_ERROR_DETAIL,\n    });\n  }\n\n  if (subscriptionEvent.data.previous_attributes) {\n    const previousAttributes = subscriptionEvent.data.previous_attributes;\n\n    // Support subscription status change\n    if (\n      previousAttributes.status &&\n      previousAttributes.status !== subscriptionEvent.data.object.status\n    ) {\n      try {\n        context.log.debug(\n          `Processing subscription status change from Stripe event '${subscriptionEvent.id}'.`\n        );\n        const currentSubscription = await getSubscription({\n          context,\n          stripeSubscriptionId,\n          stripeCustomerId,\n          meteringBucketId: options.meteringBucketId,\n        });\n\n        const newStatus = stripeStatusToMeteringStatus(\n          subscriptionEvent.data.object.status\n        );\n\n        await updateSubscription({\n          context,\n          meteringSubscriptionId: currentSubscription.id,\n          meteringBucketId: options.meteringBucketId,\n          requestBody: {\n            status: newStatus,\n            planExternalIds: currentSubscription.planExternalIds,\n          },\n        });\n      } catch (err) {\n        return HttpProblems.internalServerError(request, context, {\n          title: UNABLE_PROCESS_WEBHOOK_EVENT,\n          detail:\n            \"The event 'customer.subscription.updated' could not be processed. \" +\n            `${err.message} ` +\n            \"This can happen because of a misconfiguration of Stripe or your Zuplo API. \" +\n            \"However, it also could be a temporary condition that happens when a subscription is created due to events being sent out of order. \" +\n            MONETIZATION_DOC_ERROR_DETAIL,\n        });\n      }\n\n      return HttpProblems.ok(request, context, {\n        title: SUCCESS_PROCESSING_WEBHOOK_EVENT,\n      });\n    }\n\n    // Support subscription plan change\n    if (\n      previousAttributes.plan &&\n      previousAttributes.plan.product !==\n        subscriptionEvent.data.object.plan.product\n    ) {\n      try {\n        context.log.debug(\n          `Processing subscription plan change from Stripe event '${subscriptionEvent.id}'.`\n        );\n        const currentSubscription = await getSubscription({\n          context,\n          stripeSubscriptionId,\n          stripeCustomerId,\n          meteringBucketId: options.meteringBucketId,\n        });\n\n        // Price id, starts with \"price_\"\n        const newStripeProductId = subscriptionEvent.data.object.plan.product;\n\n        // Get invoice data so we can calculate prorate on the new plan\n        const upcomingInvoice = await StripeApi.getUpcomingInvoice({\n          customerId: stripeCustomerId,\n          logger: context.log,\n          stripeSecretKey: options.stripeSecretKey,\n        });\n\n        const newPlanProratedData = upcomingInvoice.lines.data.filter(\n          (line) => {\n            return line.proration && line.price.product === newStripeProductId;\n          }\n        );\n\n        let prorateResult = 0;\n        if (newPlanProratedData.length === 0) {\n          context.log.warn(\n            `The plan change does not include proration details. Subscription event '${subscriptionEvent.id}'`\n          );\n        } else {\n          // @NOTE - we assume there is only 1 product per plan aka quantity\n          prorateResult =\n            parseFloat(newPlanProratedData[0].unit_amount_excluding_tax) /\n            newPlanProratedData[0].price.unit_amount;\n        }\n\n        await updateSubscription({\n          context,\n          meteringSubscriptionId: currentSubscription.id,\n          meteringBucketId: options.meteringBucketId,\n          requestBody: {\n            status: currentSubscription.status,\n            planExternalIds: [newStripeProductId],\n            prorate: prorateResult,\n          },\n        });\n      } catch (err) {\n        return HttpProblems.internalServerError(request, context, {\n          title: UNABLE_PROCESS_WEBHOOK_EVENT,\n          detail:\n            \"The event 'customer.subscription.updated' could not be processed. \" +\n            `${err.message} ` +\n            \"This can happen because of a misconfiguration of Stripe or your Zuplo API. \" +\n            \"However, it also could be a temporary condition that happens when a subscription is created due to events being sent out of order. \" +\n            MONETIZATION_DOC_ERROR_DETAIL,\n        });\n      }\n\n      return HttpProblems.ok(request, context, {\n        title: SUCCESS_PROCESSING_WEBHOOK_EVENT,\n      });\n    }\n\n    // Support storing future cancelation date information\n    // @NOTE - Stripe sends two update events on cancelation;\n    // one with cancellation_details and another with the rest of the info\n    if (\n      ((previousAttributes.cancel_at ||\n        previousAttributes.cancel_at === null) &&\n        previousAttributes.cancel_at !==\n          subscriptionEvent.data.object.cancel_at &&\n        previousAttributes.cancel_at_period_end &&\n        previousAttributes.cancel_at_period_end !==\n          subscriptionEvent.data.object.cancel_at_period_end &&\n        (previousAttributes.canceled_at ||\n          previousAttributes.canceled_at === null) &&\n        previousAttributes.canceled_at !==\n          subscriptionEvent.data.object.canceled_at) ||\n      (previousAttributes.cancellation_details &&\n        (previousAttributes.cancellation_details.comment ||\n          previousAttributes.cancellation_details.comment === null ||\n          previousAttributes.cancellation_details.feedback ||\n          previousAttributes.cancellation_details.feedback === null ||\n          previousAttributes.cancellation_details.reason ||\n          previousAttributes.cancellation_details.reason === null))\n    ) {\n      try {\n        context.log.debug(\n          `Processing subscription cancellation details from Stripe event '${subscriptionEvent.id}'.`\n        );\n        const currentSubscription = await getSubscription({\n          context,\n          stripeSubscriptionId,\n          stripeCustomerId,\n          meteringBucketId: options.meteringBucketId,\n        });\n\n        const cancelationDetails = {\n          cancellation: {\n            cancel_at: subscriptionEvent.data.object.cancel_at\n              ? unixTimestampToISOString(\n                  subscriptionEvent.data.object.cancel_at\n                )\n              : null,\n            cancel_at_period_end:\n              subscriptionEvent.data.object.cancel_at_period_end,\n            canceled_at: subscriptionEvent.data.object.canceled_at\n              ? unixTimestampToISOString(\n                  subscriptionEvent.data.object.canceled_at\n                )\n              : null,\n            cancellation_details:\n              subscriptionEvent.data.object.cancellation_details,\n          },\n        };\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        let subscriptionMetadataUpdate: Record<string, any>;\n\n        if (currentSubscription.metadata) {\n          subscriptionMetadataUpdate = {\n            ...currentSubscription.metadata,\n            ...cancelationDetails,\n          };\n        } else {\n          subscriptionMetadataUpdate = cancelationDetails;\n        }\n\n        await updateSubscription({\n          context,\n          meteringSubscriptionId: currentSubscription.id,\n          meteringBucketId: options.meteringBucketId,\n          requestBody: {\n            status: currentSubscription.status,\n            planExternalIds: currentSubscription.planExternalIds,\n            metadata: subscriptionMetadataUpdate,\n          },\n        });\n      } catch (err) {\n        return HttpProblems.internalServerError(request, context, {\n          title: UNABLE_PROCESS_WEBHOOK_EVENT,\n          detail:\n            \"The event 'customer.subscription.updated' could not be processed. \" +\n            `${err.message} ` +\n            \"This can happen because of a misconfiguration of Stripe or your Zuplo API. \" +\n            \"However, it also could be a temporary condition that happens when a subscription is created due to events being sent out of order. \" +\n            MONETIZATION_DOC_ERROR_DETAIL,\n        });\n      }\n\n      return HttpProblems.ok(request, context, {\n        title: SUCCESS_PROCESSING_WEBHOOK_EVENT,\n      });\n    }\n  }\n\n  context.log.warn(\n    `This update event '${subscriptionEvent.id}' is not supported by Stripe monetization plugin webhook.`\n  );\n  return HttpProblems.badRequest(request, context, {\n    title: UNABLE_PROCESS_WEBHOOK_EVENT,\n    detail:\n      \"This 'customer.subscription.updated' event could not be processed. \" +\n      \"The Stripe monetization plugin only supports update events for subscription plan changes or subscription status changes.\" +\n      MONETIZATION_DOC_ERROR_DETAIL,\n  });\n}\n", "import { ZuploContext } from \"../context\";\nimport { environment } from \"../environment\";\nimport { ConfigurationError, SystemError } from \"../errors\";\nimport { Gateway } from \"../gateway\";\nimport { MeteringRegions } from \"../metering-interfaces\";\nimport { Pipeline } from \"../pipeline\";\nimport {\n  StripeWebhookVerificationInboundPolicy,\n  StripeWebhookVerificationInboundPolicyOptions,\n} from \"../policies/stripe-webhook-verification-inbound/policy\";\nimport { HttpProblems } from \"../problem-responses/http-problems\";\nimport { metricsProcessor } from \"../processors/metrics-processor\";\nimport { createInternalPolicyProcessor } from \"../processors/policy-processor\";\nimport { ZuploRequest } from \"../request\";\nimport { SystemRouteName } from \"../router/interfaces.custom\";\nimport { RouteHandler, Router } from \"../router/router\";\nimport { SystemRouteConfiguration } from \"../router/system-route-configuration\";\nimport { Environment } from \"../utils/environment\";\nimport {\n  StripeCustomerSubscriptionCreatedWebHookEvent,\n  StripeCustomerSubscriptionDeletedWebHookEvent,\n  StripeCustomerSubscriptionUpdatedWebHookEvent,\n} from \"../utils/stripe/interfaces\";\nimport { isStripeWebhookEvent } from \"../utils/stripe/types\";\nimport { optionValidator } from \"../utils/validator\";\nimport { MeteringPlugin } from \"./plugins\";\nimport onCustomerSubscriptionCreated from \"./stripe-event-handlers/customer-subscription-created-handler\";\nimport onCustomerSubscriptionDeleted from \"./stripe-event-handlers/customer-subscription-deleted-handler\";\nimport onCustomerSubscriptionUpdated from \"./stripe-event-handlers/customer-subscription-updated-handler\";\nimport {\n  MONETIZATION_DOC_ERROR_DETAIL,\n  UNABLE_PROCESS_WEBHOOK_EVENT,\n} from \"./stripe-event-handlers/utils\";\n\n/**\n * @beta\n */\nexport interface StripeMonetizationPluginOptions {\n  /**\n   * Stripe Webhook settings\n   */\n  webhooks: StripeWebhookVerificationInboundPolicyOptions & {\n    /**\n     * The URL path where the webhook is registered.\n     * Defaults to `/_zuplo/stripe-webhook`\n     */\n    routePath?: string;\n  };\n\n  /**\n   * The ID of the Zuplo metering bucket.\n   */\n  meteringBucketId?: string;\n\n  /**\n   * The primary region where data is stored. Among other things, the choice of location impacts latency.\n   * Defaults to `us-central1`\n   */\n  primaryDataRegion?: string;\n\n  apiKeyBucketName?: string;\n\n  /**\n   * The Stripe account's secret key\n   */\n  stripeSecretKey: string;\n\n  /**\n   * @internal\n   * For unit testing only. Forces webhook to return \"success\" after\n   * verification and disables API calls\n   */\n  __testMode?: boolean;\n}\n\n/**\n * Adds stripe monetization routes and configuration\n * @beta\n */\nexport class StripeMonetizationPlugin extends MeteringPlugin {\n  constructor(private options: StripeMonetizationPluginOptions) {\n    super();\n  }\n\n  /**\n   * @internal\n   * @param router - The router to register the routes with\n   * @param gateway - The gateway to register the routes with\n   */\n  override registerRoutes(router: Router, gateway: Gateway): void {\n    const stripeWebhookHandler: RouteHandler = async (\n      request: ZuploRequest,\n      context: ZuploContext\n    ) => {\n      if (this.options.__testMode === true) {\n        context.log.warn(`Received Stripe webhook event of in test mode.`);\n        return \"success\";\n      }\n\n      let { meteringBucketId, apiKeyBucketName } = this.options;\n\n      if (!meteringBucketId) {\n        if (environment.ZUPLO_METERING_SERVICE_BUCKET_ID) {\n          meteringBucketId = environment.ZUPLO_METERING_SERVICE_BUCKET_ID;\n        } else {\n          throw new ConfigurationError(\n            `StripeMonetizationPlugin - No 'meteringBucketId' property provided`\n          );\n        }\n      }\n\n      if (!apiKeyBucketName) {\n        if (environment.ZUPLO_API_KEY_SERVICE_BUCKET_NAME) {\n          apiKeyBucketName = environment.ZUPLO_API_KEY_SERVICE_BUCKET_NAME;\n        } else {\n          throw new ConfigurationError(\n            `StripeMonetizationPlugin - No 'apiKeyBucketName' property provided`\n          );\n        }\n      }\n\n      if (!Environment.instance.build.ACCOUNT_NAME) {\n        throw new SystemError(\n          \"Build environment is not configured correctly. Expected 'ACCOUNT_NAME' to be set.\"\n        );\n      }\n\n      const primaryDataRegion = this.options.primaryDataRegion ?? \"us-central1\";\n\n      if (!isMetricsRegion(primaryDataRegion)) {\n        throw new ConfigurationError(\n          `StripeMonetizationPlugin - The value '${primaryDataRegion}' on the property 'primaryDataRegion' is invalid.`\n        );\n      }\n\n      const event: unknown = await request.json();\n      if (!isStripeWebhookEvent(event)) {\n        return HttpProblems.badRequest(request, context, {\n          title: UNABLE_PROCESS_WEBHOOK_EVENT,\n          detail:\n            \"The event payload received was not in the expected format. \" +\n            \"This can happen because of a misconfiguration of Stripe or your Zuplo API. \" +\n            MONETIZATION_DOC_ERROR_DETAIL,\n        });\n      }\n\n      context.log.info(\n        `Received Stripe webhook event of type '${event.type}' with ID '${event.id}'.`\n      );\n\n      switch (event.type) {\n        case \"customer.subscription.created\":\n          return await onCustomerSubscriptionCreated(\n            request,\n            context,\n            event as StripeCustomerSubscriptionCreatedWebHookEvent,\n            {\n              meteringBucketId,\n              apiKeyBucketName,\n              meteringBucketRegion: primaryDataRegion,\n              stripeSecretKey: this.options.stripeSecretKey,\n            }\n          );\n        case \"customer.subscription.updated\":\n          return await onCustomerSubscriptionUpdated(\n            request,\n            context,\n            event as StripeCustomerSubscriptionUpdatedWebHookEvent,\n            {\n              meteringBucketId,\n              apiKeyBucketName,\n              meteringBucketRegion: primaryDataRegion,\n              stripeSecretKey: this.options.stripeSecretKey,\n            }\n          );\n        case \"customer.subscription.deleted\":\n          return await onCustomerSubscriptionDeleted(\n            request,\n            context,\n            event as StripeCustomerSubscriptionDeletedWebHookEvent,\n            {\n              meteringBucketId,\n            }\n          );\n        default:\n          return HttpProblems.badRequest(request, context, {\n            title: UNABLE_PROCESS_WEBHOOK_EVENT,\n            detail:\n              `Event '${event.type}' could not be processed because it is not supported by Stripe monetization plugin webhook. ` +\n              \"This can happen because of a misconfiguration of Stripe or your Zuplo API.\" +\n              MONETIZATION_DOC_ERROR_DETAIL,\n          });\n      }\n    };\n\n    const policyProcessor = createInternalPolicyProcessor({\n      inboundPolicies: [\n        new StripeWebhookVerificationInboundPolicy(\n          {\n            signingSecret: this.options.webhooks.signingSecret,\n            tolerance: this.options.webhooks.tolerance,\n          },\n          \"stripe-webhook-verification\"\n        ),\n      ],\n    });\n\n    optionValidator(this.options.webhooks, \"StripeMonetizationPlugin\", \"plugin\")\n      .required(\"signingSecret\", \"string\")\n      .optional(\"tolerance\", \"number\");\n\n    const zPipe = new Pipeline({\n      processors: [metricsProcessor, policyProcessor],\n      handler: stripeWebhookHandler,\n      gateway,\n    });\n    const stripeWebhookRouteConfig = new SystemRouteConfiguration({\n      label: \"PLUGIN_STRIPE_WEBHOOK_ROUTE\",\n      methods: [\"POST\"],\n      path: this.options.webhooks.routePath ?? `/__plugins/stripe/webhooks`,\n      systemRouteName: SystemRouteName.StripePlugin,\n    });\n\n    router.addRoute(stripeWebhookRouteConfig, zPipe.execute);\n  }\n}\n\nfunction isMetricsRegion(val: unknown): val is MeteringRegions {\n  return (\n    val !== null &&\n    typeof val === \"string\" &&\n    [\"us-central1\", \"us-east1\", \"europe-west4\"].includes(val)\n  );\n}\n", "// Example payload\n// {\n//      \"customerId\": \"customer-123\",\n//      \"meterApiName\": \"ComputeHours\",\n//      \"meterValue\": 5,\n//      \"meterTimeInMillis\": 1619445706909,\n//      \"dimensions\": {\n//         \"region\": \"us-west-2\",\n//         \"az\": \"az1\"\n//      }\n// }\n\nimport { ZuploContext } from \"../../context\";\nimport { ConfigurationError, RuntimeError } from \"../../errors\";\nimport internals from \"../../internals\";\nimport { ZuploRequest } from \"../../request\";\nimport { BatchDispatch } from \"../../utils/batch-dispatch\";\nimport {\n  getValueFromRequestUser,\n  statusCodesStringToNumberArray,\n} from \"../../utils/options-parsing\";\nimport { AmberfloMeteringInboundPolicyOptions } from \"./options\";\n\nexport { AmberfloMeteringInboundPolicyOptions };\n\ninterface AmberfloMeteringIngestPayload {\n  customerId: string;\n  meterApiName: string;\n  meterValue: number;\n  meterTimeInMillis: number;\n  dimensions: Record<string, string>;\n}\n\ninterface AmberfloMeteringProperties\n  extends Omit<AmberfloMeteringIngestPayload, \"meterTimeInMillis\"> {\n  customerId: string;\n}\n\nconst map = new WeakMap<ZuploContext, AmberfloMeteringProperties>();\nconst batcherMap: Record<\n  string,\n  BatchDispatch<AmberfloMeteringIngestPayload>\n> = {};\n\nexport class AmberfloMeteringPolicy {\n  static setRequestProperties(\n    context: ZuploContext,\n    properties: AmberfloMeteringProperties\n  ) {\n    map.set(context, properties);\n  }\n}\n\n/**\n * Amberflo is a usage metering and billing service. This policy allows you to send metering calls for each API to their meter ingest endpoint.\n *\n * @remarks\n * Amberflo {@link https://www.amberflo.io|amberflo.com} is a usage metering and\n * billing service. This policy allows you to meter API calls going through Zuplo\n * and send them to your Amberflo account using your Amberflo API key.\n *\n * Add the policy to each route you want to meter. Note you can specify the Meter\n * API Name and Meter Value (meter increment) at the policy level.\n *\n * @title Amberflo Metering / Billing\n * @public\n * @param request - The ZuploRequest\n * @param context - The ZuploContext\n * @param options - The policy options set in policies.json\n * @param policyName - The name of the policy as set in policies.json\n * @returns A Request or a Response\n */\nexport async function AmberfloMeteringInboundPolicy(\n  request: ZuploRequest,\n  context: ZuploContext,\n  options: AmberfloMeteringInboundPolicyOptions,\n  policyName: string\n) {\n  if (!options.statusCodes) {\n    throw new ConfigurationError(\n      `Invalid AmberfloMeterInboundPolicy '${policyName}': options.statusCodes must be an array of HTTP status code numbers`\n    );\n  }\n\n  const statusCodes = statusCodesStringToNumberArray(options.statusCodes);\n\n  context.addResponseSendingFinalHook(async (response) => {\n    if (statusCodes.includes(response.status)) {\n      const local = map.get(context);\n\n      let tmpCustomerId = options.customerId;\n      if (options.customerIdPropertyPath) {\n        if (!request.user) {\n          throw new RuntimeError(\n            `Unable to apply customerIdPropertyPath '${options.customerIdPropertyPath}' as request.user is 'undefined'.`\n          );\n        }\n        tmpCustomerId = getValueFromRequestUser(\n          request.user,\n          options.customerIdPropertyPath,\n          \"customerIdPropertyPath\"\n        );\n      }\n\n      const customerId = local?.customerId ?? tmpCustomerId;\n\n      if (!customerId) {\n        context.log.error(\n          `Error in AmberfloMeterInboundPolicy '${policyName}': customerId cannot be undefined`\n        );\n        return;\n      }\n\n      const meterApiName = local?.meterApiName ?? options.meterApiName;\n      if (!meterApiName) {\n        context.log.error(\n          `Error in AmberfloMeterInboundPolicy '${policyName}': meterApiName cannot be undefined`\n        );\n        return;\n      }\n\n      const meterValue = local?.meterValue ?? options.meterValue;\n      if (!meterValue) {\n        context.log.error(\n          `Error in AmberfloMeterInboundPolicy '${policyName}': meterValue cannot be undefined`\n        );\n        return;\n      }\n\n      const data: AmberfloMeteringIngestPayload = {\n        customerId,\n        meterApiName,\n        meterValue,\n        meterTimeInMillis: Date.now(),\n        dimensions: Object.apply(\n          options.dimensions ?? {},\n          local?.dimensions as never // TypeScript being too fussy here\n        ),\n      };\n\n      // important to only have on batcher per API key\n      let batcher: BatchDispatch<AmberfloMeteringIngestPayload> =\n        batcherMap[options.apiKey];\n\n      if (!batcher) {\n        const apiKey = options.apiKey;\n\n        // for automated testing purposes\n        const zmTestId = request.headers.get(\"zm-test-id\") ?? \"\";\n\n        batcher = new BatchDispatch<AmberfloMeteringIngestPayload>(\n          `amberflo-ingest-meter`,\n          10,\n          async (entries) => {\n            try {\n              const url = options.url ?? \"https://app.amberflo.io/ingest\";\n              const result = await internals.fetch(url, {\n                method: \"POST\",\n                body: JSON.stringify(entries),\n                headers: {\n                  \"content-type\": \"application/json\",\n                  \"x-api-key\": apiKey,\n                  \"zm-test-id\": zmTestId,\n                },\n              });\n              if (!result.ok) {\n                context.log.error(\n                  `Unexpected response in AmberfloMeteringInboundPolicy '${policyName}'. ${\n                    result.status\n                  }: ${await result.text()}`\n                );\n              }\n            } catch (err) {\n              context.log.error(\n                `Error in AmberfloMeteringInboundPolicy '${policyName}': ${err.message}`\n              );\n              throw err;\n            }\n          }\n        );\n\n        batcherMap[apiKey] = batcher;\n      }\n\n      batcher.enqueue(data);\n      context.waitUntil(batcher.waitUntilFlushed());\n    }\n  });\n\n  return request;\n}\n", "export async function sha256(value: string) {\n  const enc = new TextEncoder().encode(value);\n  const digest = await crypto.subtle.digest({ name: \"SHA-256\" }, enc);\n  const hex = [...new Uint8Array(digest)]\n    .map((b) => b.toString(16).padStart(2, \"0\"))\n    .join(\"\");\n  return hex;\n}\n", "import { sha256 } from \"../utils/crypto\";\n\nconst cacheMap = new Map<string, string>();\n\n/**\n * Gets a unique cache name for a policy. Policy names cannot be duplicated\n * in a zup so these are unique in each project. The options values are included\n * in the hash so that when options change the cache is busted - otherwise\n * you might end up with cached results that don't match current options.\n * @param policyName - The name of the policy\n * @param options - The options of the policy, used to compute the cache name hash\n * @returns\n */\nexport async function getPolicyCacheName(policyName: string, options: unknown) {\n  let name: string;\n  const cachedName = cacheMap.get(policyName);\n  if (cachedName !== undefined) {\n    name = cachedName;\n  } else {\n    const hash = await sha256(JSON.stringify({ policyName, options }));\n    name = `zuplo-policy-${hash}`;\n    cacheMap.set(policyName, name);\n  }\n  return name;\n}\n", "import { getPolicyCacheName } from \"../../caches/keys\";\nimport { MemoryZoneReadThroughCache } from \"../../caches/memory-zone-readthrough-cache\";\nimport { ZuploContext } from \"../../context\";\nimport { environment } from \"../../environment\";\nimport { ConfigurationError, RuntimeError } from \"../../errors\";\nimport { HttpProblems } from \"../../index.worker\";\nimport { ZuploRequest } from \"../../request\";\nimport { SystemLogMap } from \"../../system-log-map\";\nimport { Environment } from \"../../utils/environment\";\nimport { fetchRetry } from \"../../utils/retry\";\nimport { ApiKeyInboundPolicyOptions } from \"./options\";\n\nexport { ApiKeyInboundPolicyOptions };\n\nconst KEY_TYPE_ID = \"key-metadata-cache-type\";\n\ninterface KeyMetadata {\n  isValid: boolean;\n  typeId: string;\n  user?: {\n    sub: string;\n    data: unknown;\n  };\n}\n\ninterface ApiKeyValidateResponse {\n  id: string;\n  name: string;\n  metadata: unknown;\n}\n\nfunction getKeyValue(\n  rawAuthHeader: string,\n  options: Required<ApiKeyInboundPolicyOptions>\n) {\n  if (options.authScheme === \"\") {\n    return rawAuthHeader;\n  }\n  // replace teh authScheme\n  return rawAuthHeader.replace(`${options.authScheme} `, \"\");\n}\n\n/**\n * Authenticates requests based on API Keys using Zuplo API Management. You can learn more about the Zuplo API Key Service [here](https://zuplo.com/docs/articles/api-key-api#buckets)\n *\n * @remarks\n * Authenticate requests with Zuplo's fully managed API Key service. This policy is\n * the easiest way to secure your API and can be combined with other policies like\n * Rate limiting, quotas, and more to build a fully featured API to support your\n * partners, developers, or customers.\n *\n * For more information on Zuplo's API Key Management service and options enabling\n * self-serve API Key management see the following resources:\n *\n * - {@link https://zuplo.com/docs/articles/api-key-management|API Key Authentication Overview}\n * - {@link https://zuplo.com/docs/articles/api-key-api|API Key Management API}\n *\n * @title API Key Authentication\n * @public\n * @param request - The ZuploRequest\n * @param context - The ZuploContext\n * @param unparsedOptions - The policy options set in policies.json\n * @param policyName - The name of the policy as set in policies.json\n * @returns A Request or a Response\n */\nexport async function ApiKeyInboundPolicy(\n  request: ZuploRequest,\n  context: ZuploContext,\n  unparsedOptions: ApiKeyInboundPolicyOptions,\n  policyName: string\n) {\n  if (!unparsedOptions.bucketName) {\n    if (environment.ZUPLO_API_KEY_SERVICE_BUCKET_NAME) {\n      unparsedOptions.bucketName =\n        environment.ZUPLO_API_KEY_SERVICE_BUCKET_NAME;\n    } else {\n      throw new ConfigurationError(\n        `ApiKeyInboundPolicy '${policyName}' - no bucketName property provided`\n      );\n    }\n  }\n\n  const options: Required<ApiKeyInboundPolicyOptions> = {\n    authHeader: unparsedOptions.authHeader ?? \"authorization\",\n    authScheme: unparsedOptions.authScheme ?? \"Bearer\",\n    bucketName: unparsedOptions.bucketName,\n    cacheTtlSeconds: unparsedOptions.cacheTtlSeconds ?? 60,\n    allowUnauthenticatedRequests:\n      unparsedOptions.allowUnauthenticatedRequests ?? false,\n    disableAutomaticallyAddingKeyHeaderToOpenApi:\n      unparsedOptions.disableAutomaticallyAddingKeyHeaderToOpenApi ?? false,\n  };\n\n  if (options.cacheTtlSeconds < 60) {\n    throw new ConfigurationError(\n      `ApiKeyInboundPolicy '${policyName}' - minimum cacheTtlSeconds value is 60s, '${options.cacheTtlSeconds}' is invalid`\n    );\n  }\n\n  const unauthorizedResponse = (detail: string) => {\n    if (options.allowUnauthenticatedRequests) {\n      return request;\n    }\n    return HttpProblems.unauthorized(request, context, { detail });\n  };\n\n  const rawAuthHeader = request.headers.get(options.authHeader);\n\n  if (!rawAuthHeader) {\n    return unauthorizedResponse(`No Authorization Header`);\n  }\n\n  if (\n    !rawAuthHeader.toLowerCase().startsWith(options.authScheme.toLowerCase())\n  ) {\n    return unauthorizedResponse(`Invalid Authorization Scheme`);\n  }\n\n  const keyValue = getKeyValue(rawAuthHeader, options);\n\n  if (!keyValue || keyValue === \"\") {\n    return unauthorizedResponse(`No key present`);\n  }\n\n  const hashedKey = await hashValue(keyValue);\n\n  // 1. check the cache for the key\n  const cacheName = await getPolicyCacheName(policyName, options);\n  const cache = new MemoryZoneReadThroughCache<KeyMetadata>(cacheName, context);\n  const cachedMetadata = await cache.get(hashedKey);\n\n  if (cachedMetadata && cachedMetadata.isValid === true) {\n    request.user = cachedMetadata.user;\n    return request;\n  }\n\n  if (cachedMetadata && !cachedMetadata.isValid) {\n    if (cachedMetadata.typeId !== KEY_TYPE_ID) {\n      SystemLogMap.getLogger(context).error(\n        `ApiKeyInboundPolicy '${policyName}' - cached metadata has invalid typeId '${cachedMetadata.typeId}'`,\n        cachedMetadata\n      );\n    }\n\n    return unauthorizedResponse(`Authorization Failed`);\n  }\n\n  const payload = {\n    key: keyValue,\n  };\n\n  const response = await fetchRetry(\n    {\n      retryDelayMs: 5,\n      retries: 2,\n      logger: SystemLogMap.getLogger(context),\n    },\n    `${Environment.instance.apiKeyServiceUrl}/v1/$validate/${options.bucketName}`,\n    {\n      method: \"POST\",\n      headers: {\n        \"content-type\": \"application/json\",\n        \"zp-rid\": context.requestId,\n        \"zp-dn\": Environment.instance.deploymentName ?? \"unknown\",\n        \"User-Agent\": Environment.instance.systemUserAgent,\n      },\n      body: JSON.stringify(payload),\n    }\n  );\n\n  if (response.status === 401) {\n    context.log.info(\n      `ApiKeyInboundPolicy '${policyName}' - 401 response from Key Service`\n    );\n    return unauthorizedResponse(`Authorization Failed`);\n  }\n\n  if (response.status !== 200) {\n    try {\n      const errorBody = await response.text();\n      const errorData = JSON.parse(errorBody);\n      context.log.error(\"Unexpected response from key service\", errorData);\n    } catch (err) {\n      context.log.error(\"Invalid response from key service\");\n    }\n    // We don't cache this response, something went wrong\n    throw new RuntimeError(\n      `ApiKeyInboundPolicy '${policyName}' - unexpected response from Key Service. Status: ${response.status}`\n    );\n  }\n\n  const data = (await response.json()) as ApiKeyValidateResponse;\n\n  const keyMetadata: KeyMetadata = {\n    isValid: true,\n    typeId: KEY_TYPE_ID,\n    user: {\n      sub: data.name,\n      data: data.metadata,\n    },\n  };\n\n  request.user = keyMetadata.user;\n\n  cache.put(hashedKey, keyMetadata, options.cacheTtlSeconds);\n\n  return request;\n}\n\nasync function hashValue(value: string) {\n  const msgUint8 = new TextEncoder().encode(value);\n  const hashBuffer = await crypto.subtle.digest(\"SHA-256\", msgUint8);\n  const hashArray = Array.from(new Uint8Array(hashBuffer));\n  const hashHex = hashArray\n    .map((b) => b.toString(16).padStart(2, \"0\"))\n    .join(\"\");\n  return hashHex;\n}\n", "import { ApiKeyInboundPolicy } from \"../api-key-inbound/policy\";\n\nexport { ApiAuthKeyInboundPolicyOptions } from \"./options\";\n\n/**\n * Authenticates requests based on API Keys using Zuplo API Management. You\n * can learn more about the Zuplo API Key Service\n * [here](https://zuplo.com/docs/articles/api-key-api#buckets)\n *\n * @remarks\n * This policy uses the managed API key storage provided by Zuplo.\n * `allowUnauthenticatedRequests` defaults to false and rejects any request without\n * a valid API key (returning a `401 - Unauthorized` response). You can override\n * (set `\"allowUnauthenticatedRequests\" : true`) this to support multiple\n * authentication methods or support both authenticated and anonymous requests.\n *\n * @deprecated Please use the new {@link https://zuplo.com/docs/policies/api-key-inbound|API Key Authentication} policy\n * instead. This policy will continue to work but will be removed in a future\n * version of Zuplo.\n * @hidden\n * @title API Key Authentication\n * @public\n * @param request - The ZuploRequest\n * @param context - The ZuploContext\n * @param unparsedOptions - The policy options set in policies.json\n * @param policyName - The name of the policy as set in policies.json\n * @returns A Request or a Response\n */\nexport const ApiAuthKeyInboundPolicy = ApiKeyInboundPolicy;\n", "import type {\n  FlattenedJWSInput,\n  JSONWebKeySet,\n  JWSHeaderParameters,\n  KeyLike,\n  RemoteJWKSetOptions,\n} from \"jose\";\nimport { createLocalJWKSet } from \"jose\";\nimport { MemoryZoneReadThroughCache } from \"../../caches/memory-zone-readthrough-cache\";\nimport { RuntimeError } from \"../../errors\";\nimport internals from \"../../internals\";\nimport { Environment } from \"../../utils/environment\";\n\ntype AcceptedRequestOptions = Pick<RequestInit, \"headers\">;\n\nclass RemoteJWKSet<KeyLikeType extends KeyLike = KeyLike> {\n  private url: URL;\n\n  private timeoutDuration: number;\n\n  private cooldownDuration: number;\n\n  private cacheMaxAge: number;\n\n  private jwksTimestamp?: number;\n\n  private pendingFetch?: Promise<unknown>;\n\n  private options: Pick<RemoteJWKSetOptions, \"agent\" | \"headers\">;\n\n  private local!: ReturnType<typeof createLocalJWKSet<KeyLikeType>>;\n\n  constructor(\n    url: unknown,\n    private cache: MemoryZoneReadThroughCache<JSONWebKeySet>,\n    options?: RemoteJWKSetOptions\n  ) {\n    if (!(url instanceof URL)) {\n      throw new TypeError(\"url must be an instance of URL\");\n    }\n    this.url = new URL(url.href);\n    this.options = { agent: options?.agent, headers: options?.headers };\n    this.timeoutDuration =\n      typeof options?.timeoutDuration === \"number\"\n        ? options?.timeoutDuration\n        : 5000;\n    this.cooldownDuration =\n      typeof options?.cooldownDuration === \"number\"\n        ? options?.cooldownDuration\n        : 30000;\n    this.cacheMaxAge =\n      typeof options?.cacheMaxAge === \"number\" ? options?.cacheMaxAge : 600000;\n  }\n\n  coolingDown() {\n    return typeof this.jwksTimestamp === \"number\"\n      ? Date.now() < this.jwksTimestamp + this.cooldownDuration\n      : false;\n  }\n\n  fresh() {\n    return typeof this.jwksTimestamp === \"number\"\n      ? Date.now() < this.jwksTimestamp + this.cacheMaxAge\n      : false;\n  }\n\n  async getKey(\n    protectedHeader?: JWSHeaderParameters,\n    token?: FlattenedJWSInput\n  ): Promise<KeyLikeType> {\n    if (!this.local || !this.fresh()) {\n      await this.reload();\n    }\n\n    try {\n      return await this.local(protectedHeader, token);\n    } catch (err) {\n      if (err instanceof JWKSNoMatchingKey) {\n        if (this.coolingDown() === false) {\n          await this.reload();\n          return this.local(protectedHeader, token);\n        }\n      }\n      throw err;\n    }\n  }\n\n  async reload() {\n    // Do not assume a fetch created in another request reliably resolves\n    // see https://github.com/panva/jose/issues/355 and https://github.com/panva/jose/issues/509\n    // eslint-disable-next-line @typescript-eslint/no-misused-promises\n    if (this.pendingFetch) {\n      this.pendingFetch = undefined;\n    }\n\n    const headers = new Headers(this.options.headers);\n    if (!headers.has(\"User-Agent\")) {\n      headers.set(\"User-Agent\", Environment.instance.systemUserAgent);\n      this.options.headers = Object.fromEntries(headers.entries());\n    }\n\n    this.pendingFetch ||= this.fetchJwks(\n      this.url,\n      this.timeoutDuration,\n      this.options\n    )\n      .then((json) => {\n        this.local = createLocalJWKSet(<JSONWebKeySet>(<unknown>json));\n        this.jwksTimestamp = Date.now();\n        this.pendingFetch = undefined;\n      })\n      .catch((err: Error) => {\n        this.pendingFetch = undefined;\n        throw err;\n      });\n\n    await this.pendingFetch;\n  }\n\n  async fetchJwks(url: URL, timeout: number, options: AcceptedRequestOptions) {\n    const cachedJwks = await this.cache.get(this.url.href);\n    if (cachedJwks) {\n      return cachedJwks;\n    }\n\n    let controller!: AbortController;\n    let id!: ReturnType<typeof setTimeout>;\n    let timedOut = false;\n    if (typeof AbortController === \"function\") {\n      controller = new AbortController();\n      id = setTimeout(() => {\n        timedOut = true;\n        controller.abort();\n      }, timeout);\n    }\n\n    const response = await internals\n      .fetch(url.href, {\n        signal: controller ? controller.signal : undefined,\n        redirect: \"manual\",\n        headers: options.headers,\n      })\n      .catch((err) => {\n        if (timedOut) throw new JWKSTimeout(\"JWKS fetch timed out\");\n        throw err;\n      });\n\n    if (id !== undefined) clearTimeout(id);\n\n    if (response.status !== 200) {\n      throw new JWKSError(\n        \"Expected 200 OK from the JSON Web Key Set HTTP response\"\n      );\n    }\n\n    try {\n      const result = await response.json();\n      this.cache.put(this.url.href, result, this.cacheMaxAge);\n\n      return result;\n    } catch {\n      throw new JWKSError(\n        \"Failed to parse the JSON Web Key Set HTTP response as JSON\"\n      );\n    }\n  }\n}\n\n/**\n * Returns a function that resolves a JWS JOSE Header to a public key object downloaded from a\n * remote endpoint returning a JSON Web Key Set, that is, for example, an OAuth 2.0 or OIDC\n * jwks_uri. The JSON Web Key Set is fetched when no key matches the selection process but only as\n * frequently as the `cooldownDuration` option allows to prevent abuse.\n *\n * It uses the \"alg\" (JWS Algorithm) Header Parameter to determine the right JWK \"kty\" (Key Type),\n * then proceeds to match the JWK \"kid\" (Key ID) with one found in the JWS Header Parameters (if\n * there is one) while also respecting the JWK \"use\" (Public Key Use) and JWK \"key_ops\" (Key\n * Operations) Parameters (if they are present on the JWK).\n *\n * Only a single public key must match the selection process. As shown in the example below when\n * multiple keys get matched it is possible to opt-in to iterate over the matched keys and attempt\n * verification in an iterative manner.\n *\n * Note: The function's purpose is to resolve public keys used for verifying signatures and will not\n * work for public encryption keys.\n *\n * @example\n *\n * ```js\n * const JWKS = jose.createRemoteJWKSet(new URL('https://www.googleapis.com/oauth2/v3/certs'))\n *\n * const { payload, protectedHeader } = await jose.jwtVerify(jwt, JWKS, {\n *   issuer: 'urn:example:issuer',\n *   audience: 'urn:example:audience',\n * })\n * console.log(protectedHeader)\n * console.log(payload)\n * ```\n *\n * @example\n *\n * Opting-in to multiple JWKS matches using `createRemoteJWKSet`\n *\n * ```js\n * const options = {\n *   issuer: 'urn:example:issuer',\n *   audience: 'urn:example:audience',\n * }\n * const { payload, protectedHeader } = await jose\n *   .jwtVerify(jwt, JWKS, options)\n *   .catch(async (error) => {\n *     if (error?.code === 'ERR_JWKS_MULTIPLE_MATCHING_KEYS') {\n *       for await (const publicKey of error) {\n *         try {\n *           return await jose.jwtVerify(jwt, publicKey, options)\n *         } catch (innerError) {\n *           if (innerError?.code === 'ERR_JWS_SIGNATURE_VERIFICATION_FAILED') {\n *             continue\n *           }\n *           throw innerError\n *         }\n *       }\n *       throw new jose.errors.JWSSignatureVerificationFailed()\n *     }\n *\n *     throw error\n *   })\n * console.log(protectedHeader)\n * console.log(payload)\n * ```\n *\n * @param url - URL to fetch the JSON Web Key Set from.\n * @param options - Options for the remote JSON Web Key Set.\n * @param cache - The MemoryZoneReadThroughCache to use for caching the JSON Web Key Set.\n */\nexport function createRemoteJWKSet<KeyLikeType extends KeyLike = KeyLike>(\n  url: URL,\n  cache: MemoryZoneReadThroughCache<JSONWebKeySet>,\n  options?: RemoteJWKSetOptions\n) {\n  const set = new RemoteJWKSet<KeyLikeType>(url, cache, options);\n  return async (\n    protectedHeader?: JWSHeaderParameters,\n    token?: FlattenedJWSInput\n  ): Promise<KeyLikeType> => set.getKey(protectedHeader, token);\n}\n\nclass JWKSError extends RuntimeError {}\n\nclass JWKSNoMatchingKey extends JWKSError {}\n\nclass JWKSTimeout extends JWKSError {}\n", "import {\n  createRemoteJWKSet,\n  JWTPayload,\n  jwtVerify,\n  JWTVerifyGetKey,\n  KeyLike,\n} from \"jose\";\nimport { JSONWebKeySet } from \"jose/dist/types/types\";\nimport { getPolicyCacheName } from \"../../caches/keys\";\nimport { MemoryZoneReadThroughCache } from \"../../caches/memory-zone-readthrough-cache\";\nimport { ZuploContext } from \"../../context\";\nimport { ConfigurationError } from \"../../errors\";\nimport { InboundPolicyHandler } from \"../../policies\";\nimport { HttpProblems } from \"../../problem-responses/http-problems\";\nimport { createRemoteJWKSet as experimentalCreateRemoteJWKSet } from \"./jwks\";\nimport { OpenIdJwtInboundPolicyOptions } from \"./options\";\n\nexport { OpenIdJwtInboundPolicyOptions };\n\ninterface OpenIdJwtInboundPolicyInternalOptions\n  extends Omit<OpenIdJwtInboundPolicyOptions, \"secret\"> {\n  secret?: string | KeyLike;\n}\n\n// used to cache JWK Set for each policy by policy-name\nconst JwksDictionary: Record<string, JWTVerifyGetKey> = {};\n\ntype JWTVerifier = (\n  token: string,\n  option: OpenIdJwtInboundPolicyInternalOptions\n) => Promise<JWTPayload>;\n\nconst createJwkVerifier =\n  (policyName: string, context: ZuploContext): JWTVerifier =>\n  async (jwt, options) => {\n    if (!options.jwkUrl || typeof options.jwkUrl !== \"string\") {\n      throw new ConfigurationError(`Invalid State - jwkUrl not set`);\n    }\n\n    if (!JwksDictionary[options.jwkUrl]) {\n      let useExperimentalInMemoryCache = false;\n      if (\n        \"useExperimentalInMemoryCache\" in options &&\n        typeof options.useExperimentalInMemoryCache === \"boolean\"\n      ) {\n        useExperimentalInMemoryCache = options.useExperimentalInMemoryCache;\n      }\n      if (useExperimentalInMemoryCache) {\n        const cacheName = await getPolicyCacheName(policyName, options);\n        const cache = new MemoryZoneReadThroughCache<JSONWebKeySet>(\n          cacheName,\n          context\n        );\n        JwksDictionary[options.jwkUrl] = experimentalCreateRemoteJWKSet(\n          new URL(options.jwkUrl),\n          cache,\n          options.headers ? { headers: options.headers } : undefined\n        );\n      } else {\n        JwksDictionary[options.jwkUrl] = createRemoteJWKSet(\n          new URL(options.jwkUrl),\n          options.headers ? { headers: options.headers } : undefined\n        );\n      }\n    }\n\n    const { payload } = await jwtVerify(jwt, JwksDictionary[options.jwkUrl], {\n      issuer: options.issuer,\n      audience: options.audience,\n    });\n\n    return payload;\n  };\n\nconst secretVerifier: JWTVerifier = async (jwt, options) => {\n  let key: KeyLike | Uint8Array;\n  if (options.secret === undefined) {\n    throw new Error(\"secretVerifier requires secret to be defined\");\n  } else if (typeof options.secret === \"string\") {\n    const encoder = new TextEncoder();\n    const encoded = encoder.encode(options.secret);\n    key = new Uint8Array(encoded);\n  } else {\n    key = options.secret;\n  }\n  const { payload } = await jwtVerify(jwt, key, {\n    issuer: options.issuer,\n    audience: options.audience,\n  });\n\n  return payload;\n};\n\n/**\n * The Open ID JWT Authentication policy allows you to authenticate incoming requests using an Open ID compliant bearer token.\n *\n * @remarks\n * The Open ID JWT Authentication policy allows you to authenticate incoming\n * requests using an Open ID-compliant bearer token. It works with common\n * authentication services like Auth0 (sample here) but should also work with any\n * valid Open ID JWT token.\n *\n * When configured, you can have Zuplo check incoming requests for a JWT token and\n * automatically populate the `ZuploRequest` 's `user` property with a user object.\n * This `user` object will have a `sub` property - taking the `sub` id from the JWT\n * token. It will also have a `data` property populated by other data returned in\n * the JWT token (including any claims).\n *\n * See {@link https://zuplo.com/docs/articles/oauth-authentication|this document} for more information\n * about OAuth authorization in Zuplo.\n *\n * @title JWT Auth\n * @public\n * @param request - The ZuploRequest\n * @param context - The ZuploContext\n * @param options - The policy options set in policies.json\n * @param policyName - The name of the policy as set in policies.json\n * @returns A Request or a Response\n */\nexport const OpenIdJwtInboundPolicy: InboundPolicyHandler<\n  OpenIdJwtInboundPolicyInternalOptions\n> = async (request, context, options, policyName) => {\n  const authHeader = request.headers.get(\"Authorization\");\n  const bearerPrefix = \"bearer \";\n\n  // Helper to create similar responses\n  const unauthorizedResponse = (detail: string) => {\n    return HttpProblems.unauthorized(request, context, { detail });\n  };\n\n  if (!options.jwkUrl && !options.secret) {\n    throw new ConfigurationError(\n      `OpenIdJwtInboundPolicy policy '${policyName}': One of 'jwkUrl' or 'secret' options are required.`\n    );\n  }\n\n  if (options.jwkUrl && options.secret) {\n    throw new ConfigurationError(\n      `OpenIdJwtInboundPolicy policy '${policyName}': Only one of 'jwkUrl' and 'secret' options should be provided.`\n    );\n  }\n\n  const verifier: JWTVerifier = options.jwkUrl\n    ? createJwkVerifier(policyName, context)\n    : secretVerifier;\n\n  const getJwtOrRejectedResponse = async () => {\n    if (!authHeader) {\n      return unauthorizedResponse(`No authorization header`);\n    }\n\n    if (authHeader.toLowerCase().indexOf(bearerPrefix) !== 0) {\n      return unauthorizedResponse(\n        `Invalid bearer token format for authorization header`\n      );\n    }\n\n    const jwt = authHeader.substring(bearerPrefix.length);\n    if (!jwt || jwt.length === 0) {\n      return unauthorizedResponse(`No bearer token on authorization header`);\n    }\n\n    try {\n      // Must await here so the error is caught correctly\n      return await verifier(jwt, options);\n    } catch (err) {\n      const url = new URL(request.url);\n      if (\"code\" in err && err.code === \"ERR_JWT_EXPIRED\") {\n        context.log.warn(`Expired token used on url: ${url.pathname} `, err);\n      } else {\n        context.log.warn(\n          `Invalid token on: ${request.method} ${url.pathname}`,\n          err\n        );\n      }\n\n      return unauthorizedResponse(`Invalid token`);\n    }\n  };\n\n  const result = await getJwtOrRejectedResponse();\n\n  if (result instanceof Response) {\n    return options.allowUnauthenticatedRequests === true ? request : result;\n  }\n\n  const subProp = options.subPropertyName ?? \"sub\";\n  const sub = result[subProp] as string;\n\n  if (!sub) {\n    return unauthorizedResponse(\n      `Token is not valid, no '${subProp}' property found.`\n    );\n  }\n\n  request.user = {\n    sub: sub,\n    data: result,\n  };\n\n  return request;\n};\n", "import { InboundPolicyHandler } from \"../../policies\";\nimport { OpenIdJwtInboundPolicy } from \"../open-id-jwt-auth-inbound/policy\";\nimport { Auth0JwtInboundPolicyOptions } from \"./options\";\n\nexport { Auth0JwtInboundPolicyOptions };\n\n/**\n * Authenticate users using Auth0 issued JWT tokens.\n *\n * @remarks\n * Authenticate requests with JWT tokens issued by Auth0. This is a customized\n * version of the {@link https://zuplo.com/docs/policies/open-id-jwt-auth-inbound|OpenId JWT Policy} specifically\n * for Auth0.\n *\n * @title Auth0 JWT Auth\n * @public\n * @param request - The ZuploRequest\n * @param context - The ZuploContext\n * @param options - The policy options set in policies.json\n * @param policyName - The name of the policy as set in policies.json\n * @returns A Request or a Response\n */\nexport const Auth0JwtInboundPolicy: InboundPolicyHandler<\n  Auth0JwtInboundPolicyOptions\n> = async (request, context, options, policyName) =>\n  OpenIdJwtInboundPolicy(\n    request,\n    context,\n    {\n      issuer: `https://${options.auth0Domain}/`,\n      audience: options.audience,\n      jwkUrl: `https://${options.auth0Domain}/.well-known/jwks.json`,\n      allowUnauthenticatedRequests: options.allowUnauthenticatedRequests,\n    },\n    policyName\n  );\n", "import { InboundPolicyHandler } from \"../../policies\";\nimport { HttpProblems } from \"../../problem-responses/http-problems\";\nimport { BasicAuthAccount, BasicAuthInboundPolicyOptions } from \"./options\";\n\nexport { BasicAuthInboundPolicyOptions };\n\n/**\n * Authenticate requests using basic auth (i.e. username and password)\n *\n * @remarks\n * The Basic Authentication policy allows you to authenticate incoming requests\n * using the Basic authentication standard. You can configure multiple accounts\n * with different passwords and a different bucket of user 'data'.\n *\n * The API will expect a Basic Auth header (you can generate samples\n * {@link https://www.debugbear.com/basic-auth-header-generator|here}). Requests with\n * invalid credentials (or no header) will not be authenticated. Authenticated\n * requests will populate the `user` property of the `ZuploRequest` parameter on\n * your RequestHandler.\n *\n * @title Basic Auth\n * @public\n * @param request - The ZuploRequest\n * @param context - The ZuploContext\n * @param options - The policy options set in policies.json\n * @param policyName - The name of the policy as set in policies.json\n * @returns A Request or a Response\n */\nexport const BasicAuthInboundPolicy: InboundPolicyHandler<\n  BasicAuthInboundPolicyOptions\n> = async (request, context, options) => {\n  const authHeader = request.headers.get(\"Authorization\");\n  const basicPrefix = \"basic \";\n\n  const unauthorizedResponse = (detail: string) => {\n    return HttpProblems.unauthorized(request, context, { detail });\n  };\n\n  const getAccountOrRejectedResponse = async (): Promise<\n    BasicAuthAccount | Response\n  > => {\n    if (!authHeader) {\n      return await unauthorizedResponse(`No Authorization header`);\n    }\n\n    if (authHeader.toLowerCase().indexOf(basicPrefix) !== 0) {\n      return await unauthorizedResponse(\n        `Invalid Basic token format for Authorization header`\n      );\n    }\n\n    const encodedToken = authHeader.substring(basicPrefix.length);\n    if (!encodedToken || encodedToken.length === 0) {\n      return await unauthorizedResponse(`No username:password provided`);\n    }\n\n    const decoded = atob(encodedToken).normalize();\n\n    const colonIndex = decoded.indexOf(\":\");\n\n    // The user & password are split by the first colon and MUST NOT contain control characters.\n    // @see https://tools.ietf.org/html/rfc5234#appendix-B.1 (=> \"CTL = %x00-1F / %x7F\")\n    // eslint-disable-next-line no-control-regex\n    if (colonIndex === -1 || /[\\0-\\x1F\\x7F]/.test(decoded)) {\n      return await unauthorizedResponse(\n        `Invalid basic token value - see https://tools.ietf.org/html/rfc5234#appendix-B.1`\n      );\n    }\n\n    const username = decoded.substring(0, colonIndex);\n    const password = decoded.substring(colonIndex + 1);\n\n    const matchingAccount = options.accounts.find(\n      (acct) => acct.username === username && acct.password === password\n    );\n\n    if (!matchingAccount) {\n      return await unauthorizedResponse(\"Invalid username or password\");\n    }\n\n    return matchingAccount;\n  };\n\n  const result = await getAccountOrRejectedResponse();\n\n  if (result instanceof Response) {\n    return options.allowUnauthenticatedRequests ? request : result;\n  }\n\n  const sub = result.username;\n\n  request.user = {\n    sub: sub,\n    data: result.data,\n  };\n\n  return request;\n};\n", "import { getPolicyCacheName } from \"../../caches/keys\";\nimport { ResponseSentEvent, ZuploContext } from \"../../context\";\nimport { ZuploRequest } from \"../../request\";\nimport { CachingInboundPolicyOptions } from \"./options\";\n\nexport { CachingInboundPolicyOptions };\n\n/**\n * Headers that Cloudflare uses to control response cache,\n * these are removed so the cache value user's explicitly define\n * is honored. Otherwise very confusing behavior can happen\n */\nconst CACHE_HEADERS_TO_REMOVE = [\n  \"cdn-cache-control\",\n  \"cloudflare-cdn-cache-control\",\n  \"surrogate-control\",\n  \"cache-tag\",\n  \"expires\",\n];\n\nasync function digestMessage(data: string) {\n  const msgUint8 = new TextEncoder().encode(data); // encode as (utf-8) Uint8Array\n  const hashBuffer = await crypto.subtle.digest(\"SHA-256\", msgUint8); // hash the message\n  const hashArray = Array.from(new Uint8Array(hashBuffer)); // convert buffer to byte array\n  const hashHex = hashArray\n    .map((b) => b.toString(16).padStart(2, \"0\"))\n    .join(\"\"); // convert bytes to hex string\n  return hashHex;\n}\n\nconst createCacheKeyRequest = async (\n  request: Request,\n  options: CachingInboundPolicyOptions\n) => {\n  const headersToInclude = [\n    ...(options.dangerouslyIgnoreAuthorizationHeader === true\n      ? []\n      : [\"authorization\"]),\n    ...(options.headers ?? []), // undefined is not iterable\n  ];\n\n  // \uD83D\uDEA8\uD83D\uDEA8\uD83D\uDEA8 HACK\n  // Deno completely ignores headers and CF Does not respect headers\n  // in a reliable way, so we parse them and put them on the URL which does work on\n  // CF and Deno.\n  const matchingHeaders: { key: string; value: string }[] = [];\n\n  for (const [key, value] of request.headers.entries()) {\n    if (headersToInclude.includes(key)) {\n      matchingHeaders.push({ key: key.toLowerCase(), value });\n    }\n  }\n\n  // We need to ensure the headers are sorted consistently\n  matchingHeaders.sort((a, b) => a.key.localeCompare(b.key));\n  const serialized = await digestMessage(JSON.stringify(matchingHeaders));\n\n  const incomingUrl = new URL(request.url);\n  const newSearchParams = new URLSearchParams(incomingUrl.searchParams);\n  newSearchParams.set(\"_z-hdr-dgst\", serialized);\n  const rewriteMethod =\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    options.cacheHttpMethods?.includes(request.method.toUpperCase() as any) &&\n    request.method.toUpperCase() !== \"GET\";\n  if (rewriteMethod) {\n    newSearchParams.set(\"_z-original-method\", request.method);\n  }\n  const newUrl = `${incomingUrl.origin}${incomingUrl.pathname}?${newSearchParams}`;\n\n  const cacheKeyRequest = new Request(newUrl, {\n    method: rewriteMethod ? \"GET\" : request.method,\n  });\n\n  return cacheKeyRequest;\n};\n\n/**\n * Respond to matched incoming requests with cached content\n *\n * @title Caching\n * @public\n * @param request - The ZuploRequest\n * @param context - The ZuploContext\n * @param options - The policy options set in policies.json\n * @param policyName - The name of the policy as set in policies.json\n * @returns A Request or a Response\n */\nexport async function CachingInboundPolicy(\n  request: ZuploRequest,\n  context: ZuploContext,\n  options: CachingInboundPolicyOptions,\n  policyName: string\n) {\n  const cacheName = await getPolicyCacheName(policyName, options);\n  const cache = await caches.open(cacheName);\n\n  const cacheHttpMethods = options?.cacheHttpMethods?.map((method) =>\n    method.toUpperCase()\n  ) ?? [\"GET\"];\n  const cacheKeyRequest = await createCacheKeyRequest(request, options);\n  const cachedResponse = await cache.match(cacheKeyRequest);\n\n  if (cachedResponse) {\n    return cachedResponse;\n  }\n\n  context.addEventListener(\"responseSent\", (event) => {\n    try {\n      // default to same status codes as CloudFlare\n      // https://developers.cloudflare.com/cache/how-to/configure-cache-status-code/#edge-ttl\n      // we do not vary TTL, customer specifies this\n      const statusCodes = options.statusCodes ?? [\n        200, 206, 301, 302, 303, 404, 410,\n      ];\n\n      const response = (event as ResponseSentEvent).response.clone();\n\n      // if not a supported status code or method - don't store\n      if (\n        !statusCodes.includes(response.status) ||\n        !cacheHttpMethods.includes(request.method.toUpperCase())\n      ) {\n        return;\n      }\n\n      // default TTL to 60s\n      const ttlSeconds = options?.expirationSecondsTtl ?? 60;\n\n      const cacheReadyResponse = new Response(response.body, response);\n\n      CACHE_HEADERS_TO_REMOVE.forEach((key) =>\n        cacheReadyResponse.headers.delete(key)\n      );\n\n      cacheReadyResponse.headers.set(\"cache-control\", `s-maxage=${ttlSeconds}`);\n\n      // run this asynchronously, but ensure it completes before tear down\n      context.waitUntil(cache.put(cacheKeyRequest, cacheReadyResponse));\n    } catch (err) {\n      context.log.error(\n        `Error in caching-inbound-policy '${policyName}': \"${err.message}\"`,\n        err\n      );\n    }\n  });\n\n  return request;\n}\n", "import { ConfigurationError } from \"../../errors\";\nimport { InboundPolicyHandler } from \"../../policies\";\nimport { ZuploRequest } from \"../../request\";\nimport { ChangeMethodInboundPolicyOptions } from \"./options\";\n\nexport { ChangeMethodInboundPolicyOptions };\n\n/**\n * Changes the HTTP method of the incoming request.\n *\n * @title Change Method\n * @public\n * @param request - The ZuploRequest\n * @param context - The ZuploContext\n * @param options - The policy options set in policies.json\n * @param policyName - The name of the policy as set in policies.json\n * @returns A Request or a Response\n */\nexport const ChangeMethodInboundPolicy: InboundPolicyHandler<\n  ChangeMethodInboundPolicyOptions\n> = async (request, context, options, policyName) => {\n  if (!options.method) {\n    throw new ConfigurationError(\n      `ChangeMethodInboundPolicy '${policyName}' options.method must be valid HttpMethod`\n    );\n  }\n\n  const newRequest = new ZuploRequest(request, {\n    method: options.method,\n  });\n  return newRequest;\n};\n", "import { InboundPolicyHandler } from \"../../policies\";\nimport { ZuploRequest } from \"../../request\";\nimport { ClearHeadersInboundPolicyOptions } from \"./options\";\n\nexport { ClearHeadersInboundPolicyOptions };\n\n/**\n * Removes all headers from the incoming request except for those in the exclude list.\n *\n * @title Clear Request Headers\n * @public\n * @param request - The ZuploRequest\n * @param context - The ZuploContext\n * @param options - The policy options set in policies.json\n * @param policyName - The name of the policy as set in policies.json\n * @returns A Request or a Response\n */\nexport const ClearHeadersInboundPolicy: InboundPolicyHandler<\n  ClearHeadersInboundPolicyOptions\n> = async (request, context, options) => {\n  const exclude = [...(options.exclude ?? [])];\n\n  const headers = new Headers();\n\n  exclude.forEach((ex) => {\n    const val = request.headers.get(ex);\n    if (val) {\n      headers.set(ex, val);\n    }\n  });\n\n  const newRequest = new ZuploRequest(request, {\n    headers,\n  });\n\n  return newRequest;\n};\n", "import { OutboundPolicyHandler } from \"../../policies\";\nimport { ClearHeadersOutboundPolicyOptions } from \"./options\";\n\nexport { ClearHeadersOutboundPolicyOptions };\n\n/**\n * Removes all headers from the response except for those in the exclude list.\n *\n * @title Clear Response Headers\n * @public\n * @param request - The ZuploRequest\n * @param context - The ZuploContext\n * @param options - The policy options set in policies.json\n * @param policyName - The name of the policy as set in policies.json\n * @returns A Request or a Response\n */\nexport const ClearHeadersOutboundPolicy: OutboundPolicyHandler<\n  ClearHeadersOutboundPolicyOptions\n> = async (response, request, context, options) => {\n  const exclude = [...(options.exclude ?? [])];\n\n  const headers = new Headers();\n\n  exclude.forEach((key) => {\n    const val = response.headers.get(key);\n    if (val) {\n      headers.set(key, val);\n    }\n  });\n\n  const newResponse = new Response(response.body, {\n    headers,\n    status: response.status,\n    statusText: response.statusText,\n  });\n\n  return newResponse;\n};\n", "import { InboundPolicyHandler } from \"../../policies\";\nimport { OpenIdJwtInboundPolicy } from \"../open-id-jwt-auth-inbound/policy\";\nimport { ClerkJwtInboundPolicyOptions } from \"./options\";\n\nexport { ClerkJwtInboundPolicyOptions };\n\n/**\n * Authenticate users using Clerk issued JWT tokens.\n *\n * @remarks\n * Authenticate requests with JWT tokens issued by Clerk. This is a customized\n * version of the {@link https://zuplo.com/docs/policies/open-id-jwt-auth-inbound|OpenId JWT Policy} specifically\n * for Clerk.\n *\n * @title Clerk JWT Auth\n * @public\n * @param request - The ZuploRequest\n * @param context - The ZuploContext\n * @param options - The policy options set in policies.json\n * @param policyName - The name of the policy as set in policies.json\n * @returns A Request or a Response\n */\nexport const ClerkJwtInboundPolicy: InboundPolicyHandler<\n  ClerkJwtInboundPolicyOptions\n> = async (request, context, options, policyName) => {\n  const issuerUrl = new URL(\n    options.frontendApiUrl.startsWith(\"https://\") ||\n    options.frontendApiUrl.startsWith(\"http://\")\n      ? options.frontendApiUrl\n      : `https://${options.frontendApiUrl}`\n  );\n\n  const jwkUrl = new URL(issuerUrl);\n  jwkUrl.pathname = `/.well-known/jwks.json`;\n\n  return OpenIdJwtInboundPolicy(\n    request,\n    context,\n    {\n      issuer: issuerUrl.href.slice(0, -1),\n      jwkUrl: jwkUrl.toString(),\n      allowUnauthenticatedRequests: options.allowUnauthenticatedRequests,\n    },\n    policyName\n  );\n};\n", "import { ConfigurationError } from \"../../errors\";\nimport { InboundPolicyHandler } from \"../../policies\";\nimport { OpenIdJwtInboundPolicy } from \"../open-id-jwt-auth-inbound/policy\";\nimport { CognitoJwtInboundPolicyOptions } from \"./options\";\n\nexport { CognitoJwtInboundPolicyOptions };\n\n/**\n * Authenticate requests with JWT tokens issued by AWS Cognito.\n *\n * @remarks\n * Authenticate requests with JWT tokens issued by AWS Cognito. This is a\n * customized version of the {@link https://zuplo.com/docs/policies/open-id-jwt-auth-inbound|OpenId JWT Policy}\n * specifically for AWS Cognito.\n *\n * See {@link https://zuplo.com/docs/articles/oauth-authentication|this document} for more information\n * about OAuth authorization in Zuplo.\n *\n * @title AWS Cognito JWT Auth\n * @public\n * @param request - The ZuploRequest\n * @param context - The ZuploContext\n * @param options - The policy options set in policies.json\n * @param policyName - The name of the policy as set in policies.json\n * @returns A Request or a Response\n */\nexport const CognitoJwtInboundPolicy: InboundPolicyHandler<\n  CognitoJwtInboundPolicyOptions\n> = async (request, context, options, policyName) => {\n  if (!options.userPoolId) {\n    throw new ConfigurationError(\n      \"userPoolId must be set in the options for CognitoJwtInboundPolicy\"\n    );\n  }\n  if (!options.region) {\n    throw new ConfigurationError(\n      \"region must be set in the options for CognitoJwtInboundPolicy\"\n    );\n  }\n  return OpenIdJwtInboundPolicy(\n    request,\n    context,\n    {\n      issuer: `https://cognito-idp.${options.region}.amazonaws.com/${options.userPoolId}`,\n      jwkUrl: `https://cognito-idp.${options.region}.amazonaws.com/${options.userPoolId}/.well-known/jwks.json`,\n      allowUnauthenticatedRequests: options.allowUnauthenticatedRequests,\n    },\n    policyName\n  );\n};\n", "import { ConfigurationError } from \"../../errors\";\nimport { Gateway } from \"../../gateway\";\nimport { InboundPolicyHandler } from \"../../policies\";\nimport {\n  getInboundPolicyInstances,\n  toStackedInboundHandler,\n} from \"../../processors/policy-processor\";\nimport { CompositeInboundPolicyOptions } from \"./options\";\n\nexport { CompositeInboundPolicyOptions };\n\n/**\n * Creates a composite, or group policy - composed of other policies. For reuse across routes.\n *\n * @remarks\n * The Composite policy allows you to create groups of other policies, for easy\n * reuse across multiple routes. Other policies are referenced by their `name`.\n *\n * Be careful not to create circular references which can cause your gateway to\n * fail.\n *\n * @title Composite Inbound (Group Policies)\n * @public\n * @param request - The ZuploRequest\n * @param context - The ZuploContext\n * @param options - The policy options set in policies.json\n * @param policyName - The name of the policy as set in policies.json\n * @returns A Request or a Response\n */\nexport const CompositeInboundPolicy: InboundPolicyHandler<\n  CompositeInboundPolicyOptions\n> = async (request, context, options, policyName) => {\n  if (!options.policies || options.policies.length === 0) {\n    throw new ConfigurationError(\n      `CompositeInboundPolicy '${policyName}' must have valid policies defined`\n    );\n  }\n\n  const gateway = Gateway.instance;\n\n  const handlersAndOptions = getInboundPolicyInstances(\n    options.policies,\n    gateway?.routeData.policies\n  );\n\n  // Note - people could create circular dependencies, we should try to detect this\n  // but for now we will let it fly. The simplest check would be to disallow composite policy\n  // usage within composite policies - but that would limit some legitimately useful scenarios.\n\n  const stackedPolicies = toStackedInboundHandler(handlersAndOptions);\n\n  return stackedPolicies(request, context);\n};\n", "import { getPolicyCacheName } from \"../../caches/keys\";\nimport { MemoryZoneReadThroughCache } from \"../../caches/memory-zone-readthrough-cache\";\nimport internals from \"../../internals\";\nimport { InboundPolicyHandler } from \"../../policies\";\nimport { HttpProblems } from \"../../problem-responses/http-problems\";\nimport { CurityPhantomTokenInboundPolicyOptions } from \"./options\";\n\nexport { CurityPhantomTokenInboundPolicyOptions };\n\n/**\n * Authenticate users using the Curity Phantom Token Pattern.\n *\n * @remarks\n * Authenticate requests with Phantom Tokens issued by Curity. The payload of the\n * Phantom JWT token, if successfully authenticated, with be on the\n * `request.user.data` object accessible to the runtime.\n *\n * @title Curity Phantom Token Auth\n * @public\n * @param request - The ZuploRequest\n * @param context - The ZuploContext\n * @param options - The policy options set in policies.json\n * @param policyName - The name of the policy as set in policies.json\n * @returns A Request or a Response\n */\nexport const CurityPhantomTokenInboundPolicy: InboundPolicyHandler<\n  CurityPhantomTokenInboundPolicyOptions\n> = async (request, context, options, policyName) => {\n  const authHeader = request.headers.get(\"Authorization\");\n\n  if (!authHeader) {\n    return HttpProblems.unauthorized(request, context, {\n      detail: \"No authorization header\",\n    });\n  }\n\n  const token = getToken(authHeader);\n\n  if (!token) {\n    return HttpProblems.unauthorized(request, context, {\n      detail: `Failed to parse token from Authorization header`,\n    });\n  }\n\n  const cacheName = await getPolicyCacheName(policyName, options);\n  const cache = new MemoryZoneReadThroughCache(cacheName, context);\n  let jwt = await cache.get(token);\n\n  if (!jwt) {\n    const response = await internals.fetch(options.introspectionUrl, {\n      headers: {\n        Authorization:\n          \"Basic \" + btoa(`${options.clientId}:${options.clientSecret}`),\n        Accept: \"application/jwt\",\n        \"Content-Type\": \"application/x-www-form-urlencoded\",\n      },\n      method: \"POST\",\n      body: \"token=\" + token + \"&token_type_hint=access_token\",\n    });\n\n    const text = await response.text();\n\n    if (response.status === 200) {\n      // If the response is 200, the user is authorized\n      jwt = text;\n      cache.put(token, jwt, options.cacheDurationSeconds ?? 600);\n    } else if (response.status >= 500) {\n      // If the response is 500, an unexpected error has happened calling\n      // introspection, this is something to surface in logs\n      context.log.error(\n        `Error introspecting token - ${response.status}: '${text}'`\n      );\n      return HttpProblems.internalServerError(request, context, {\n        detail: \"Problem encountered authorizing the HTTP request\",\n      });\n    } else {\n      // If any other response was returned, this is an unauthorized response\n      return HttpProblems.unauthorized(request, context);\n    }\n  }\n\n  request.headers.set(\"Authorization\", `Bearer ${jwt}`);\n\n  return request;\n};\n\nfunction getToken(authHeader: string) {\n  if (authHeader.split(\" \")[0] === \"Bearer\") {\n    return authHeader.split(\" \")[1];\n  }\n  return null;\n}\n", "import { InboundPolicyHandler } from \"../../policies\";\nimport { optionValidator } from \"../../utils/validator\";\nimport { OpenIdJwtInboundPolicy } from \"../open-id-jwt-auth-inbound/policy\";\nimport { FirebaseJwtInboundPolicyOptions } from \"./options\";\n\nexport { FirebaseJwtInboundPolicyOptions };\n\n/**\n * Authenticate users using Firebase issued JWT tokens.\n *\n * @remarks\n * Authenticate requests with JWT tokens issued by Firebase. The payload of the JWT\n * token, if successfully authenticated, with be on the `request.user.data` object\n * accessible to the runtime.\n *\n * See {@link https://zuplo.com/docs/articles/oauth-authentication|this document} for more information\n * about OAuth authorization in Zuplo.\n *\n * @title Firebase JWT Auth\n * @public\n * @param request - The ZuploRequest\n * @param context - The ZuploContext\n * @param options - The policy options set in policies.json\n * @param policyName - The name of the policy as set in policies.json\n * @returns A Request or a Response\n */\nexport const FirebaseJwtInboundPolicy: InboundPolicyHandler<\n  FirebaseJwtInboundPolicyOptions\n> = async (request, context, options, policyName) => {\n  optionValidator(options, policyName)\n    .required(\"projectId\", \"string\")\n    .optional(\"allowUnauthenticatedRequests\", \"boolean\");\n\n  return OpenIdJwtInboundPolicy(\n    request,\n    context,\n    {\n      issuer: `https://securetoken.google.com/${options.projectId}`,\n      audience: options.projectId,\n      jwkUrl: `https://www.googleapis.com/service_accounts/v1/jwk/securetoken@system.gserviceaccount.com`,\n      allowUnauthenticatedRequests: options.allowUnauthenticatedRequests,\n    },\n    policyName\n  );\n};\n", "import { InboundPolicyHandler } from \"../../policies\";\nimport { ZuploRequest } from \"../../request\";\nimport { FormDataToJsonInboundPolicyOptions } from \"./options\";\n\nexport { FormDataToJsonInboundPolicyOptions };\n\n/**\n * Converts form data in the incoming request to JSON.\n *\n * @title Form Data to JSON\n * @public\n * @param request - The ZuploRequest\n * @param context - The ZuploContext\n * @param options - The policy options set in policies.json\n * @param policyName - The name of the policy as set in policies.json\n * @returns A Request or a Response\n */\nexport const FormDataToJsonInboundPolicy: InboundPolicyHandler<\n  FormDataToJsonInboundPolicyOptions\n> = async (request, context, options) => {\n  const FORM_URL_ENCODED = \"application/x-www-form-urlencoded\";\n  const FORM_MULTIPART = \"multipart/form-data\";\n\n  const contentType = request.headers.get(\"content-type\")?.toLowerCase();\n\n  if (\n    !contentType ||\n    ![FORM_MULTIPART, FORM_URL_ENCODED].includes(contentType)\n  ) {\n    if (options && options.badRequestIfNotFormData) {\n      return new Response(\n        `Bad Request - expected content-type '${FORM_URL_ENCODED}' or ${FORM_MULTIPART}`,\n        { status: 400, statusText: \"Bad Request\" }\n      );\n    }\n    return request;\n  }\n\n  const formData = await request.formData();\n\n  if (options && options.optionalHoneypotName) {\n    if (formData.get(options.optionalHoneypotName) !== \"\") {\n      return new Response(\"Bad Request\", {\n        status: 400,\n        statusText: \"Bad Request\",\n      });\n    }\n  }\n\n  const body: Record<string, string> = {};\n\n  for (const [key, value] of formData) {\n    body[key] = value.toString();\n  }\n\n  const headers = new Headers(request.headers);\n  headers.set(\"content-type\", \"application/json\");\n  // don't set content-length, it will be set by the  new request\n  headers.delete(\"content-length\");\n\n  const newRequest = new ZuploRequest(request, {\n    body: JSON.stringify(body),\n    headers,\n  });\n\n  return newRequest;\n};\n", "import { ZuploContext } from \"../../context\";\nimport { ConfigurationError } from \"../../errors\";\nimport { InboundPolicyHandler } from \"../../policies\";\nimport { HttpProblems } from \"../../problem-responses/http-problems\";\nimport { ZuploRequest } from \"../../request\";\nimport { GeoFilterInboundPolicyOptions } from \"./options\";\n\nexport { GeoFilterInboundPolicyOptions };\n\nconst UNKNOWN = \"__unknown__\";\n\ninterface ParsedGeoSpec {\n  countries: string[];\n  regionCodes: string[];\n  asns: string[];\n}\n\ninterface ParsedOptions {\n  allow: ParsedGeoSpec;\n  block: ParsedGeoSpec;\n  ignoreUnknown: boolean;\n}\n\n/**\n * Block requests based on geo-location parameters: country, region code, and ASN\n *\n * @title Geo-location filtering\n * @public\n * @param request - The ZuploRequest\n * @param context - The ZuploContext\n * @param options - The policy options set in policies.json\n * @param policyName - The name of the policy as set in policies.json\n * @returns A Request or a Response\n */\nexport const GeoFilterInboundPolicy: InboundPolicyHandler<\n  GeoFilterInboundPolicyOptions\n> = async (request, context, options, policyName) => {\n  const parsedOptions: ParsedOptions = {\n    allow: {\n      countries: toLowerStringArray(\n        options.allow?.countries,\n        \"allow.countries\",\n        policyName\n      ),\n      regionCodes: toLowerStringArray(\n        options.allow?.regionCodes,\n        \"allow.regionCode\",\n        policyName\n      ),\n      asns: toLowerStringArray(\n        options.allow?.asns,\n        \"allow.asOrganization\",\n        policyName\n      ),\n    },\n    block: {\n      countries: toLowerStringArray(\n        options.block?.countries,\n        \"block.countries\",\n        policyName\n      ),\n      regionCodes: toLowerStringArray(\n        options.block?.regionCodes,\n        \"block.regionCode\",\n        policyName\n      ),\n      asns: toLowerStringArray(\n        options.block?.asns,\n        \"block.asOrganization\",\n        policyName\n      ),\n    },\n    // default to true for ignoreUnknown\n    ignoreUnknown: options.ignoreUnknown === false ? false : true,\n  };\n\n  const lowerCountry: string =\n    context.incomingRequestProperties.country?.toLowerCase() ?? UNKNOWN;\n  const lowerRegionCode: string =\n    context.incomingRequestProperties.regionCode?.toLowerCase() ?? UNKNOWN;\n  const lowerAsn: string =\n    context.incomingRequestProperties.asn?.toString() ?? UNKNOWN;\n\n  const ignoreUnknownCountry =\n    parsedOptions.ignoreUnknown && lowerCountry === UNKNOWN;\n  const ignoreUnknownCity =\n    parsedOptions.ignoreUnknown && lowerRegionCode === UNKNOWN;\n  const ignoreUnknownAsOrganization =\n    parsedOptions.ignoreUnknown && lowerAsn === UNKNOWN;\n\n  // ALLOW PHASE\n  const allowCountries = parsedOptions.allow.countries;\n  const allowRegionCodes = parsedOptions.allow.regionCodes;\n  const allowAsns = parsedOptions.allow.asns;\n\n  if (\n    allowCountries.length > 0 &&\n    !allowCountries.includes(lowerCountry) &&\n    !ignoreUnknownCountry\n  ) {\n    return blockedResponse(\n      request,\n      context,\n      policyName,\n      lowerCountry,\n      lowerRegionCode,\n      lowerAsn\n    );\n  }\n\n  if (\n    allowRegionCodes.length > 0 &&\n    !allowRegionCodes.includes(lowerRegionCode) &&\n    !ignoreUnknownCity\n  ) {\n    return blockedResponse(\n      request,\n      context,\n      policyName,\n      lowerCountry,\n      lowerRegionCode,\n      lowerAsn\n    );\n  }\n\n  if (\n    allowAsns.length > 0 &&\n    !allowAsns.includes(lowerAsn) &&\n    !ignoreUnknownAsOrganization\n  ) {\n    return blockedResponse(\n      request,\n      context,\n      policyName,\n      lowerCountry,\n      lowerRegionCode,\n      lowerAsn\n    );\n  }\n\n  // BLOCK PHASE\n  const blockCountries = parsedOptions.block.countries;\n  const blockRegionCode = parsedOptions.block.regionCodes;\n  const blockAsn = parsedOptions.block.asns;\n\n  if (\n    blockCountries.length > 0 &&\n    blockCountries.includes(lowerCountry) &&\n    !ignoreUnknownCountry\n  ) {\n    return blockedResponse(\n      request,\n      context,\n      policyName,\n      lowerCountry,\n      lowerRegionCode,\n      lowerAsn\n    );\n  }\n\n  if (\n    blockRegionCode.length > 0 &&\n    blockRegionCode.includes(lowerRegionCode) &&\n    !ignoreUnknownCity\n  ) {\n    return blockedResponse(\n      request,\n      context,\n      policyName,\n      lowerCountry,\n      lowerRegionCode,\n      lowerAsn\n    );\n  }\n\n  if (\n    blockAsn.length > 0 &&\n    blockAsn.includes(lowerAsn) &&\n    !ignoreUnknownAsOrganization\n  ) {\n    return blockedResponse(\n      request,\n      context,\n      policyName,\n      lowerCountry,\n      lowerRegionCode,\n      lowerAsn\n    );\n  }\n\n  return request;\n};\n\nfunction blockedResponse(\n  request: ZuploRequest,\n  context: ZuploContext,\n  policyName: string,\n  country?: string,\n  regionCode?: string,\n  asn?: string\n) {\n  context.log.debug(\n    `Request blocked by GeoFilterInboundPolicy '${policyName}' (country: '${country}', regionCode: '${regionCode}', asn: '${asn}')`\n  );\n  return HttpProblems.forbidden(request, context, {\n    geographicContext: {\n      country,\n      regionCode,\n      asn,\n    },\n  });\n}\n\nfunction toLowerStringArray(\n  input: string | string[] | undefined,\n  propertyName: string,\n  policyName: string\n): string[] {\n  if (typeof input === \"string\") {\n    return input.split(\",\").map((s) => s.trim().toLowerCase());\n  }\n  if (typeof input === \"undefined\") {\n    return [];\n  }\n  if (Array.isArray(input)) {\n    return input.map((s) => s.trim().toLowerCase());\n  }\n  throw new ConfigurationError(\n    `Invalid '${propertyName}' for GeoFilterInboundPolicy '${policyName}': '${input}', must be a string or string[]`\n  );\n}\n", "import { InboundPolicyHandler } from \"../../policies\";\nimport { JWTScopeValidationInboundPolicyOptions } from \"./options\";\n\nexport { JWTScopeValidationInboundPolicyOptions };\n\n/**\n * Validates that the JWT token includes specific scopes\n *\n * @title JWT Scope Validation\n * @public\n * @param request - The ZuploRequest\n * @param context - The ZuploContext\n * @param options - The policy options set in policies.json\n * @param policyName - The name of the policy as set in policies.json\n * @returns A Request or a Response\n */\nexport const JWTScopeValidationInboundPolicy: InboundPolicyHandler<\n  JWTScopeValidationInboundPolicyOptions\n> = async (request, context, options) => {\n  const tokenScopes = request.user?.data[\"scope\"].split(\" \") || [];\n\n  const scopeChecker = (tokenScopes: string[], routeScopes: string[]) =>\n    routeScopes.every((v) => tokenScopes.includes(v));\n\n  if (!scopeChecker(tokenScopes, options.scopes)) {\n    const data = {\n      code: \"UNAUTHORIZED\",\n      help_url: \"https://zup.fail/UNAUTHORIZED\",\n      message: `JWT must have all the following scopes: ${options.scopes}`,\n    };\n\n    return new Response(JSON.stringify(data), {\n      status: 401,\n      statusText: \"Unauthorized\",\n      headers: {\n        \"content-type\": \"application/json\",\n      },\n    });\n  }\n  return request;\n};\n", "import { ZuploContext } from \"../../context\";\nimport { InboundPolicyHandler } from \"../../policies\";\nimport { HttpProblems } from \"../../problem-responses/http-problems\";\nimport { ZuploRequest } from \"../../request\";\nimport { MockApiInboundOptions } from \"./options\";\n\nexport { MockApiInboundOptions };\n\ninterface ExampleData {\n  responseName: string;\n  contentName: string;\n  exampleName: string;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  exampleValue: any;\n}\n\n/**\n * Returns example responses from the OpenAPI document associated with this route.\n *\n * @title Mock API Response\n * @public\n * @param request - The ZuploRequest\n * @param context - The ZuploContext\n * @param options - The policy options set in policies.json\n * @param policyName - The name of the policy as set in policies.json\n * @returns A Request or a Response\n */\nexport const MockApiInboundPolicy: InboundPolicyHandler<\n  MockApiInboundOptions\n> = async (request, context, options, policyName) => {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const responses = context.route.raw<any>().responses;\n\n  if (!responses) {\n    return getProblemDetailResponse(\n      policyName,\n      request,\n      context,\n      \"No responses defined in the OpenAPI document. Add some responses with examples to use this policy.\"\n    );\n  }\n  const responseNames = Object.keys(responses);\n  let examplesData: ExampleData[] = [];\n\n  if (responseNames.length === 0) {\n    return getProblemDetailResponse(\n      policyName,\n      request,\n      context,\n      \"No response object defined under responses in the OpenAPI document. Add some response objects with examples to use this policy.\"\n    );\n  }\n\n  responseNames.forEach((responseName) => {\n    if (responses[responseName][\"content\"]) {\n      const contentNames = Object.keys(responses[responseName][\"content\"]);\n\n      contentNames.forEach((contentName) => {\n        const examples =\n          responses[responseName][\"content\"][contentName].examples;\n\n        if (examples) {\n          const exampleNames = Object.keys(examples);\n\n          exampleNames.forEach((exampleName) => {\n            examplesData.push({\n              responseName,\n              contentName,\n              exampleName,\n              exampleValue: examples[exampleName],\n            });\n          });\n        }\n      });\n    }\n  });\n\n  examplesData = examplesData.filter((e) => {\n    if (\n      options.responsePrefixFilter &&\n      !e.responseName.startsWith(options.responsePrefixFilter)\n    ) {\n      return false;\n    }\n\n    if (options.contentType && !(e.contentName === options.contentType)) {\n      return false;\n    }\n\n    if (options.exampleName && !(e.exampleName === options.exampleName)) {\n      return false;\n    }\n\n    return true;\n  });\n\n  if (options.random && examplesData.length > 1) {\n    const randomKey = Math.floor(Math.random() * examplesData.length);\n    return generateResponse(examplesData[randomKey]);\n  } else if (examplesData.length > 0) {\n    return generateResponse(examplesData[0]);\n  } else {\n    return getProblemDetailResponse(\n      policyName,\n      request,\n      context,\n      \"No examples matching the mocking options found in the OpenAPI document. Add examples to the OpenAPI document matching the options for this policy or change the mocking options to match the examples in the OpenAPI document.\"\n    );\n  }\n};\n\nfunction generateResponse(exampleData: ExampleData): Response {\n  const jsonValue = JSON.stringify(exampleData.exampleValue, null, 2);\n  const headers: Headers = new Headers();\n  headers.set(\"Content-Type\", exampleData.contentName);\n\n  switch (exampleData.responseName) {\n    case \"1XX\":\n      return new Response(jsonValue, { status: 100, headers });\n    case \"2XX\":\n      return new Response(jsonValue, { status: 200, headers });\n    case \"3XX\":\n      return new Response(jsonValue, { status: 300, headers });\n    case \"4XX\":\n      return new Response(jsonValue, { status: 400, headers });\n    case \"5XX\":\n    case \"default\":\n      return new Response(jsonValue, { status: 500, headers });\n    default:\n      return new Response(jsonValue, {\n        status: Number(exampleData.responseName),\n        headers,\n      });\n  }\n}\n\nconst getProblemDetailResponse = (\n  policyName: string,\n  request: ZuploRequest,\n  context: ZuploContext,\n  message: string\n) => {\n  const detail = `Error in policy: ${policyName} - On route ${request.method} ${context.route.path}. ${message}`;\n  return HttpProblems.internalServerError(request, context, { detail });\n};\n", "import { ZuploContext } from \"../../context\";\nimport { RuntimeError } from \"../../errors\";\nimport internals from \"../../internals\";\nimport { Logger } from \"../../logging/interfaces\";\nimport { ZuploRequest } from \"../../request\";\nimport { HttpMethod } from \"../../router/interfaces\";\nimport { BatchDispatch } from \"../../utils/batch-dispatch\";\nimport { MoesifInboundPolicyOptions } from \"./options\";\n\nexport { MoesifInboundPolicyOptions };\n\nconst DEFAULT_DIRECTION = \"Incoming\";\nconst DEFAULT_OPTIONS: Partial<MoesifInboundPolicyOptions> = {\n  logRequestBody: true,\n  logResponseBody: true,\n};\n\ninterface MoesifRequest {\n  time: string;\n  uri: string;\n  verb: HttpMethod;\n  api_version?: string;\n  ip_address?: string;\n  headers: Record<string, string>;\n  body?: unknown;\n  transfer_encoding?: string;\n}\n\ninterface MoesifResponse {\n  time: string;\n  status: number;\n  ip_address?: string;\n  headers: Record<string, string>;\n  body?: unknown;\n  transfer_encoding?: string;\n}\n\ninterface MoesifEntry {\n  request: MoesifRequest;\n  response: MoesifResponse;\n  session_token?: string;\n  user_id?: string;\n  company_id?: string;\n  direction?: string;\n  metadata?: unknown;\n}\n\ninterface MoesifContext {\n  apiVersion?: string;\n  userId?: string;\n  companyId?: string;\n  sessionToken?: string;\n  metadata?: unknown;\n}\n\nfunction headersToObject(headers: Headers) {\n  const h: Record<string, string> = {};\n  headers.forEach((value, key) => {\n    h[key] = value;\n  });\n  return h;\n}\n\nfunction timestamp() {\n  return new Date().toISOString();\n}\n\nconst contextMap = new WeakMap<ZuploContext, MoesifContext>();\nconst defaultMoesifContext: MoesifContext = {};\n\nexport function setMoesifContext(\n  context: ZuploContext,\n  moesifContext: MoesifContext\n) {\n  let mc = contextMap.get(context);\n  if (!mc) {\n    mc = defaultMoesifContext;\n  }\n\n  const newMoesifContext = Object.assign({ ...mc }, moesifContext);\n  contextMap.set(context, newMoesifContext);\n}\n\nasync function readBody(\n  reqRes: Request | Response,\n  context: ZuploContext\n): Promise<unknown | string> {\n  const contentType = reqRes.headers.get(\"content-type\");\n  if (contentType && contentType.indexOf(\"json\") !== 0) {\n    try {\n      const body = await reqRes.clone().json();\n      return body;\n    } catch (err) {\n      // ignore and allow next phase to pick it up\n      context.log.error(err);\n    }\n  }\n\n  const body = await reqRes.clone().text();\n  context.log.debug({ textBody: body });\n  return body;\n}\n\nconst dispatchers: Record<string, BatchDispatch<MoesifEntry>> = {};\n\nlet _lastLogger: Logger | undefined;\n\nfunction getLastLogger() {\n  if (!_lastLogger) {\n    throw new RuntimeError(\"Invalid State - no _lastLogger\");\n  }\n  return _lastLogger;\n}\n\n// need a dispatcher per applicationId\nfunction getDispatcher(applicationId: string) {\n  let dispatcher = dispatchers[applicationId];\n  if (!dispatcher) {\n    dispatcher = new BatchDispatch<MoesifEntry>(\n      \"moesif-inbound\",\n      100,\n      async (entries) => {\n        const body = JSON.stringify(entries);\n        getLastLogger().debug(\"posting\", body);\n        const result = await internals.fetch(\n          \"https://api.moesif.net/v1/events/batch\",\n          {\n            method: \"POST\",\n            headers: {\n              \"content-type\": \"application/json\",\n              \"X-Moesif-Application-Id\": applicationId,\n            },\n            body,\n          }\n        );\n        if (!result.ok) {\n          getLastLogger().error({\n            status: result.status,\n            body: await result.text(),\n          });\n        }\n      }\n    );\n  }\n  return dispatcher;\n}\n\n/**\n * Moesif is an API analytics and billing service. This policy allows you to send metering calls for each API to their events batch endpoint.\n *\n * @remarks\n * Moesif {@link https://moesif.com|moesif.com} is an API analytics and monetization\n * platform. This policy allows you to measure (and meter) API calls flowing\n * through your Zuplo gateway.\n *\n * Add the policy to each route you want to meter. Note you can specify the Meter\n * API Name and Meter Value (meter increment) at the policy level.\n *\n * @title Moesif Analytics & Billing\n * @public\n * @param request - The ZuploRequest\n * @param context - The ZuploContext\n * @param options - The policy options set in policies.json\n * @param policyName - The name of the policy as set in policies.json\n * @returns A Request or a Response\n */\nexport async function MoesifInboundPolicy(\n  request: ZuploRequest,\n  context: ZuploContext,\n  passedOptions: MoesifInboundPolicyOptions,\n  policyName: string\n) {\n  _lastLogger = context.log;\n  const startTime = timestamp();\n\n  // pick up the defaults for any optional options\n  const options = Object.assign(DEFAULT_OPTIONS, passedOptions);\n\n  if (!options.applicationId) {\n    throw new Error(\n      `Invalid configuration for MoesifInboundPolicy '${policyName}' - applicationId is required`\n    );\n  }\n\n  const requestBody = options.logRequestBody\n    ? await readBody(request, context)\n    : undefined;\n\n  context.addResponseSendingFinalHook(\n    async (response: Response, latestRequest: ZuploRequest) => {\n      // This is checked above, on entry\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      const dispatcher = getDispatcher(options.applicationId!);\n      const ip = request.headers.get(\"true-client-ip\");\n\n      const mc = contextMap.get(context) ?? {};\n\n      const req: MoesifRequest = {\n        time: startTime,\n        uri: request.url,\n        verb: request.method as HttpMethod,\n        body: requestBody,\n        ip_address: ip ?? undefined,\n        api_version: mc.apiVersion,\n        headers: headersToObject(request.headers),\n      };\n\n      const responseBody = options.logResponseBody\n        ? await readBody(response, context)\n        : undefined;\n\n      const res: MoesifResponse = {\n        time: timestamp(),\n        status: response.status,\n        headers: headersToObject(response.headers),\n        body: responseBody,\n      };\n\n      const entry: MoesifEntry = {\n        request: req,\n        response: res,\n        user_id: mc.userId ?? latestRequest.user?.sub, // allow override\n        session_token: mc.sessionToken,\n        company_id: mc.companyId,\n        metadata: mc.metadata,\n        direction: DEFAULT_DIRECTION,\n      };\n\n      dispatcher.enqueue(entry);\n      context.waitUntil(dispatcher.waitUntilFlushed());\n    }\n  );\n\n  return request;\n}\n", "import { ZuploContext } from \"../../context\";\nimport internals from \"../../internals\";\nimport { StoredMeteringSubscriptionWithQuotas } from \"../../metering-interfaces\";\nimport { ProblemDetails } from \"../../problem-responses/problem\";\nimport { SystemLogMap } from \"../../system-log-map\";\nimport { Environment } from \"../../utils/environment\";\nimport { MonetizationPolicyMeters } from \"./policy\";\n\nexport async function loadSubscription(\n  context: ZuploContext,\n  userSub: string,\n  policyName: string,\n  bucketId: string\n): Promise<StoredMeteringSubscriptionWithQuotas | undefined> {\n  const systemLog = SystemLogMap.getLogger(context);\n  const { authApiJWT, meteringServiceUrl } = Environment.instance;\n  let subscriptionResult:\n    | { data: StoredMeteringSubscriptionWithQuotas[] }\n    | undefined;\n\n  try {\n    const res: Response = await internals.fetch(\n      `${meteringServiceUrl}/internal/v1/metering/${bucketId}/subscriptions?customerKey=${userSub}`,\n      {\n        headers: {\n          Authorization: `Bearer ${authApiJWT}`,\n          \"zp-rid\": context.requestId,\n        },\n        method: \"GET\",\n      }\n    );\n    if (!res.ok) {\n      const loadSubscriptionError = (await res.json()) as ProblemDetails;\n\n      const errMessage =\n        loadSubscriptionError.detail ??\n        loadSubscriptionError.title ??\n        \"Unknown error on quota consumption.\";\n      context.log.error(\n        `MonetizationInboundPolicy '${policyName}' - Error loading subscription. ${res.status} - ${errMessage}`\n      );\n      systemLog.error(\n        `MonetizationInboundPolicy '${policyName}' - Error loading subscription.${res.status} - ${errMessage}`\n      );\n    } else {\n      subscriptionResult = (await res.json()) as {\n        data: StoredMeteringSubscriptionWithQuotas[];\n      };\n    }\n  } catch (err) {\n    systemLog.error(\n      `MonetizationInboundPolicy '${policyName}' - Error loading subscription`,\n      err\n    );\n    // Do not throw\n  }\n\n  // @NOTE - If a user has multiple subscriptions, get the most recently created one\n  const subscriptionRes: StoredMeteringSubscriptionWithQuotas[] | undefined =\n    subscriptionResult &&\n    subscriptionResult.data &&\n    subscriptionResult.data.length > 0\n      ? subscriptionResult.data\n      : undefined;\n\n  if (subscriptionRes && subscriptionRes.length > 1) {\n    // Sort the subscriptions by the createdOn date in descending order\n    const sortedSubscriptions = subscriptionRes.sort((a, b) =>\n      a.createdOn > b.createdOn ? -1 : 1\n    );\n\n    // Return the first (most recent) subscription\n    return sortedSubscriptions[0];\n  }\n\n  return subscriptionRes ? subscriptionRes[0] : subscriptionRes;\n}\n\nexport async function consumeSubcriptionQuotas(\n  context: ZuploContext,\n  subscriptionId: string,\n  policyName: string,\n  bucketId: string,\n  meters: MonetizationPolicyMeters\n) {\n  const { authApiJWT, meteringServiceUrl } = Environment.instance;\n  const systemLog = SystemLogMap.getLogger(context);\n  try {\n    const consumption = await internals.fetch(\n      `${meteringServiceUrl}/internal/v1/metering/${bucketId}/subscriptions/${subscriptionId}/quotas/consume`,\n      {\n        headers: {\n          Authorization: `Bearer ${authApiJWT}`,\n          \"zp-rid\": context.requestId,\n        },\n        method: \"POST\",\n        // @TODO - make the meters customizable, hardcoded for v0\n        body: JSON.stringify({\n          meters: meters,\n        }),\n      }\n    );\n\n    if (!consumption.ok) {\n      const consumptionError = (await consumption.json()) as ProblemDetails;\n\n      const errMessage =\n        consumptionError.detail ??\n        consumptionError.title ??\n        \"Unknown error on quota consumption.\";\n      context.log.error(\n        `MonetizationInboundPolicy '${policyName}' - Error updating subscription quota. ${consumption.status} - ${errMessage}`\n      );\n      systemLog.error(\n        `MonetizationInboundPolicy '${policyName}' - Error updating subscription quota. ${consumption.status} - ${errMessage}`\n      );\n    }\n  } catch (err) {\n    context.log.error(\n      `MonetizationInboundPolicy '${policyName}' - Error updating subscription quota.`\n    );\n    systemLog.error(\n      `MonetizationInboundPolicy '${policyName}' - Error updating subscription quota.`,\n      err\n    );\n  }\n}\n", "import { ConfigurationError } from \"../../errors\";\nimport {\n  MeteringSubscriptionStatus,\n  SubscriptionMeters,\n} from \"../../metering-interfaces\";\nimport { parseValueToStringArray } from \"../../utils/options-parsing\";\nimport { MonetizationPolicyMeters } from \"./policy\";\n\nconst validSubscriptionStatuses = new Set([\n  \"active\",\n  \"inactive\",\n  \"incomplete\",\n  \"incomplete-expired\",\n  \"trialing\",\n  \"past-due\",\n  \"canceled\",\n  \"unpaid\",\n]);\n\nexport function validateMeters(\n  meters: MonetizationPolicyMeters,\n  policyName: string\n) {\n  try {\n    const nonNumericProperties: string[] = [];\n\n    for (const key in meters) {\n      if (\n        typeof meters[key] !== \"number\" &&\n        !(\n          Number.isInteger(meters[key]) &&\n          /^-?\\d+$/.test(meters[key].toString())\n        )\n      ) {\n        nonNumericProperties.push(key);\n      }\n    }\n\n    if (nonNumericProperties.length > 0) {\n      throw new ConfigurationError(\n        nonNumericProperties.length > 1\n          ? `The values found in these properties are not integers : ${nonNumericProperties.join(\", \")}`\n          : `The value in property '${nonNumericProperties[0]}' is not an integer`\n      );\n    }\n  } catch (err) {\n    if (err instanceof ConfigurationError) {\n      throw new ConfigurationError(\n        `MonetizationInboundPolicy '${policyName}' - The property 'meters' is invalid. ${err.message}`\n      );\n    }\n    throw err;\n  }\n}\n\nexport function parseAllowedSubscriptionStatuses(\n  providedAllowedSubscriptionStatuses: MeteringSubscriptionStatus[] | undefined,\n  policyName: string\n): MeteringSubscriptionStatus[] {\n  if (providedAllowedSubscriptionStatuses) {\n    try {\n      if (providedAllowedSubscriptionStatuses.length === 0) {\n        throw new ConfigurationError(`Must set valid subscription statuses`);\n      }\n\n      const statuses = parseValueToStringArray(\n        providedAllowedSubscriptionStatuses\n      );\n\n      const invalidStatuses: string[] = [];\n      for (const item of statuses) {\n        if (!validSubscriptionStatuses.has(item)) {\n          invalidStatuses.push(item);\n        }\n      }\n\n      if (invalidStatuses.length > 0) {\n        throw new ConfigurationError(\n          `Found the following invalid statuses: ${invalidStatuses.join(\", \")}`\n        );\n      }\n\n      return providedAllowedSubscriptionStatuses;\n    } catch (err) {\n      if (err instanceof ConfigurationError) {\n        throw new ConfigurationError(\n          `MonetizationInboundPolicy '${policyName}' - The property 'allowedSubscriptionStatuses' is invalid. ${err.message}`\n        );\n      }\n      throw err;\n    }\n  } else {\n    return [\"active\", \"incomplete\", \"trialing\"];\n  }\n}\n\nexport function compareMeters(\n  subscriptionMeters: SubscriptionMeters,\n  policyMeters: MonetizationPolicyMeters\n): {\n  metersInSubscription: MonetizationPolicyMeters;\n  metersNotInSubscription: MonetizationPolicyMeters;\n} {\n  const metersInSubscription: MonetizationPolicyMeters = {};\n  const metersNotInSubscription: MonetizationPolicyMeters = {};\n\n  for (const key in policyMeters) {\n    // eslint-disable-next-line no-prototype-builtins\n    if (subscriptionMeters.hasOwnProperty(key)) {\n      metersInSubscription[key] = policyMeters[key];\n    } else {\n      metersNotInSubscription[key] = policyMeters[key];\n    }\n  }\n\n  return { metersInSubscription, metersNotInSubscription };\n}\n", "import {\n  DYNAMIC_METERS_CONTEXT_DATA,\n  METERING_SUBSCRIPTION_CONTEXT_DATA,\n} from \"../../constants\";\nimport { ZuploContext } from \"../../context\";\nimport { ContextData } from \"../../context-data\";\nimport { environment } from \"../../environment\";\nimport { ConfigurationError } from \"../../errors\";\nimport {\n  MeteringSubscriptionStatus,\n  StoredMeteringSubscriptionWithQuotas,\n} from \"../../metering-interfaces\";\nimport { InboundPolicy } from \"../../policies\";\nimport { HttpProblems } from \"../../problem-responses/http-problems\";\nimport { RequestGeneric, ZuploRequest } from \"../../request\";\nimport { statusCodesStringToNumberArray } from \"../../utils/options-parsing\";\nimport { optionValidator } from \"../../utils/validator\";\nimport { consumeSubcriptionQuotas, loadSubscription } from \"./metering-utils\";\nimport { MonetizationInboundPolicyOptions } from \"./options\";\nimport {\n  compareMeters,\n  parseAllowedSubscriptionStatuses,\n  validateMeters,\n} from \"./validation-utils\";\n\nexport { MonetizationInboundPolicyOptions };\n\nexport type MonetizationPolicyMeters = {\n  [Key in string]: number;\n};\n\n/**\n * The Monetization policy enables you to track & monetize by your API's usage\n *\n * @remarks\n * The Monetization policy allows you to track and monetize the usage of our API resources,\n * declaratively and programatically.\n *\n * @title Monetization\n * @beta\n * @param request - The ZuploRequest\n * @param context - The ZuploContext\n * @param options - The policy options set in policies.json\n * @param policyName - The name of the policy as set in policies.json\n * @returns A Request or a Response\n */\nexport class MonetizationInboundPolicy extends InboundPolicy<MonetizationInboundPolicyOptions> {\n  static getSubscription(\n    context: ZuploContext\n  ): StoredMeteringSubscriptionWithQuotas | undefined {\n    return ContextData.get(context, METERING_SUBSCRIPTION_CONTEXT_DATA);\n  }\n\n  static setMeters(context: ZuploContext, meters: MonetizationPolicyMeters) {\n    validateMeters(meters, \"setMeters\");\n    ContextData.set(context, DYNAMIC_METERS_CONTEXT_DATA, meters);\n  }\n\n  async handler(\n    request: ZuploRequest<RequestGeneric>,\n    context: ZuploContext\n  ): Promise<ZuploRequest<RequestGeneric> | Response> {\n    optionValidator(this.options, this.policyName)\n      .optional(\"allowRequestsWithoutSubscription\", \"boolean\")\n      .optional(\"allowRequestsOverQuota\", \"boolean\")\n      .optional(\"bucketId\", \"string\");\n\n    if (!this.options.meterOnStatusCodes) {\n      this.options.meterOnStatusCodes = \"200-399\";\n    }\n\n    const allowRequestsOverQuota = this.options.allowRequestsOverQuota ?? false;\n\n    const statusCodes = statusCodesStringToNumberArray(\n      this.options.meterOnStatusCodes\n    );\n\n    // Merge policy meters + dynamic meters\n    const dynamicMeters = ContextData.get(\n      context,\n      DYNAMIC_METERS_CONTEXT_DATA\n    ) as MonetizationPolicyMeters | undefined;\n\n    const mergedMeters = {\n      ...this.options.meters,\n      ...dynamicMeters,\n    } as MonetizationPolicyMeters;\n\n    validateMeters(mergedMeters, this.policyName);\n\n    const allowRequestsWithoutSubscription =\n      this.options.allowRequestsWithoutSubscription ?? false;\n\n    const allowedSubscriptionStatus: MeteringSubscriptionStatus[] =\n      parseAllowedSubscriptionStatuses(\n        this.options.allowedSubscriptionStatuses,\n        this.policyName\n      );\n\n    context.addResponseSendingFinalHook(\n      async (\n        response: Response,\n        latestRequest: ZuploRequest,\n        context: ZuploContext\n      ) => {\n        const subscription: StoredMeteringSubscriptionWithQuotas | undefined =\n          ContextData.get(context, METERING_SUBSCRIPTION_CONTEXT_DATA);\n\n        const allowRequestsWithoutSubscription =\n          this.options.allowRequestsWithoutSubscription ?? false;\n        if (allowRequestsWithoutSubscription && !subscription) {\n          context.log.debug(\n            `MonetizationInboundPolicy '${this.policyName}' - No subscription found and property 'allowRequestsWithoutSubscription' is true`\n          );\n          return;\n        }\n\n        if (!this.options.bucketId) {\n          if (environment.ZUPLO_METERING_SERVICE_BUCKET_ID) {\n            this.options.bucketId =\n              environment.ZUPLO_METERING_SERVICE_BUCKET_ID;\n          } else {\n            throw new ConfigurationError(\n              `MonetizationInboundPolicy '${this.policyName}' - No bucketId property provided`\n            );\n          }\n        }\n\n        // Merge policy meters + dynamic meters\n        const dynamicMeters = ContextData.get(\n          context,\n          DYNAMIC_METERS_CONTEXT_DATA\n        ) as MonetizationPolicyMeters | undefined;\n\n        const mergedMeters = {\n          ...this.options.meters,\n          ...dynamicMeters,\n        } as MonetizationPolicyMeters;\n\n        validateMeters(mergedMeters, this.policyName);\n\n        if (\n          statusCodes.includes(response.status) &&\n          subscription &&\n          mergedMeters\n        ) {\n          context.log.debug(\n            `MonetizationInboundPolicy '${this.policyName}' - Updating subscription '${\n              subscription.id\n            }' with meters '${JSON.stringify(\n              mergedMeters\n            )} on response status '${response.status}'`\n          );\n\n          const { metersInSubscription, metersNotInSubscription } =\n            compareMeters(subscription.meters, mergedMeters);\n\n          if (\n            metersNotInSubscription &&\n            Object.keys(metersNotInSubscription).length > 0\n          ) {\n            const keys = Object.keys(metersNotInSubscription);\n            context.log.warn(\n              `The following meters cannot be applied since they are not present in the subscription: '${keys}'`\n            );\n          }\n\n          await consumeSubcriptionQuotas(\n            context,\n            subscription.id,\n            this.policyName,\n            this.options.bucketId,\n            metersInSubscription\n          );\n        }\n      }\n    );\n\n    // User must be populated by a previous stage\n    const user = request.user;\n    if (!user) {\n      if (allowRequestsWithoutSubscription) {\n        return request;\n      }\n\n      return HttpProblems.unauthorized(request, context, {\n        detail: \"Unable to check subscription for anonymous user\",\n      });\n    }\n\n    if (!this.options.bucketId) {\n      if (environment.ZUPLO_METERING_SERVICE_BUCKET_ID) {\n        this.options.bucketId = environment.ZUPLO_METERING_SERVICE_BUCKET_ID;\n      } else {\n        throw new ConfigurationError(\n          `MonetizationInboundPolicy '${this.policyName}' - No bucketId property provided`\n        );\n      }\n    }\n\n    const { sub } = user;\n    const subscriptionRes: StoredMeteringSubscriptionWithQuotas | undefined =\n      await loadSubscription(\n        context,\n        sub,\n        this.policyName,\n        this.options.bucketId\n      );\n\n    if (!subscriptionRes) {\n      context.log.warn(`No valid subscription found`);\n      if (allowRequestsWithoutSubscription) {\n        return request;\n      } else {\n        return HttpProblems.unauthorized(request, context, {\n          detail: \"No valid subscription found\",\n        });\n      }\n    }\n\n    if (\n      !allowedSubscriptionStatus.includes(subscriptionRes.status) &&\n      !allowRequestsWithoutSubscription\n    ) {\n      context.log.warn(\n        `Subscription '${subscriptionRes.id}' has status '${subscriptionRes.status}' which is not part of the allowed statuses.`\n      );\n      return HttpProblems.unauthorized(request, context, {\n        detail: \"No valid subscription found\",\n      });\n    }\n\n    if (allowedSubscriptionStatus.includes(subscriptionRes.status)) {\n      context.log.debug(\n        `Loading subscription '${subscriptionRes.id}' for user sub '${sub}' to ContextData`\n      );\n      // filter based on supported statuses, throw error if needed\n      ContextData.set(\n        context,\n        METERING_SUBSCRIPTION_CONTEXT_DATA,\n        subscriptionRes\n      );\n    }\n\n    // Inbound policy code\n    const subscription: StoredMeteringSubscriptionWithQuotas | undefined =\n      ContextData.get(context, METERING_SUBSCRIPTION_CONTEXT_DATA);\n\n    if (!subscription) {\n      if (allowRequestsWithoutSubscription) {\n        return request;\n      }\n\n      context.log.warn(\"Subscription is not available for user\");\n      return HttpProblems.paymentRequired(request, context, {\n        detail: \"Subscription is not available for user\",\n        title: \"No Subscription\",\n      });\n    }\n\n    if (subscription && Object.keys(subscription.meters).length === 0) {\n      context.log.error(\n        `Quota is not set up for subscription '${subscription.id}'`\n      );\n      return HttpProblems.tooManyRequests(request, context, {\n        detail: `Quota is not set up for the user's subscription`,\n        title: \"Quota Exceeded\",\n      });\n    }\n\n    // Check if all keys in options.meters are present in subscription.quotas\n    const policyMeterKeys = Object.keys(mergedMeters);\n    const missingMeterKeys = policyMeterKeys.filter(\n      (meterKey) => !Object.keys(subscription.meters).includes(meterKey)\n    );\n\n    if (missingMeterKeys.length > 0) {\n      context.log.warn(\n        `The following policy meters are not present in the subscription: ${missingMeterKeys.join(\n          \", \"\n        )}`\n      );\n      return HttpProblems.tooManyRequests(request, context, {\n        detail: `The following policy meters are not present in the subscription: ${missingMeterKeys.join(\n          \", \"\n        )}`,\n        title: \"Quota Exceeded\",\n      });\n    }\n\n    for (const key of Object.keys(mergedMeters)) {\n      const quota = subscription.meters[key].available;\n\n      if (quota <= 0) {\n        if (!allowRequestsOverQuota) {\n          return HttpProblems.tooManyRequests(request, context, {\n            detail: `Quota exceeded for meter '${key}'`,\n            title: \"Quota Exceeded\",\n          });\n        }\n      }\n    }\n\n    return request;\n  }\n}\n", "import { InboundPolicyHandler } from \"../../policies\";\nimport { OpenIdJwtInboundPolicy } from \"../open-id-jwt-auth-inbound/policy\";\nimport { OktaJwtInboundPolicyOptions } from \"./options\";\n\nexport { OktaJwtInboundPolicyOptions };\n\n/**\n * Authenticate users using Okta issued JWT tokens.\n *\n * @remarks\n * Authenticate requests with JWT tokens issued by Okta. This is a customized\n * version of the {@link https://zuplo.com/docs/policies/open-id-jwt-auth-inbound|OpenId JWT Policy} specifically\n * for Okta.\n *\n * See {@link https://zuplo.com/docs/articles/oauth-authentication|this document} for more information\n * about OAuth authorization in Zuplo.\n *\n * @title Okta JWT Auth\n * @public\n * @param request - The ZuploRequest\n * @param context - The ZuploContext\n * @param options - The policy options set in policies.json\n * @param policyName - The name of the policy as set in policies.json\n * @returns A Request or a Response\n */\nexport const OktaJwtInboundPolicy: InboundPolicyHandler<\n  OktaJwtInboundPolicyOptions\n> = async (request, context, options, policyName) =>\n  OpenIdJwtInboundPolicy(\n    request,\n    context,\n    {\n      issuer: options.issuerUrl,\n      audience: options.audience,\n      jwkUrl: `${options.issuerUrl}/v1/keys`,\n      allowUnauthenticatedRequests: options.allowUnauthenticatedRequests,\n    },\n    policyName\n  );\n", "import { KeyLike, importSPKI } from \"jose\";\nimport { InboundPolicyHandler } from \"../../policies\";\nimport { OpenIdJwtInboundPolicy } from \"../open-id-jwt-auth-inbound/policy\";\nimport { PropelAuthJwtInboundPolicyOptions } from \"./options\";\n\nexport { PropelAuthJwtInboundPolicyOptions };\n\nlet verifierKey: KeyLike | undefined;\n\n/**\n * Authenticate users using PropelAuth issued JWT tokens.\n *\n * @remarks\n * Authenticate requests with JWT tokens issued by {@link https://propelauth.com|PropelAuth}.\n * This is a customized version of the {@link https://zuplo.com/docs/policies/open-id-jwt-auth-inbound|OpenId JWT Policy}\n * specifically for PropelAuth.\n *\n * @title PropelAuth JWT Auth\n * @public\n * @param request - The ZuploRequest\n * @param context - The ZuploContext\n * @param options - The policy options set in policies.json\n * @param policyName - The name of the policy as set in policies.json\n * @returns A Request or a Response\n */\nexport const PropelAuthJwtInboundPolicy: InboundPolicyHandler<\n  PropelAuthJwtInboundPolicyOptions\n> = async (request, context, options, policyName) => {\n  if (!verifierKey) {\n    try {\n      verifierKey = await importSPKI(options.verifierKey, \"RS256\");\n    } catch (err) {\n      context.log.error(\"Could not import verifier key\");\n      throw err;\n    }\n  }\n\n  return OpenIdJwtInboundPolicy(\n    request,\n    context,\n    {\n      issuer: options.authUrl,\n      secret: verifierKey,\n      allowUnauthenticatedRequests: options.allowUnauthenticatedRequests,\n      subPropertyName: \"user_id\",\n    },\n    policyName\n  );\n};\n", "import {\n  isNumber,\n  isObject,\n  isString,\n  isUndefined,\n  isUndefinedOrNull,\n} from \"./types\";\n\n/*\n * Argument errors are used to validate arguments applied to functions\n */\n\nexport class ValidationError extends Error {\n  constructor(message: string) {\n    super(message);\n  }\n}\n\nexport class ArgumentUndefinedError extends ValidationError {\n  constructor(argument: string) {\n    super(`The argument '${argument}' is undefined.`);\n  }\n}\n\nexport class ArgumentTypeError extends ValidationError {\n  constructor(argument: string, type: string) {\n    super(`The argument '${argument}' must be of type '${type}'.`);\n  }\n}\n\nexport function throwIfUndefined(value: unknown, name: string) {\n  if (isUndefined(value)) {\n    throw new ArgumentUndefinedError(name);\n  }\n}\n\nexport function throwIfUndefinedOrNull(value: unknown, name: string) {\n  if (isUndefinedOrNull(value)) {\n    throw new ArgumentUndefinedError(name);\n  }\n}\n\nexport function throwIfNotString(value: unknown, name: string) {\n  throwIfUndefinedOrNull(value, name);\n  if (!isString(value)) {\n    throw new ArgumentTypeError(name, \"string\");\n  }\n}\n\nexport function throwIfNotNumber(value: unknown, name: string) {\n  throwIfUndefinedOrNull(value, name);\n  if (!isNumber(value)) {\n    throw new ArgumentTypeError(name, \"number\");\n  }\n}\n\n/*\n * Option errors are used to validate options set on various config\n */\n\n/**\n * Things like a policy, a handler, etc.\n */\ntype OptionWhat = \"policy\" | \"handler\" | \"route\";\n\nexport class OptionUndefinedError extends ValidationError {\n  constructor(what: OptionWhat, where: string, option: string) {\n    super(\n      `The option '${option}' on the ${what} named '${where}' is undefined.`\n    );\n  }\n}\n\nexport class OptionTypeError extends ValidationError {\n  constructor(what: OptionWhat, where: string, option: string, type: string) {\n    super(\n      `The option '${option}' on the ${what} named '${where}' must be of type '${type}'.`\n    );\n  }\n}\n\nexport function throwIfOptionUndefined(\n  what: OptionWhat,\n  where: string,\n  name: string,\n  value: unknown\n) {\n  if (isUndefined(value)) {\n    throw new OptionUndefinedError(what, where, name);\n  }\n}\n\nexport function throwIfOptionUndefinedOrNull(\n  what: OptionWhat,\n  where: string,\n  name: string,\n  value: unknown\n) {\n  if (isUndefinedOrNull(value)) {\n    throw new OptionUndefinedError(what, where, name);\n  }\n}\n\nexport function throwIfOptionNotString(\n  what: OptionWhat,\n  where: string,\n  name: string,\n  value: unknown\n) {\n  throwIfOptionUndefinedOrNull(what, where, name, value);\n  if (!isString(value)) {\n    throw new OptionTypeError(what, where, name, \"string\");\n  }\n}\n\nexport function throwIfOptionNotNumber(\n  what: OptionWhat,\n  where: string,\n  name: string,\n  value: unknown\n) {\n  throwIfOptionUndefinedOrNull(what, where, name, value);\n  if (!isNumber(value)) {\n    throw new OptionTypeError(what, where, name, \"number\");\n  }\n}\n\nexport function throwIfOptionNotObject(\n  what: OptionWhat,\n  where: string,\n  name: string,\n  value: unknown\n) {\n  throwIfOptionUndefinedOrNull(what, where, name, value);\n  if (!isObject(value)) {\n    throw new OptionTypeError(what, where, name, \"object\");\n  }\n}\n\n/*\n * State errors are used when a computed result is not in a valid state\n */\n\nexport function throwIfStateUndefined(value: unknown, message: string) {\n  if (isUndefined(value)) {\n    throw new ValidationError(message);\n  }\n}\n\nexport function throwIfStateUndefinedOrNull(value: unknown, message: string) {\n  if (isUndefinedOrNull(value)) {\n    throw new ValidationError(message);\n  }\n}\n\nexport function throwIfStateNotString(\n  value: unknown,\n  message: string\n): value is string {\n  throwIfStateUndefinedOrNull(value, message);\n  if (!isString(value)) {\n    throw new ValidationError(message);\n  }\n  return true;\n}\n\nexport function throwIfStateNotNumber(\n  value: unknown,\n  message: string\n): value is number {\n  throwIfStateUndefinedOrNull(value, message);\n  if (!isNumber(value)) {\n    throw new ValidationError(message);\n  }\n  return true;\n}\n\nexport function throwIfStateNotObject(\n  value: unknown,\n  message: string\n): value is object {\n  throwIfStateUndefinedOrNull(value, message);\n  if (!isObject(value)) {\n    throw new ValidationError(message);\n  }\n  return true;\n}\n", "import { SystemError } from \"../errors\";\nimport internals from \"../internals\";\nimport { throwIfNotString } from \"./errors\";\n\nexport interface RedisClient {\n  isEnabled(): boolean;\n  fetch({\n    url,\n    body,\n    method,\n    requestId,\n  }: {\n    url: string;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    body: any;\n    method: string;\n    requestId: string;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  }): Promise<any>;\n}\n\nexport class StandardRedisClient implements RedisClient {\n  static instance: StandardRedisClient | undefined;\n  redisClientUrl: string;\n  clientAuthToken: string;\n  userAgent: string;\n  deploymentName: string;\n\n  constructor(\n    domain: string,\n    token: string,\n    deploymentName: string,\n    userAgent: string\n  ) {\n    this.redisClientUrl = domain;\n    this.clientAuthToken = token;\n    this.deploymentName = deploymentName;\n    this.userAgent = userAgent;\n  }\n\n  public static initialize(\n    redisClientUrl: string,\n    clientAuthToken: string,\n    deploymentName: string,\n    userAgent: string\n  ): StandardRedisClient {\n    throwIfNotString(redisClientUrl, \"redisClientUrl\");\n    throwIfNotString(clientAuthToken, \"clientAuthToken\");\n\n    if (!StandardRedisClient.instance) {\n      StandardRedisClient.instance = new StandardRedisClient(\n        redisClientUrl,\n        clientAuthToken,\n        deploymentName,\n        userAgent\n      );\n    }\n    return StandardRedisClient.instance;\n  }\n\n  isEnabled(): boolean {\n    return (\n      this.redisClientUrl !== undefined && this.clientAuthToken !== undefined\n    );\n  }\n\n  async fetch({\n    url,\n    body,\n    method,\n    requestId,\n  }: {\n    url: string;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    body: any;\n    method: string;\n    requestId: string;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  }): Promise<any> {\n    throwIfNotString(url, \"url\");\n\n    const res = await internals.fetch(`${this.redisClientUrl}${url}`, {\n      method,\n      body,\n      headers: {\n        \"content-type\": \"application/json\",\n        authorization: `Bearer ${this.clientAuthToken}`,\n        \"zp-rid\": requestId,\n        \"zp-dn\": this.deploymentName,\n        \"User-Agent\": this.userAgent,\n      },\n    });\n\n    const data = res.headers.get(\"Content-Type\")?.includes(\"application/json\")\n      ? await res.json()\n      : await res.text();\n\n    if (res.ok) {\n      return data;\n    } else {\n      if (res.status === 401) {\n        throw new SystemError(\"Redis client failed with 401: Unauthorized\");\n      } else {\n        throw new SystemError(\n          `Redis client failed with (${res.status}): ${\n            typeof data === \"string\" ? data : JSON.stringify(data, null, 2)\n          }`\n        );\n      }\n    }\n  }\n}\n\nexport class InMemoryRedisClient implements RedisClient {\n  private keyValueStore: Map<string, { value: number; expiresAt: number }>;\n\n  constructor() {\n    this.keyValueStore = new Map<\n      string,\n      { value: number; expiresAt: number }\n    >();\n  }\n\n  isEnabled(): boolean {\n    return true;\n  }\n\n  fetch({\n    url,\n    body,\n    method,\n  }: {\n    url: string;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    body: any;\n    method: string;\n    requestId: string;\n  }): Promise<unknown> {\n    throwIfNotString(url, \"url\");\n\n    if (method === \"POST\" && url === \"/rate-limit\") {\n      const { incrBy, expire: expiresInSeconds, key } = JSON.parse(body);\n\n      const expirationEpoch = Date.now() + expiresInSeconds * 1000;\n      const currentDataForKey = this.keyValueStore.get(key);\n      if (currentDataForKey) {\n        // We don't have a background expiration so we check on first access\n        if (Date.now() > currentDataForKey.expiresAt) {\n          // Reset the key, which is equivalent to deleting it and starting afresh\n          this.keyValueStore.set(key, {\n            value: incrBy,\n            expiresAt: expirationEpoch,\n          });\n        } else {\n          this.keyValueStore.set(key, {\n            value: currentDataForKey.value + incrBy,\n            // retain the same value\n            expiresAt: currentDataForKey.expiresAt,\n          });\n        }\n      } else {\n        this.keyValueStore.set(key, {\n          value: incrBy,\n          expiresAt: expirationEpoch,\n        });\n      }\n\n      // We need to tell TS that this has a value since we just set it\n      const latestDataForKey = this.keyValueStore.get(key) as {\n        value: number;\n        expiresAt: number;\n      };\n\n      return Promise.resolve({\n        count: latestDataForKey.value,\n        ttlSeconds: Math.round(\n          (latestDataForKey.expiresAt - Date.now()) / 1000\n        ),\n      });\n    }\n\n    throw new SystemError(\n      \"The in-memory redis client only supports /rate-limit calls\"\n    );\n  }\n}\n", "import { ZuploContext } from \"../../context\";\nimport { ConfigurationError, RuntimeError, SystemError } from \"../../errors\";\nimport { CustomRateLimitDetails } from \"../../interfaces\";\nimport { Logger } from \"../../logging/interfaces\";\nimport { ZuploRequest } from \"../../request\";\nimport { Environment } from \"../../utils/environment\";\nimport {\n  InMemoryRedisClient,\n  RedisClient,\n  StandardRedisClient,\n} from \"../../utils/redis-rest-client\";\nimport { isString } from \"../../utils/types\";\nimport { RateLimitInboundPolicyOptions } from \"./options\";\n\ninterface RateLimitInboundPolicyInternalOptions\n  extends Omit<RateLimitInboundPolicyOptions, \"identifier\"> {\n  identifier?: {\n    export: string;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    module: any;\n  };\n}\n\nexport type RateLimitFunction = (\n  request: ZuploRequest,\n  context: ZuploContext,\n  policyName: string\n) => CustomRateLimitDetails | Promise<CustomRateLimitDetails>;\n\nexport const getRealIP = (request: ZuploRequest) => {\n  // See: https://developers.cloudflare.com/fundamentals/reference/http-request-headers/#cf-connecting-ip-in-worker-subrequests\n  const trueClientIp =\n    request.headers.get(\"x-real-ip\") ??\n    request.headers.get(\"true-client-ip\") ??\n    request.headers.get(\"cf-connecting-ip\");\n  if (trueClientIp) {\n    return trueClientIp;\n  }\n\n  const xff = request.headers.get(\"x-forwarded-for\");\n  const ip = xff ? xff.split(\",\")[0] : \"127.0.0.1\";\n  return ip;\n};\n\nexport const getIP: RateLimitFunction = async (request) => {\n  return { key: `ip-${getRealIP(request)}` };\n};\n\nexport const getUser: RateLimitFunction = async (request) => {\n  return {\n    key: `user-${request.user?.sub ?? \"anonymous\"}`,\n  };\n};\n\nexport const getAll: RateLimitFunction = async () => {\n  // We need a unique id so we can use it as the bucket id\n  return {\n    key: `all-2d77ce9d-9a3c-4206-9ab2-668cfd271095`,\n  };\n};\n\n// only need to create this once per runtime\nlet redisClient: RedisClient;\n\nexport function getRedisClient(policyName: string, logger: Logger) {\n  let redis: RedisClient | undefined;\n\n  if (redisClient) {\n    return redisClient;\n  }\n\n  if (Environment.instance.isLocalDevelopment) {\n    logger.info(\"Using in-memory redis client for local development.\");\n    redis = new InMemoryRedisClient();\n    redisClient = redis;\n    return redis;\n  }\n\n  const { authApiJWT, redisURL } = Environment.instance;\n\n  if (!isString(redisURL)) {\n    throw new SystemError(\n      `RateLimitInboundPolicy '${policyName}' - rate limit service URL not configured`\n    );\n  }\n\n  if (!isString(authApiJWT)) {\n    throw new SystemError(\n      `RateLimitInboundPolicy '${policyName}' - service authentication not configured`\n    );\n  }\n\n  if (redisURL) {\n    redis = StandardRedisClient.initialize(\n      redisURL,\n      authApiJWT,\n      Environment.instance.deploymentName ?? \"unknown\",\n      Environment.instance.systemUserAgent\n    );\n  }\n\n  if (!redis || !redis.isEnabled()) {\n    throw new SystemError(\n      `RateLimitInboundPolicy '${policyName}' - no redis ('${redis}') or redis.isEnabled ('${redis?.isEnabled}) is false`\n    );\n  }\n\n  redisClient = redis;\n  return redis;\n}\n\nexport async function getCountAndUpdateExpiry(\n  bucketName: string,\n  timeWindowMinutes: number,\n  client: RedisClient,\n  systemLog: Logger,\n  requestId: string\n) {\n  const expireInSeconds = Math.floor(timeWindowMinutes * 60);\n  const data: { count: number; ttlSeconds: number } = await client.fetch({\n    url: \"/rate-limit\",\n    method: \"POST\",\n    body: JSON.stringify({\n      incrBy: 1,\n      expire: expireInSeconds,\n      key: bucketName,\n    }),\n    requestId,\n  });\n\n  return data;\n}\n\nexport function wrapUserFunction(\n  options: RateLimitInboundPolicyInternalOptions,\n  policyName: string\n) {\n  let userFunction: RateLimitFunction;\n\n  if (options.rateLimitBy === \"function\") {\n    if (!options.identifier) {\n      throw new ConfigurationError(\n        `RateLimitInboundPolicy '${policyName}' - If rateLimitBy set to 'function' options.identifier must be specified`\n      );\n    }\n    if (!options.identifier.module) {\n      throw new ConfigurationError(\n        `RateLimitInboundPolicy '${policyName}' - If rateLimitBy set to 'function' options.identifier.module must be specified`\n      );\n    }\n    if (!options.identifier.export) {\n      throw new ConfigurationError(\n        `RateLimitInboundPolicy '${policyName}' - If rateLimitBy set to 'function' options.identifier.export must be specified`\n      );\n    }\n\n    userFunction = options.identifier.module[options.identifier.export];\n    if (!userFunction || typeof userFunction !== \"function\") {\n      throw new ConfigurationError(\n        `RateLimitInboundPolicy '${policyName}' - Custom rate limit function must be a valid function`\n      );\n    }\n  }\n\n  const outerFunction: RateLimitFunction = async (\n    request,\n    context,\n    policyName\n  ) => {\n    const result = await userFunction(request, context, policyName);\n    if (!result.key) {\n      const message = `RateLimitInboundPolicy '${policyName}' - Custom rate limit function must return a valid key property '${JSON.stringify(\n        result,\n        null,\n        2\n      )}'`;\n      context.log.error(message);\n      throw new RuntimeError(message);\n    }\n    return result;\n  };\n  return outerFunction;\n}\n\nexport const RETRY_AFTER_HEADER = \"Retry-After\";\n", "import { debug } from \"@zuplo/debug\";\nimport { getPolicyCacheName } from \"../../caches/keys\";\nimport { ZuploContext } from \"../../context\";\nimport { InboundPolicyHandler } from \"../../policies\";\nimport { HttpProblems } from \"../../problem-responses/http-problems\";\nimport { ZuploRequest } from \"../../request\";\nimport { SystemLogMap } from \"../../system-log-map\";\nimport { Environment } from \"../../utils/environment\";\n\nimport { MemoryZoneReadThroughCache } from \"../../caches/memory-zone-readthrough-cache\";\nimport {\n  RETRY_AFTER_HEADER,\n  RateLimitFunction,\n  getAll,\n  getCountAndUpdateExpiry,\n  getIP,\n  getRedisClient,\n  getUser,\n  wrapUserFunction,\n} from \"./common\";\nimport { RateLimitHeaderMode, RateLimitInboundPolicyOptions } from \"./options\";\n\nconst log = debug(\"zuplo:policies:RateLimitInboundPolicy\");\n\n/**\n * The rate-limiting policy is used to limit the number of requests that can be made against your API based on a key.\n *\n * @remarks\n * Rate-limiting allows you to set a maximum rate of requests for your API gateway.\n * This is useful to enforce rate limits agreed with your clients and protect your\n * downstream services.\n *\n * The Zuplo Rate-Limit allows you to limit based on different attributes of the\n * incoming request. For example, you might set a rate limit of 10 requests per\n * second per user, or 20 requests per second for a given IP address.\n *\n * The Zuplo rate-limiter also allows you to set a custom bucket name by which to\n * effect a rate-limit using a function.\n *\n * When a client reaches a rate limit - they will receive a `429` response code.\n *\n * @title Rate Limiting\n * @public\n * @param request - The ZuploRequest\n * @param context - The ZuploContext\n * @param options - The policy options set in policies.json\n * @param policyName - The name of the policy as set in policies.json\n * @returns A Request or a Response\n */\nexport const AsyncRateLimitInboundPolicy: InboundPolicyHandler<\n  RateLimitInboundPolicyOptions\n> = async (\n  request: ZuploRequest,\n  context: ZuploContext,\n  options: RateLimitInboundPolicyOptions,\n  policyName: string\n) => {\n  const systemLog = SystemLogMap.getLogger(context);\n\n  const rateLimited = (\n    rateLimitHeaderMode: RateLimitHeaderMode,\n    ttlSeconds: number\n  ) => {\n    const headers: { [RETRY_AFTER_HEADER]?: string } = {};\n\n    if (!rateLimitHeaderMode || rateLimitHeaderMode === \"retry-after\") {\n      headers[RETRY_AFTER_HEADER] = ttlSeconds.toString();\n    }\n\n    return HttpProblems.tooManyRequests(request, context, undefined, headers);\n  };\n\n  const rateLimitByFunctions: Record<string, RateLimitFunction> = {\n    function: wrapUserFunction(options, policyName),\n    user: getUser,\n    ip: getIP,\n    all: getAll,\n  };\n\n  // Using build id for now - but we should use deployment name\n  // const deploymentName =\n  //   Gateway.getInstance().runtimeEnvironment.__ZUPLO_DEPLOYMENT_NAME;\n  const detailsFunction = rateLimitByFunctions[options.rateLimitBy];\n\n  const customDetails = await detailsFunction(request, context, policyName);\n\n  // if a rate limit function (typically custom) provides requestsAllowed\n  // or timeWindowMinutes - that overrides what was provided in the\n  // policy options\n  const key = customDetails.key;\n  const requestsAllowed =\n    customDetails.requestsAllowed ?? options.requestsAllowed;\n  const timeWindowMinutes =\n    customDetails.timeWindowMinutes ?? options.timeWindowMinutes;\n  const rateLimitHeaderMode = options.headerMode ?? \"retry-after\";\n\n  const redis = getRedisClient(policyName, systemLog);\n  const buildId = Environment.instance.build.BUILD_ID;\n\n  // TODO - should we use the buildID??\n  const bucketName = `bucket/${buildId}/${policyName}/${key}`;\n\n  const cacheName = await getPolicyCacheName(policyName, options);\n  const cache = new MemoryZoneReadThroughCache<number>(cacheName, context);\n\n  // always increment the count, even if they will get rejected\n  // customer needs to chill out\n  const redisPromise = getCountAndUpdateExpiry(\n    bucketName,\n    timeWindowMinutes,\n    redis,\n    systemLog,\n    context.requestId\n  );\n\n  let rateLimitResponse: Promise<Response> | undefined;\n\n  const asyncCheck = async () => {\n    const redisCount = await redisPromise;\n\n    if (redisCount.count > requestsAllowed) {\n      const expires = Date.now() + redisCount.ttlSeconds * 1000;\n      cache.put(bucketName, expires, redisCount.ttlSeconds);\n      log(\n        `RateLimitInboundPolicy '${policyName}' - returning 429 from redis for '${bucketName}' (async mode)`\n      );\n      rateLimitResponse = rateLimited(\n        rateLimitHeaderMode,\n        redisCount.ttlSeconds\n      );\n    }\n  };\n\n  void asyncCheck();\n\n  const expires = await cache.get(bucketName);\n\n  if (expires !== undefined && expires > Date.now()) {\n    log(\n      `RateLimitInboundPolicy '${policyName}' - returning 429 from cache for '${bucketName}' (async mode)`\n    );\n    const ttlSeconds = Math.round((expires - Date.now()) / 1000);\n    return rateLimited(rateLimitHeaderMode, ttlSeconds);\n  }\n\n  context.addResponseSendingHook(async (response) => {\n    // if we already have a rate limit response, return it.\n    return rateLimitResponse ?? response;\n  });\n\n  return request;\n};\n", "import { debug } from \"@zuplo/debug\";\nimport { ZuploContext } from \"../../context\";\nimport { SystemError } from \"../../errors\";\nimport { InboundPolicyHandler } from \"../../policies\";\nimport { HttpProblems } from \"../../problem-responses/http-problems\";\nimport { ZuploRequest } from \"../../request\";\nimport { SystemLogMap } from \"../../system-log-map\";\nimport { Environment } from \"../../utils/environment\";\nimport { AsyncRateLimitInboundPolicy } from \"./async\";\nimport {\n  RETRY_AFTER_HEADER,\n  RateLimitFunction,\n  getAll,\n  getCountAndUpdateExpiry,\n  getIP,\n  getRedisClient,\n  getUser,\n  wrapUserFunction,\n} from \"./common\";\nimport {\n  RateLimitHeaderMode,\n  RateLimitInboundPolicyOptions,\n  RateLimitMode,\n} from \"./options\";\n\nexport { RateLimitInboundPolicyOptions };\n\nconst log = debug(\"zuplo:policies:RateLimitInboundPolicy\");\n\nconst DEFAULT_RATE_LIMIT_MODE: RateLimitMode = \"strict\";\n\n/**\n * The rate-limiting policy is used to limit the number of requests that can be made against your API based on a key.\n *\n * @remarks\n * Rate-limiting allows you to set a maximum rate of requests for your API gateway.\n * This is useful to enforce rate limits agreed with your clients and protect your\n * downstream services.\n *\n * The Zuplo Rate-Limit allows you to limit based on different attributes of the\n * incoming request. For example, you might set a rate limit of 10 requests per\n * second per user, or 20 requests per second for a given IP address.\n *\n * The Zuplo rate-limiter also allows you to set a custom bucket name by which to\n * effect a rate-limit using a function.\n *\n * When a client reaches a rate limit - they will receive a `429` response code.\n *\n * @title Rate Limiting\n * @public\n * @param request - The ZuploRequest\n * @param context - The ZuploContext\n * @param options - The policy options set in policies.json\n * @param policyName - The name of the policy as set in policies.json\n * @returns A Request or a Response\n */\nexport const RateLimitInboundPolicy: InboundPolicyHandler<\n  RateLimitInboundPolicyOptions\n> = async (\n  request: ZuploRequest,\n  context: ZuploContext,\n  options: RateLimitInboundPolicyOptions,\n  policyName: string\n) => {\n  const mode = options.mode ?? DEFAULT_RATE_LIMIT_MODE;\n\n  if (mode === \"async\") {\n    return AsyncRateLimitInboundPolicy(request, context, options, policyName);\n  }\n\n  const start = Date.now();\n  const systemLog = SystemLogMap.getLogger(context);\n  const throwOrLog = (message: string, err?: Error) => {\n    // TODO - when we have a way to convert err => SystemError without losing\n    // stack we should change this code to always use SystemError\n    if (options.throwOnFailure) {\n      throw new SystemError(message, { cause: err });\n    }\n    systemLog.error(message, err);\n  };\n\n  const rateLimited = (\n    rateLimitHeaderMode: RateLimitHeaderMode,\n    ttlSeconds: number\n  ) => {\n    const headers: { [RETRY_AFTER_HEADER]?: string } = {};\n\n    if (!rateLimitHeaderMode || rateLimitHeaderMode === \"retry-after\") {\n      headers[RETRY_AFTER_HEADER] = ttlSeconds.toString();\n    }\n\n    return HttpProblems.tooManyRequests(request, context, undefined, headers);\n  };\n\n  try {\n    const rateLimitByFunctions: Record<string, RateLimitFunction> = {\n      function: wrapUserFunction(options, policyName),\n      user: getUser,\n      ip: getIP,\n      all: getAll,\n    };\n\n    // Using build id for now - but we should use deployment name\n    // const deploymentName =\n    //   Gateway.getInstance().runtimeEnvironment.__ZUPLO_DEPLOYMENT_NAME;\n    const detailsFunction = rateLimitByFunctions[options.rateLimitBy];\n\n    const customDetails = await detailsFunction(request, context, policyName);\n\n    // if a rate limit function (typically custom) provides requestsAllowed\n    // or timeWindowMinutes - that overrides what was provided in the\n    // policy options\n    const key = customDetails.key;\n    const requestsAllowed =\n      customDetails.requestsAllowed ?? options.requestsAllowed;\n    const timeWindowMinutes =\n      customDetails.timeWindowMinutes ?? options.timeWindowMinutes;\n    const rateLimitHeaderMode = options.headerMode ?? \"retry-after\";\n\n    const redis = getRedisClient(policyName, systemLog);\n    const buildId = Environment.instance.build.BUILD_ID;\n\n    // TODO - should we use the buildID??\n    const bucketName = `bucket/${buildId}/${policyName}/${key}`;\n\n    // otherwise mode is strict\n    const redisCount = await getCountAndUpdateExpiry(\n      bucketName,\n      timeWindowMinutes,\n      redis,\n      systemLog,\n      context.requestId\n    );\n\n    if (redisCount.count > requestsAllowed) {\n      log(\n        `RateLimitInboundPolicy '${policyName}' - returning 429 from redis for '${bucketName}' (strict mode)`\n      );\n      return rateLimited(rateLimitHeaderMode, redisCount.ttlSeconds);\n    }\n\n    return request;\n  } catch (err) {\n    throwOrLog(err.message, err);\n    return request; // fallback to passthrough\n  } finally {\n    const latency = Date.now() - start;\n    log(`RateLimitInboundPolicy '${policyName}' - latency ${latency}ms`);\n  }\n};\n", "import { ZuploContext, ZuploRequest } from \"../../index.worker\";\nimport internals from \"../../internals\";\nimport { BatchDispatch } from \"../../utils/batch-dispatch\";\nimport { Environment } from \"../../utils/environment\";\nimport { getValueFromRequestUser } from \"../../utils/options-parsing\";\nimport { ReadmeMeteringInboundPolicyOptions } from \"./options\";\n\nexport { ReadmeMeteringInboundPolicyOptions };\ninterface NameValuePair {\n  name: string;\n  value: string;\n}\n\ninterface ReadmeMetricsIngestPayload {\n  development?: boolean;\n  clientIPAddress: string;\n  group: {\n    email?: string;\n    label?: string;\n    id?: string; // this is really for API keys, we don't trust sending these\n  };\n  request: {\n    log?: {\n      creator?: ReadmeCreator;\n      entries?: {\n        startedDateTime: string;\n        time: number;\n        request: {\n          headers: NameValuePair[];\n          queryString?: NameValuePair[];\n          method: string;\n          url: string;\n          httpVersion: string;\n        };\n        response: {\n          status: number;\n          statusText: string;\n          headers: NameValuePair[];\n          content: {\n            size?: number;\n          };\n        };\n      }[];\n    };\n  };\n}\n\ninterface ReadmeCreator {\n  name: string;\n  version: string;\n  comment?: string;\n}\n\nlet readmeCreator: ReadmeCreator;\n\ninterface NameValuePair {\n  name: string;\n  value: string;\n}\n\nfunction headersToNameValuePairs(headers: Headers): NameValuePair[] {\n  const result: NameValuePair[] = [];\n  for (const [name, value] of headers) {\n    result.push({ name, value });\n  }\n  return result;\n}\n\nfunction queryToNameValueParis(query: Record<string, string>): NameValuePair[] {\n  const result: NameValuePair[] = [];\n  Object.entries(query).forEach(([name, value]) => {\n    result.push({ name, value });\n  });\n  return result;\n}\n\nfunction parseIntOrUndefined(value: string | null): number | undefined {\n  if (value === null) {\n    return undefined;\n  }\n  const parsed = parseFloat(value);\n  if (isNaN(parsed)) {\n    return undefined;\n  }\n  return parsed;\n}\n\nconst batcherMap: Record<\n  string,\n  BatchDispatch<ReadmeMetricsIngestPayload>\n> = {};\n\n/**\n * Readme is a developer documentation and API metrics company. This policy pushes logs to their API calls dashboard.\n *\n * @remarks\n * {@link https://readme.com|Readme} is a developer Documentation and\n * metrics service. This policy pushes the request/response data to their ingestion\n * endpoint so you can see your Zuplo API traffic in their API calls dashboard.\n *\n * @title Readme Metrics\n * @public\n * @param request - The ZuploRequest\n * @param context - The ZuploContext\n * @param options - The policy options set in policies.json\n * @param policyName - The name of the policy as set in policies.json\n * @returns A Request or a Response\n */\nexport async function ReadmeMetricsInboundPolicy(\n  request: ZuploRequest,\n  context: ZuploContext,\n  options: ReadmeMeteringInboundPolicyOptions,\n  policyName: string\n) {\n  const startDate = new Date();\n  const startMs = Date.now();\n\n  if (!readmeCreator) {\n    readmeCreator = {\n      name: \"zuplo\",\n      version: Environment.instance.build.ZUPLO_VERSION,\n      comment: `zuplo/${Environment.instance.build.ZUPLO_VERSION}`,\n    };\n  }\n\n  context.addResponseSendingFinalHook(async (response) => {\n    try {\n      const userLabel =\n        options.userLabelPropertyPath && request.user\n          ? getValueFromRequestUser(\n              request.user,\n              options.userLabelPropertyPath,\n              \"userLabelPropertyPath\"\n            )\n          : request.user?.sub;\n\n      const userEmail =\n        options.userEmailPropertyPath && request.user\n          ? getValueFromRequestUser(\n              request.user,\n              options.userEmailPropertyPath,\n              \"userEmailPropertyPath\"\n            )\n          : undefined;\n\n      // TODO - type this correctly\n      const data: ReadmeMetricsIngestPayload = {\n        clientIPAddress: request.headers.get(\"true-client-ip\") ?? \"\",\n        development:\n          options.development !== undefined\n            ? options.development\n            : Environment.instance.isWorkingCopy ||\n              Environment.instance.isLocalDevelopment,\n        group: {\n          label: userLabel,\n          email: userEmail,\n          id: request.user?.sub ?? \"anonymous\",\n          // can be used for API keys, we're not comfortable sending this, but it is required so sending blank (confirmed with readme that is OK)\n        },\n        request: {\n          log: {\n            creator: readmeCreator,\n            entries: [\n              {\n                startedDateTime: startDate.toISOString(),\n                time: Date.now() - startMs,\n                request: {\n                  method: request.method,\n                  // by default we use the route path, because that is safer\n                  url: options.useFullRequestPath\n                    ? new URL(request.url).pathname\n                    : context.route.path,\n                  httpVersion: \"2\", // hard coding for now, not sure we can know this?\n                  headers: headersToNameValuePairs(request.headers),\n                  queryString: queryToNameValueParis(request.query),\n                },\n                response: {\n                  status: response.status,\n                  statusText: response.statusText,\n                  headers: headersToNameValuePairs(response.headers),\n                  content: {\n                    // TODO - need to not set this if this is not a number otherwise we'll get NaN\n                    size: parseIntOrUndefined(\n                      request.headers.get(\"content-length\")\n                    ),\n                  },\n                },\n              },\n            ],\n          },\n        },\n      };\n\n      // important to only have on batcher per API key\n      let batcher: BatchDispatch<ReadmeMetricsIngestPayload> =\n        batcherMap[options.apiKey];\n\n      if (!batcher) {\n        const apiKey = options.apiKey;\n\n        batcher = new BatchDispatch<ReadmeMetricsIngestPayload>(\n          `readme-metering-inbound-policy`,\n          10,\n          async (entries) => {\n            try {\n              const url = options.url ?? \"https://metrics.readme.io/request\";\n              const result = await internals.fetch(url, {\n                method: \"POST\",\n                body: JSON.stringify(entries),\n                headers: {\n                  \"content-type\": \"application/json\",\n                  authorization: `Basic ${btoa(apiKey + \":\")}`, // yes, readme have weird auth\n                },\n              });\n              if (result.status !== 202) {\n                context.log.error(\n                  `Unexpected response in ReadmeMeteringInboundPolicy '${policyName}'. ${\n                    result.status\n                  }: '${await result.text()}'`\n                );\n              }\n            } catch (err) {\n              context.log.error(\n                `Error in ReadmeMeteringInboundPolicy '${policyName}': '${err.message}'`\n              );\n              throw err;\n            }\n          }\n        );\n        batcherMap[apiKey] = batcher;\n      }\n\n      batcher.enqueue(data);\n      context.waitUntil(batcher.waitUntilFlushed());\n    } catch (err) {\n      context.log.error(err);\n    }\n  });\n\n  return request;\n}\n", "import { ConfigurationError } from \"../../errors\";\nimport { InboundPolicyHandler } from \"../../policies\";\nimport { ZuploRequest } from \"../../request\";\nimport { RemoveHeadersInboundPolicyOptions } from \"./options\";\n\nexport { RemoveHeadersInboundPolicyOptions };\n\n/**\n * Remove headers from the incoming request.\n *\n * @title Remove Request Headers\n * @public\n * @param request - The ZuploRequest\n * @param context - The ZuploContext\n * @param options - The policy options set in policies.json\n * @param policyName - The name of the policy as set in policies.json\n * @returns A Request or a Response\n */\nexport const RemoveHeadersInboundPolicy: InboundPolicyHandler<\n  RemoveHeadersInboundPolicyOptions\n> = async (request, context, options, policyName) => {\n  const names = options?.headers;\n\n  if (!names || !Array.isArray(names) || names.length === 0) {\n    throw new ConfigurationError(\n      `RemoveHeadersInboundPolicy '${policyName}' options.headers must be a non-empty string array of header names`\n    );\n  }\n\n  const headers = new Headers(request.headers);\n  names.forEach((key) => {\n    headers.delete(key);\n  });\n\n  const newRequest = new ZuploRequest(request, {\n    headers,\n  });\n\n  return newRequest;\n};\n", "import { ConfigurationError } from \"../../errors\";\nimport { OutboundPolicyHandler } from \"../../policies\";\nimport { RemoveHeadersOutboundPolicyOptions } from \"./options\";\n\nexport { RemoveHeadersOutboundPolicyOptions };\n\n/**\n * Remove configured headers from the outgoing response.\n *\n * @title Remove Response Headers\n * @public\n * @param request - The ZuploRequest\n * @param context - The ZuploContext\n * @param options - The policy options set in policies.json\n * @param policyName - The name of the policy as set in policies.json\n * @returns A Request or a Response\n */\nexport const RemoveHeadersOutboundPolicy: OutboundPolicyHandler<\n  RemoveHeadersOutboundPolicyOptions\n> = async (response, request, context, options, policyName) => {\n  const names = options?.headers;\n\n  if (!names || !Array.isArray(names) || names.length === 0) {\n    throw new ConfigurationError(\n      `RemoveHeadersOutboundPolicy '${policyName}' options.headers must be a non-empty string array of header names`\n    );\n  }\n\n  const headers = new Headers(response.headers);\n  names.forEach((key) => {\n    headers.delete(key);\n  });\n\n  const newResponse = new Response(response.body, {\n    headers,\n    status: response.status,\n    statusText: response.statusText,\n  });\n\n  return newResponse;\n};\n", "import { ConfigurationError } from \"../../errors\";\nimport { InboundPolicyHandler } from \"../../policies\";\nimport { ZuploRequest } from \"../../request\";\nimport { RemoveQueryParamsInboundPolicyOptions } from \"./options\";\n\nexport { RemoveQueryParamsInboundPolicyOptions };\n\n/**\n * Remove query parameters from the incoming request\n *\n * @title Remove Query Parameters\n * @public\n * @param request - The ZuploRequest\n * @param context - The ZuploContext\n * @param options - The policy options set in policies.json\n * @param policyName - The name of the policy as set in policies.json\n * @returns A Request or a Response\n */\nexport const RemoveQueryParamsInboundPolicy: InboundPolicyHandler<\n  RemoveQueryParamsInboundPolicyOptions\n> = async (request, context, options, policyName) => {\n  // NOTE - unlike headers, we do not treat query params as case insensitive\n  // see https://stackoverflow.com/questions/24699643/are-query-string-keys-case-sensitive\n  const names = options.params;\n\n  if (!names || !Array.isArray(names) || names.length === 0) {\n    throw new ConfigurationError(\n      `RemoveQueryParamsInboundPolicy '${policyName}' options.params must be a non-empty string array of header names`\n    );\n  }\n\n  const url = new URL(request.url);\n  names.forEach((n) => {\n    url.searchParams.delete(n);\n  });\n\n  const newRequest = new ZuploRequest(url.toString(), request);\n\n  return newRequest;\n};\n", "import { OutboundPolicyHandler } from \"../../policies\";\nimport { ReplaceStringOutboundPolicyOptions } from \"./options\";\n\nexport { ReplaceStringOutboundPolicyOptions };\n\n/**\n * Replace a string in the incoming request body\n *\n * @title Replace String in Response Body\n * @public\n * @param request - The ZuploRequest\n * @param context - The ZuploContext\n * @param options - The policy options set in policies.json\n * @param policyName - The name of the policy as set in policies.json\n * @returns A Request or a Response\n */\nexport const ReplaceStringOutboundPolicy: OutboundPolicyHandler<\n  ReplaceStringOutboundPolicyOptions\n> = async (response, request, context, options) => {\n  const body = await response.text();\n\n  const replaceFragment =\n    options.mode === \"regexp\" ? new RegExp(options.match, \"gm\") : options.match;\n\n  const content = body.replaceAll(replaceFragment, options.replaceWith);\n\n  return new Response(content, {\n    headers: response.headers,\n    status: response.status,\n    statusText: response.statusText,\n  });\n};\n", "import { InboundPolicyHandler } from \"../../policies\";\nimport { RequestSizeLimitInboundPolicyOptions } from \"./options\";\n\nexport { RequestSizeLimitInboundPolicyOptions };\n\nconst payloadTooLarge = () => {\n  return new Response(`Maximum request size exceeded`, {\n    status: 413,\n    statusText: \"Payload Too Large\",\n  });\n};\n\n/**\n * Enforces a maximum size in bytes of the incoming request.\n *\n * @title Request Size Limit\n * @public\n * @param request - The ZuploRequest\n * @param context - The ZuploContext\n * @param options - The policy options set in policies.json\n * @param policyName - The name of the policy as set in policies.json\n * @returns A Request or a Response\n */\nexport const RequestSizeLimitInboundPolicy: InboundPolicyHandler<\n  RequestSizeLimitInboundPolicyOptions\n> = async (request, context, options) => {\n  const trustContentLengthHeader = options.trustContentLengthHeader ?? false;\n\n  // Nothing to check on GET or HEAD requests, no body - just return\n  if ([\"GET\", \"HEAD\"].includes(request.method)) {\n    return request;\n  }\n\n  const contentLengthHeader = request.headers.get(\"content-length\");\n  const contentLength =\n    contentLengthHeader !== null ? parseInt(contentLengthHeader) : undefined;\n\n  // If the content-length header is present and exceeds the max size: Bad Request\n  // No need to verify the body stream (more efficient)\n  if (\n    contentLength &&\n    !isNaN(contentLength) &&\n    contentLength > options.maxSizeInBytes\n  ) {\n    return payloadTooLarge();\n  }\n\n  // If we are told to trust the content-length header (and it is present) we can skip verification\n  // and return the request to continue...\n  if (contentLength && trustContentLengthHeader) {\n    return request;\n  }\n\n  // Now we must verify the body length\n  const clone = request.clone();\n  // TODO - this is potentially inefficient wrt memory,\n  // we should read the stream until it exceeds the max size (and no more)\n  // We should probably use a TransformStream to read to the max point\n  // and abort then - https://developer.mozilla.org/en-US/docs/Web/API/TransformStream\n  // this will minimize memory footprint (although clone might require it to be read fully into memory too)\n  const body = await clone.text();\n  const len = body.length;\n  if (len > options.maxSizeInBytes) {\n    return payloadTooLarge();\n  }\n\n  return request;\n};\n", "export function getRawOperationDataIdentifierName(\n  oasFileName: string,\n  path: string,\n  operation: string\n): string {\n  return `_${sanitizedIdentifierName(\n    oasFileName + \"_\" + path + \"_\" + operation\n  )}`;\n}\n\nexport function getIdForParameterSchema(\n  path: string,\n  operation: string,\n  type: string,\n  name: string\n): string {\n  return (\n    `_${sanitizedIdentifierName(path.toLowerCase())}` +\n    \"_\" +\n    operation.toLowerCase() +\n    \"_\" +\n    type.toLowerCase() +\n    `_${name.toLowerCase()}`\n  );\n}\n\nexport function getIdForRequestBodySchema(\n  path: string,\n  operation: string,\n  contentType: string\n): string {\n  return (\n    `_${sanitizedIdentifierName(path.toLowerCase())}` +\n    \"_\" +\n    operation.toLowerCase() +\n    \"_\" +\n    \"rb\" +\n    `_${sanitizedIdentifierName(contentType.toLowerCase())}`\n  );\n}\n\nexport function getIdForRefSchema(oasFileName: string, ref: string) {\n  return (\n    `_${sanitizedIdentifierName(oasFileName)}` +\n    \"_\" +\n    `_${sanitizedIdentifierName(ref)}`\n  );\n}\n\nexport function sanitizedIdentifierName(name: string): string {\n  const sanitizedString: string[] = [];\n  for (let i = 0; i < name.length; i++) {\n    const charCode = name.charCodeAt(i);\n\n    if (\n      (charCode >= \"0\".charCodeAt(0) && charCode <= \"9\".charCodeAt(0)) ||\n      (charCode >= \"A\".charCodeAt(0) && charCode <= \"Z\".charCodeAt(0)) ||\n      (charCode >= \"a\".charCodeAt(0) && charCode <= \"z\".charCodeAt(0))\n    ) {\n      sanitizedString.push(name.charAt(i));\n    } else {\n      sanitizedString.push(\"_\");\n    }\n  }\n\n  return sanitizedString.join(\"\");\n}\n", "import { ErrorObject } from \"ajv\";\nimport { Gateway } from \"../../gateway\";\nimport { ZuploContext } from \"../../index.worker\";\nimport { LogLevel } from \"../../logging/interfaces\";\nimport { ValidationOptions } from \"../../policies/request-validation-inbound/policy\";\nimport { getIdForParameterSchema } from \"../open-api-utils\";\n\ninterface ParameterObject {\n  name: string;\n  location: string;\n  required?: boolean;\n  deprecated?: boolean;\n  allowEmptyValue?: boolean;\n  id: string;\n}\ninterface ValidationResult {\n  isValid: boolean;\n  errors: string[];\n  invalidValues: string[];\n}\n\nexport const getParametersForOperation = (\n  context: ZuploContext\n): ParameterObject[] => {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const openApi = context.route.raw<any>();\n  if (!openApi.parameters) {\n    return [];\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const methodParams: ParameterObject[] = openApi.parameters.map((p: any) => {\n    return {\n      name: p.name,\n      location: p.in,\n      required: p.required,\n      deprecated: p.deprecated,\n      allowEmptyValue: p.allowEmptyValue,\n    };\n  });\n\n  return methodParams;\n};\n\nexport const validateParameters = (\n  parametersFromSpec: ParameterObject[],\n  parametersFromRequest: Record<string, string>,\n  path: string,\n  method: string,\n  location: \"query\" | \"path\" | \"header\"\n): ValidationResult => {\n  const errors: string[] = [];\n  let isValid = true;\n  const invalidValues: string[] = [];\n\n  parametersFromSpec.forEach((p) => {\n    const isRequiredParam = p.required || location === \"path\";\n    if (isRequiredParam && !parametersFromRequest[p.name]) {\n      isValid = false;\n      errors.push(`Required ${location} parameter '${p.name}' not found`);\n    } else if (!isRequiredParam && !parametersFromRequest[p.name]) {\n      // No need to do anything here, isValid will be determined by the\n      // evaluation of other params\n    } else {\n      const paramValidationId = getIdForParameterSchema(\n        path,\n        method,\n        location,\n        p.name\n      );\n      const paramValidator =\n        Gateway.instance.schemaValidator[paramValidationId];\n      const isValidParams = paramValidator(parametersFromRequest[p.name]);\n      const validationErrors = getErrorsFromValidator(paramValidator.errors);\n\n      if (!isValidParams) {\n        isValid = false;\n        invalidValues.push(\n          `${location} parameter: ${p.name} : ${parametersFromRequest[p.name]}`\n        );\n        errors.push(\n          `Invalid value for ${location} parameter: '${\n            p.name\n          }' ${validationErrors.join(\", \")}`\n        );\n      }\n    }\n  });\n\n  return { isValid, invalidValues, errors } as ValidationResult;\n};\n\nexport const logErrors = (\n  context: ZuploContext,\n  logLevel: LogLevel,\n  logMessage: string,\n  invalidValues: string[],\n  errors: string[]\n) => {\n  if (invalidValues) {\n    context.log[logLevel](logMessage, invalidValues, errors);\n  } else {\n    context.log[logLevel](logMessage, errors);\n  }\n};\n\nexport const shouldLog = (options: ValidationOptions): boolean => {\n  return options === \"log-only\" || options === \"reject-and-log\";\n};\n\nexport const shouldReject = (options: ValidationOptions): boolean => {\n  return options === \"reject-only\" || options === \"reject-and-log\";\n};\n\nexport const getErrorsFromValidator = (\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  errors: ErrorObject<string, Record<string, any>, unknown>[] | null | undefined\n): string[] => {\n  return (\n    errors?.map((err) => {\n      if (err.instancePath === undefined || err.instancePath === \"\") {\n        return err.message ?? \"Unknown validation error\";\n      } else {\n        return err.instancePath.replace(\"/\", \"\") + \" \" + err.message;\n      }\n    }) ?? [\"Unknown validation error\"]\n  ); // this shouldn't happen, but just in case\n};\n", "import { Gateway } from \"../../gateway\";\nimport { LogLevel, ZuploContext, ZuploRequest } from \"../../index.worker\";\nimport { RequestValidationInboundPolicyOptions } from \"../../policies/request-validation-inbound/policy\";\nimport { HttpProblems } from \"../../problem-responses/http-problems\";\nimport { getIdForRequestBodySchema } from \"../open-api-utils\";\nimport {\n  getErrorsFromValidator,\n  logErrors,\n  shouldLog,\n  shouldReject,\n} from \"./common\";\n\nexport async function handleBodyValidation(\n  context: ZuploContext,\n  request: ZuploRequest,\n  options: RequestValidationInboundPolicyOptions\n): Promise<Promise<Response> | undefined> {\n  if (!options.validateBody || options.validateBody === \"none\") {\n    return;\n  }\n  let body: unknown;\n\n  try {\n    const clone = request.clone();\n    body = await clone.json();\n  } catch (error) {\n    const errorMessage = `Error in request body for method : ${\n      request.method\n    } in route: ${context.route.path} with content-type: ${request.headers.get(\n      \"Content-Type\"\n    )}`;\n    const response = HttpProblems.badRequest(request, context, {\n      detail: `${errorMessage}, see errors property for more details`,\n      errors: `${error}`,\n    });\n    if (shouldLog(options.validateBody)) {\n      logErrors(\n        context,\n        (options.logLevel ?? \"info\") as LogLevel,\n        errorMessage,\n        [body as string],\n        error\n      );\n    }\n\n    if (shouldReject(options.validateBody)) {\n      return response;\n    }\n  }\n\n  if (!request.headers.get(\"Content-Type\")) {\n    const errorMessage = `No content-type header defined in incoming request to ${request.method} in route: ${context.route.path}`;\n    const response = HttpProblems.badRequest(request, context, {\n      detail: errorMessage,\n    });\n\n    if (shouldLog(options.validateBody)) {\n      logErrors(\n        context,\n        (options.logLevel ?? \"info\") as LogLevel,\n        errorMessage,\n        [body as string],\n        [errorMessage]\n      );\n    }\n\n    if (shouldReject(options.validateBody)) {\n      return response;\n    } else {\n      // we don't have to proceed further since we don't have a content-type value in incoming request to fetch the schema\n      return;\n    }\n  }\n\n  let contentType = request.headers.get(\"Content-Type\") as string;\n\n  // Handle cases where content-type has charset or other params\n  // Example: Content-Type = \"application/json; charset=utf-8\"\n  const indexOfSemiColon = contentType.indexOf(\";\");\n  if (indexOfSemiColon > -1) {\n    contentType = contentType.substring(0, indexOfSemiColon);\n  }\n\n  const id = getIdForRequestBodySchema(\n    context.route.path,\n    request.method,\n    contentType\n  );\n  const schemaValidator = Gateway.instance.schemaValidator[id];\n\n  // This means that there was no schema defined in open-api doc for this route/method/content-type\n  if (!schemaValidator) {\n    const errorMessage = `No schema defined for method: ${\n      request.method\n    } in route: ${context.route.path} with content-type: ${request.headers.get(\n      \"Content-Type\"\n    )}`;\n    const response = HttpProblems.badRequest(request, context, {\n      detail: errorMessage,\n    });\n\n    if (shouldLog(options.validateBody)) {\n      logErrors(\n        context,\n        (options.logLevel ?? \"info\") as LogLevel,\n        errorMessage,\n        [body as string],\n        [errorMessage]\n      );\n    }\n\n    if (shouldReject(options.validateBody)) {\n      return response;\n    } else {\n      // we don't have to proceed further since we don't have a schemaValidator\n      return;\n    }\n  }\n\n  const isValid = schemaValidator(body);\n  if (isValid) {\n    return;\n  }\n\n  const schemaErrors = schemaValidator.errors;\n  const logMessage = \"Request body did not pass validation\";\n  const errors = getErrorsFromValidator(schemaErrors);\n  const response = HttpProblems.badRequest(request, context, {\n    detail: `${logMessage}, see errors property for more details`,\n    errors,\n  });\n\n  if (shouldLog(options.validateBody)) {\n    logErrors(\n      context,\n      (options.logLevel ?? \"info\") as LogLevel,\n      logMessage,\n      [body as string],\n      errors\n    );\n  }\n\n  if (shouldReject(options.validateBody)) {\n    return response;\n  }\n}\n", "import { LogLevel, ZuploContext, ZuploRequest } from \"../../index.worker\";\nimport { RequestValidationInboundPolicyOptions } from \"../../policies/request-validation-inbound/policy\";\nimport { HttpProblems } from \"../../problem-responses/http-problems\";\nimport {\n  getParametersForOperation,\n  logErrors,\n  shouldLog,\n  shouldReject,\n  validateParameters,\n} from \"./common\";\n\nexport function handleHeadersValidation(\n  context: ZuploContext,\n  request: ZuploRequest,\n  options: RequestValidationInboundPolicyOptions\n): Promise<Response> | undefined {\n  if (!options.validateHeaders || options.validateHeaders === \"none\") {\n    return;\n  }\n  const headers: Record<string, string> = {};\n  request.headers.forEach((value, name) => {\n    headers[name] = value;\n  });\n\n  const parameters = getParametersForOperation(context);\n  const result = validateParameters(\n    parameters.filter((p) => p.location === \"header\"),\n    headers,\n    context.route.path,\n    request.method.toLowerCase(),\n    \"header\"\n  );\n\n  if (!result.isValid) {\n    const logMessage = \"Header validation failed\";\n\n    const response = HttpProblems.badRequest(request, context, {\n      detail: `${logMessage}, see errors property for more details`,\n      errors: result.errors,\n    });\n\n    if (shouldLog(options.validateHeaders)) {\n      logErrors(\n        context,\n        (options.logLevel ?? \"info\") as LogLevel,\n        logMessage,\n        result.invalidValues,\n        result.errors\n      );\n    }\n\n    if (shouldReject(options.validateHeaders)) {\n      return response;\n    }\n  }\n}\n", "import { LogLevel, ZuploContext, ZuploRequest } from \"../../index.worker\";\nimport { RequestValidationInboundPolicyOptions } from \"../../policies/request-validation-inbound/policy\";\nimport { HttpProblems } from \"../../problem-responses/http-problems\";\nimport {\n  getParametersForOperation,\n  logErrors,\n  shouldLog,\n  shouldReject,\n  validateParameters,\n} from \"./common\";\n\nexport function handlePathParameterValidation(\n  context: ZuploContext,\n  request: ZuploRequest,\n  options: RequestValidationInboundPolicyOptions\n): Promise<Response> | undefined {\n  if (\n    !options.validatePathParameters ||\n    options.validatePathParameters === \"none\"\n  ) {\n    return;\n  }\n\n  const parameters = getParametersForOperation(context);\n  const result = validateParameters(\n    parameters.filter((p) => p.location === \"path\"),\n    request.params,\n    context.route.path,\n    request.method.toLowerCase(),\n    \"path\"\n  );\n\n  if (!result.isValid) {\n    const logMessage = \"Path parameters validation failed\";\n\n    const response = HttpProblems.badRequest(request, context, {\n      detail: `${logMessage}, see errors property for more details`,\n      errors: result.errors,\n    });\n\n    if (shouldLog(options.validatePathParameters)) {\n      logErrors(\n        context,\n        (options.logLevel ?? \"info\") as LogLevel,\n        logMessage,\n        result.invalidValues,\n        result.errors\n      );\n    }\n\n    if (shouldReject(options.validatePathParameters)) {\n      return response;\n    }\n  }\n}\n", "import { LogLevel, ZuploContext, ZuploRequest } from \"../../index.worker\";\nimport { RequestValidationInboundPolicyOptions } from \"../../policies/request-validation-inbound/policy\";\nimport { HttpProblems } from \"../../problem-responses/http-problems\";\nimport {\n  getParametersForOperation,\n  logErrors,\n  shouldLog,\n  shouldReject,\n  validateParameters,\n} from \"./common\";\n\nexport function handleQueryParameterValidation(\n  context: ZuploContext,\n  request: ZuploRequest,\n  options: RequestValidationInboundPolicyOptions\n): Promise<Response> | undefined {\n  if (\n    !options.validateQueryParameters ||\n    options.validateQueryParameters === \"none\"\n  ) {\n    return;\n  }\n\n  const parameters = getParametersForOperation(context);\n  const result = validateParameters(\n    parameters.filter((p) => p.location === \"query\"),\n    request.query,\n    context.route.path,\n    request.method.toLowerCase(),\n    \"query\"\n  );\n\n  if (!result.isValid) {\n    const logMessage = \"Query parameters validation failed\";\n\n    const response = HttpProblems.badRequest(request, context, {\n      detail: `${logMessage}, see errors property for more details`,\n      errors: result.errors,\n    });\n\n    if (shouldLog(options.validateQueryParameters)) {\n      logErrors(\n        context,\n        (options.logLevel ?? \"info\") as LogLevel,\n        logMessage,\n        result.invalidValues,\n        result.errors\n      );\n    }\n\n    if (shouldReject(options.validateQueryParameters)) {\n      return response;\n    }\n  }\n}\n", "/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { InboundPolicyHandler } from \"../../policies\";\nimport { handleBodyValidation } from \"../../utils/request-validation/body\";\nimport { handleHeadersValidation } from \"../../utils/request-validation/headers\";\nimport { handlePathParameterValidation } from \"../../utils/request-validation/path-parameters\";\nimport { handleQueryParameterValidation } from \"../../utils/request-validation/query-parameters\";\nimport {\n  RequestValidationInboundPolicyOptions,\n  ValidationOptions,\n} from \"./options\";\n\nexport { RequestValidationInboundPolicyOptions, ValidationOptions };\n\n/**\n * Validate inbound requests based on Open API specification\n *\n * @remarks\n * The Request Validation policy is used to validate incoming requests based on\n * schemas in OpenAPI specifications.\n *\n * When configured, any requests that do not conform to your OpenAPI schema will be\n * rejected with a `400: Bad Request` response containing a detailed error message\n * (in JSON) explaining why the request was not accepted.\n *\n * @title Request Validation\n * @public\n * @param request - The ZuploRequest\n * @param context - The ZuploContext\n * @param options - The policy options set in policies.json\n * @param policyName - The name of the policy as set in policies.json\n * @returns A Request or a Response\n */\nexport const RequestValidationInboundPolicy: InboundPolicyHandler<\n  RequestValidationInboundPolicyOptions\n> = async (request, context, options) => {\n  let responseResult = handleQueryParameterValidation(\n    context,\n    request,\n    options\n  );\n  if (responseResult !== undefined) {\n    return responseResult;\n  }\n\n  responseResult = handlePathParameterValidation(context, request, options);\n  if (responseResult !== undefined) {\n    return responseResult;\n  }\n\n  responseResult = handleHeadersValidation(context, request, options);\n  if (responseResult !== undefined) {\n    return responseResult;\n  }\n\n  const responseResultForBody = await handleBodyValidation(\n    context,\n    request,\n    options\n  );\n  if (responseResultForBody !== undefined) {\n    return responseResultForBody;\n  }\n\n  return request;\n};\n\n/**\n * @deprecated Use RequestValidationInboundPolicy instead\n */\nexport const SchemaBasedRequestValidation = RequestValidationInboundPolicy;\n", "import { ConfigurationError } from \"../../errors\";\nimport { InboundPolicyHandler } from \"../../policies\";\nimport { HttpProblems } from \"../../problem-responses/http-problems\";\nimport { RequireOriginInboundPolicyOptions } from \"./options\";\n\nexport { RequireOriginInboundPolicyOptions };\n\n/**\n * Sets an allow-list for an origin header\n *\n * @remarks\n * The Require Origin policy is used to enforce that the client is sending an\n * `origin` header that matches your allow-list specified in the policy options.\n *\n * This is useful if you want to stop any browser traffic from different domains.\n *\n * However, it is important to note that it does not guarantee that traffic is only\n * coming from a browser. Somebody could simulate a browser request from a backend\n * server and set any origin they like.\n *\n * If the incoming origin is missing, or not allowed - a 400 Forbidden Problem\n * Response will be sent to the client. You can customize the `detail` property in\n * the policy options.\n *\n * @title Require Origin\n * @public\n * @param request - The ZuploRequest\n * @param context - The ZuploContext\n * @param options - The policy options set in policies.json\n * @param policyName - The name of the policy as set in policies.json\n * @returns A Request or a Response\n */\nexport const RequireOriginInboundPolicy: InboundPolicyHandler<\n  RequireOriginInboundPolicyOptions\n> = async (request, context, options, policyName) => {\n  if (options.origins === undefined || options.origins.length === 0) {\n    throw new ConfigurationError(\n      `RequireOriginInboundPolicy '${policyName}' configuration error - no allowed origins specified`\n    );\n  }\n\n  let origins: string[] =\n    typeof options.origins === \"string\"\n      ? options.origins.split(\",\")\n      : options.origins;\n\n  // trim any whitespace\n  origins = origins.map((o) => o.trim());\n\n  const origin = request.headers.get(\"origin\");\n\n  if (!origin || !origins.includes(origin)) {\n    const detail = options.failureDetail ?? \"Forbidden\";\n    return HttpProblems.forbidden(request, context, { detail });\n  }\n\n  return request;\n};\n", "import { InboundPolicyHandler } from \"../../policies\";\nimport { ZuploRequest } from \"../../request\";\nimport { SetBodyInboundPolicyOptions } from \"./options\";\n\nexport { SetBodyInboundPolicyOptions };\n\n/**\n * Sets the body of the request in the inbound pipeline - make sure to convert a GET/HEAD request to another method when using this policy.\n *\n * @remarks\n * The Set Body policy allows you to set or override the incoming request body.\n * {@link https://zuplo.com/docs/articles/zp-body-removed|GET or HEAD requests do not support bodies on Zuplo},\n * so be sure to use the {@link https://zuplo.com/docs/policies/change-method-inbound|Change Method}\n * policy to update the method to a `POST` or whatever is appropriate. You might\n * also need to use the {@link https://zuplo.com/docs/policies/set-headers-inbound|Set Header} policy to\n * set a `content-type`.\n *\n * @title Set Body\n * @public\n * @param request - The ZuploRequest\n * @param context - The ZuploContext\n * @param options - The policy options set in policies.json\n * @param policyName - The name of the policy as set in policies.json\n * @returns A Request or a Response\n */\nexport const SetBodyInboundPolicy: InboundPolicyHandler<\n  SetBodyInboundPolicyOptions\n> = async (request, context, options) => {\n  return new ZuploRequest(request, {\n    body: options.body,\n  });\n};\n", "import { ConfigurationError } from \"../../errors\";\nimport { InboundPolicyHandler } from \"../../policies\";\nimport { ZuploRequest } from \"../../request\";\nimport { SetHeadersInboundPolicyOptions } from \"./options\";\n\nexport { SetHeadersInboundPolicyOptions };\n\n/**\n * Adds or sets headers on the incoming request.\n *\n * @remarks\n * The set header policy adds a header to the request in the inbound pipeline. This\n * can be used to set a security header required by the downstream service.\n *\n * @title Add or Set Request Headers\n * @public\n * @param request - The ZuploRequest\n * @param context - The ZuploContext\n * @param options - The policy options set in policies.json\n * @param policyName - The name of the policy as set in policies.json\n * @returns A Request or a Response\n */\n\nexport const SetHeadersInboundPolicy: InboundPolicyHandler<\n  SetHeadersInboundPolicyOptions\n> = async (request, context, options, policyName) => {\n  const setHeaders = options.headers;\n\n  if (!setHeaders || !Array.isArray(setHeaders) || setHeaders.length == 0) {\n    throw new ConfigurationError(\n      `SetHeadersInboundPolicy '${policyName}' options.headers must be a valid array of { name, value }`\n    );\n  }\n\n  const newHeaders = new Headers(request.headers);\n\n  setHeaders.forEach((h) => {\n    if (!h.name || h.name.length === 0) {\n      throw new ConfigurationError(\n        `SetHeadersInboundPolicy '${policyName}' each option.headers[] entry must have a name property`\n      );\n    }\n    // We default overwrite to true\n    const overwrite = h.overwrite === undefined ? true : h.overwrite;\n    const hasHeader = newHeaders.has(h.name);\n    if (!hasHeader || overwrite) {\n      newHeaders.set(h.name, h.value);\n    }\n  });\n\n  const newRequest = new ZuploRequest(request, {\n    headers: newHeaders,\n  });\n\n  return newRequest;\n};\n", "import { ConfigurationError } from \"../../errors\";\nimport { OutboundPolicyHandler } from \"../../policies\";\nimport { SetHeadersOutboundPolicyOptions } from \"./options\";\n\nexport { SetHeadersOutboundPolicyOptions };\n\n/**\n * Adds or sets headers on the on the outgoing response.\n *\n * @title Set Headers\n * @public\n * @param request - The ZuploRequest\n * @param context - The ZuploContext\n * @param options - The policy options set in policies.json\n * @param policyName - The name of the policy as set in policies.json\n * @returns A Request or a Response\n */\nexport const SetHeadersOutboundPolicy: OutboundPolicyHandler<\n  SetHeadersOutboundPolicyOptions\n> = async (response, request, context, options, policyName) => {\n  const setHeaders = options.headers;\n\n  if (!setHeaders || !Array.isArray(setHeaders) || setHeaders.length == 0) {\n    throw new ConfigurationError(\n      `SetHeadersOutboundPolicy '${policyName}' options.headers must be a valid array of { name, value }`\n    );\n  }\n\n  const newHeaders = new Headers(response.headers);\n\n  setHeaders.forEach((h) => {\n    if (!h.name || h.name.length === 0) {\n      throw new ConfigurationError(\n        `SetHeadersOutboundPolicy '${policyName}' each option.headers[] entry must have a name property`\n      );\n    }\n    // We default overwrite to true\n    const overwrite = h.overwrite === undefined ? true : h.overwrite;\n    const hasHeader = newHeaders.has(h.name);\n    if (!hasHeader || overwrite) {\n      newHeaders.set(h.name, h.value);\n    }\n  });\n\n  const newResponse = new Response(response.body, {\n    headers: newHeaders,\n    status: response.status,\n    statusText: response.statusText,\n  });\n\n  return newResponse;\n};\n", "import { ConfigurationError } from \"../../errors\";\nimport { InboundPolicyHandler } from \"../../policies\";\nimport { ZuploRequest } from \"../../request\";\nimport { SetQueryParamsInboundPolicyOptions } from \"./options\";\n\nexport { SetQueryParamsInboundPolicyOptions };\n\n/**\n * Adds or sets query parameters on the incoming request.\n *\n * @title Add or Set Query Parameters\n * @public\n * @param request - The ZuploRequest\n * @param context - The ZuploContext\n * @param options - The policy options set in policies.json\n * @param policyName - The name of the policy as set in policies.json\n * @returns A Request or a Response\n */\nexport const SetQueryParamsInboundPolicy: InboundPolicyHandler<\n  SetQueryParamsInboundPolicyOptions\n> = async (request, context, options, policyName) => {\n  // NOTE - unlike headers, we do not treat query params as case insensitive\n  // see https://stackoverflow.com/questions/24699643/are-query-string-keys-case-sensitive\n  const setParams = options.params;\n\n  if (!setParams || !Array.isArray(setParams) || setParams.length == 0) {\n    throw new ConfigurationError(\n      `SetQueryParamsInboundPolicy '${policyName}' options.params must be a valid array of { name, value }`\n    );\n  }\n\n  const url = new URL(request.url);\n\n  setParams.forEach((p) => {\n    if (!p.name || p.name.length === 0) {\n      throw new ConfigurationError(\n        `SetQueryParamsInboundPolicy '${policyName}' each option.params[] entry must have a name property`\n      );\n    }\n    // We default overwrite to true\n    const overwrite = p.overwrite === undefined ? true : p.overwrite;\n    const hasParam = url.searchParams.has(p.name);\n    if (!hasParam || overwrite) {\n      url.searchParams.set(p.name, p.value);\n    }\n  });\n\n  const newRequest = new ZuploRequest(url.toString(), request);\n\n  return newRequest;\n};\n", "import { OutboundPolicyHandler } from \"../../policies\";\nimport { SetStatusOutboundPolicyOptions } from \"./options\";\n\nexport { SetStatusOutboundPolicyOptions };\n\n/**\n * Sets the status code on the on the outgoing response.\n *\n * @title Set Status Code\n * @public\n * @param request - The ZuploRequest\n * @param context - The ZuploContext\n * @param options - The policy options set in policies.json\n * @param policyName - The name of the policy as set in policies.json\n * @returns A Request or a Response\n */\nexport const SetStatusOutboundPolicy: OutboundPolicyHandler<\n  SetStatusOutboundPolicyOptions\n> = async (response, request, context, options, policyName) => {\n  if (\n    !options.status ||\n    isNaN(options.status) ||\n    options.status < 100 ||\n    options.status > 599\n  ) {\n    throw new Error(\n      `Invalid SetStatusOutboundPolicy '${policyName}' - status must be a valid number between 100 and 599, not '${options.status}'`\n    );\n  }\n\n  const newResponse = new Response(response.body, {\n    headers: response.headers,\n    status: options.status,\n    statusText: options.statusText ?? response.statusText,\n  });\n\n  return newResponse;\n};\n", "import { ConfigurationError } from \"../../errors\";\nimport { InboundPolicyHandler } from \"../../policies\";\nimport { SleepInboundPolicyOptions } from \"./options\";\n\nexport { SleepInboundPolicyOptions };\n\nconst sleep = async (ms: number) => {\n  const promise = new Promise((res) => {\n    setTimeout(res, ms);\n  });\n  return promise;\n};\n\n/**\n * Add a delay to the incoming request. Useful for testing.\n *\n * @title Sleep / Delay\n * @public\n * @param request - The ZuploRequest\n * @param context - The ZuploContext\n * @param options - The policy options set in policies.json\n * @param policyName - The name of the policy as set in policies.json\n * @returns A Request or a Response\n */\nexport const SleepInboundPolicy: InboundPolicyHandler<\n  SleepInboundPolicyOptions\n> = async (request, context, options, policyName) => {\n  if (!options || options.sleepInMs === undefined || isNaN(options.sleepInMs)) {\n    throw new ConfigurationError(\n      `SleepInboundPolicy '${policyName} must have a valid options.sleepInMs value`\n    );\n  }\n\n  await sleep(options.sleepInMs);\n\n  return request;\n};\n", "import { RuntimeError, SystemError } from \"../../errors\";\nimport { InboundPolicyHandler } from \"../../policies\";\nimport { HttpProblems } from \"../../problem-responses/http-problems\";\nimport { ZuploRequest } from \"../../request\";\nimport { optionValidator } from \"../../utils/validator\";\nimport { OpenIdJwtInboundPolicyOptions } from \"../open-id-jwt-auth-inbound/options\";\nimport { OpenIdJwtInboundPolicy } from \"../open-id-jwt-auth-inbound/policy\";\nimport { SupabaseJwtInboundPolicyOptions } from \"./options\";\n\nexport { SupabaseJwtInboundPolicyOptions };\n\n/**\n * The Supabase JWT Authentication policy supports user JWT tokens created by Supabase.\n *\n * @remarks\n * The Supabase JWT Authentication policy allows you to authenticate incoming\n * requests using a token created by {@link https://supabase.com|supabase.com}.\n *\n * When configured, you can have Zuplo check incoming requests for a JWT token and\n * automatically populate the `ZuploRequest`'s `user` property with a user object.\n *\n * This `user` object will have a `sub` property - taking the `sub` id from the JWT\n * token. It will also have a `data` property populated by other data returned in\n * the JWT token - including all your claims, `user_metadata` and `app_metadata`.\n *\n * You can also require specific claims to have specific values to allow\n * authentication to complete, providing a layer of authorization.\n *\n * @title Supabase JWT Auth\n * @public\n * @param request - The ZuploRequest\n * @param context - The ZuploContext\n * @param options - The policy options set in policies.json\n * @param policyName - The name of the policy as set in policies.json\n * @returns A Request or a Response\n */\nexport const SupabaseJwtInboundPolicy: InboundPolicyHandler<\n  SupabaseJwtInboundPolicyOptions\n> = async (request, context, options, policyName) => {\n  optionValidator(options, policyName)\n    .required(\"secret\", \"string\")\n    .optional(\"allowUnauthenticatedRequests\", \"boolean\")\n    .optional(\"requiredClaims\", \"object\");\n\n  const innerOptions: OpenIdJwtInboundPolicyOptions = {\n    secret: options.secret,\n    allowUnauthenticatedRequests: options.allowUnauthenticatedRequests ?? false,\n  };\n\n  const result = await OpenIdJwtInboundPolicy(\n    request,\n    context,\n    innerOptions,\n    policyName\n  );\n\n  // This is a short circuit, return it\n  if (result instanceof Response) {\n    return result;\n  }\n\n  // this is a request, let's validate any required claims - validate that for type safety downstream\n  if (!(result instanceof ZuploRequest)) {\n    throw new SystemError(\n      `Invalid State - SupabaseJwtInboundPolicy encountered a non-response that wasn't a ZuploRequest type')`\n    );\n  }\n\n  const requiredClaims = options.requiredClaims;\n\n  // no claims required\n  if (!requiredClaims) {\n    return result;\n  }\n\n  // in supabase, claims are always in app_metadata\n  const app_metadata = request.user?.data.app_metadata;\n\n  if (!app_metadata) {\n    throw new RuntimeError(\n      `SupabaseJwtInboundPolicy policy '${policyName}' - has requiredClaims but the JWT token had no app_metadata property`\n    );\n  }\n\n  const keys = Object.keys(requiredClaims);\n  const missingClaims: string[] = [];\n\n  keys.forEach((key) => {\n    // we flex on options for ease of use, if an array specified\n    const requiredClaim = requiredClaims[key];\n    // array mode\n    if (Array.isArray(requiredClaim)) {\n      if (!requiredClaim.includes(app_metadata[key])) {\n        missingClaims.push(key);\n      }\n    }\n    // string mode\n    else {\n      if (requiredClaim !== app_metadata[key]) {\n        missingClaims.push(key);\n      }\n    }\n  });\n\n  if (missingClaims.length > 0) {\n    return HttpProblems.unauthorized(request, context, {\n      detail: `Invalid JWT token - missing valid claims ${missingClaims.join(\n        \", \"\n      )}`,\n    });\n  }\n\n  return result;\n};\n", "import { getPolicyCacheName } from \"../../caches/keys\";\nimport { MemoryZoneReadThroughCache } from \"../../caches/memory-zone-readthrough-cache\";\nimport { RuntimeError } from \"../../errors\";\nimport { ZuploContext } from \"../../index.worker\";\nimport { InboundPolicyHandler } from \"../../policies\";\nimport { fetchRetry } from \"../../utils/retry\";\nimport { optionValidator } from \"../../utils/validator\";\nimport { UpstreamAzureAdServiceAuthInboundPolicyOptions } from \"./options\";\n\nexport { UpstreamAzureAdServiceAuthInboundPolicyOptions };\n\ninterface AccessTokenResult {\n  access_token: string;\n  expires_in: number;\n}\n\n/**\n * Uses Azure Active Directory to add an Authorization header to the request in order to authenticate requests using Azure identity.\n *\n * @remarks\n * This policy adds a `Authorization` header to the upstream request that allows\n * using Azure AD to authenticate requests to your origin server. This is a useful\n * means of securing your origin server so that only your Zuplo gateway can make\n * requests against it.\n *\n * Using this policy allows you to delegate authentication and authorization to\n * your gateway without writing any code on your origin service. For instructions\n * on how to configure Azure AD authentication see\n * {@link https://learn.microsoft.com/en-us/azure/app-service/configure-authentication-provider-aad | Configure your App Service or Azure Functions app to use Azure AD login}.\n *\n * @title Upstream Azure AD Service Auth\n * @public\n * @param request - The ZuploRequest\n * @param context - The ZuploContext\n * @param options - The policy options set in policies.json\n * @param policyName - The name of the policy as set in policies.json\n * @returns A Request or a Response\n */\n\nexport const UpstreamAzureAdServiceAuthInboundPolicy: InboundPolicyHandler<\n  UpstreamAzureAdServiceAuthInboundPolicyOptions\n> = async (request, context, options, policyName) => {\n  optionValidator(options, policyName)\n    .required(\"activeDirectoryTenantId\", \"string\")\n    .required(\"activeDirectoryClientId\", \"string\")\n    .required(\"activeDirectoryClientSecret\", \"string\")\n    .optional(\"tokenRetries\", \"number\")\n    .optional(\"expirationOffsetSeconds\", \"number\");\n\n  const cacheName = await getPolicyCacheName(policyName, options);\n  const cache = new MemoryZoneReadThroughCache<string>(cacheName, context);\n  let accessToken = await cache.get(policyName);\n  if (!accessToken) {\n    const result = await getAccessToken(options, context);\n    cache.put(\n      policyName,\n      result.access_token,\n      result.expires_in - (options.expirationOffsetSeconds ?? 300)\n    );\n    accessToken = result.access_token;\n  }\n\n  request.headers.set(\"Authorization\", `Bearer ${accessToken}`);\n  return request;\n};\n\nasync function getAccessToken(\n  options: UpstreamAzureAdServiceAuthInboundPolicyOptions,\n  context: ZuploContext\n): Promise<AccessTokenResult> {\n  const body = new URLSearchParams({\n    client_id: options.activeDirectoryClientId,\n    scope: `${options.activeDirectoryClientId}/.default`,\n    client_secret: options.activeDirectoryClientSecret,\n    grant_type: \"client_credentials\",\n  });\n\n  const response = await fetchRetry(\n    {\n      retries: options.tokenRetries ?? 3,\n      retryDelayMs: 10,\n    },\n    `https://login.microsoftonline.com/${options.activeDirectoryTenantId}/oauth2/v2.0/token`,\n    {\n      headers: {\n        \"content-type\": \"application/x-www-form-urlencoded\",\n      },\n      method: \"POST\",\n      body,\n    }\n  );\n\n  if (response.status !== 200) {\n    try {\n      const text = await response.text();\n      context.log.error(\"Could not get token from Azure AD\", text);\n    } catch (err) {\n      // Ignore\n    }\n    throw new RuntimeError(\"Could not get token from Azure AD\");\n  }\n\n  const result = await response.json();\n\n  if (\n    result &&\n    typeof result === \"object\" &&\n    \"access_token\" in result &&\n    typeof result.access_token === \"string\" &&\n    \"expires_in\" in result &&\n    typeof result.expires_in === \"number\"\n  ) {\n    return {\n      access_token: result.access_token,\n      expires_in: result.expires_in,\n    };\n  }\n\n  throw new RuntimeError(\n    \"Response returned from Azure AD is not in the expected format.\"\n  );\n}\n", "import { getPolicyCacheName } from \"../../caches/keys\";\nimport { MemoryZoneReadThroughCache } from \"../../caches/memory-zone-readthrough-cache\";\nimport { RuntimeError } from \"../../errors\";\nimport { InboundPolicyHandler } from \"../../policies\";\nimport {\n  exchangeGgpJwtForIdToken,\n  GcpServiceAccount,\n  getTokenFromGcpServiceAccount,\n} from \"../../utils/gcp\";\nimport { optionValidator } from \"../../utils/validator\";\nimport { UpstreamFirebaseAdminAuthInboundPolicyOptions } from \"./options\";\n\nexport { UpstreamFirebaseAdminAuthInboundPolicyOptions };\n\nconst GOOGLE_TOKEN_AUDIENCE = \"https://accounts.google.com/o/oauth2/token\";\n\nlet serviceAccount: GcpServiceAccount | undefined;\n\n/**\n * Creates a Firebase Admin token and attaches it to the outgoing request. Useful when calling Firebase services as an administrator.\n *\n * @remarks\n * This policy adds a Firebase Admin token to the outgoing `Authentication` header\n * allowing requests to Firebase using Service Account admin permissions. This can\n * be useful for calling Firebase services such as Firestore through a Zuplo\n * endpoint that is secured with other means of Authentication such as API keys.\n * Additionally, this policy can be useful for service content to all API users\n * (for example serving a specific Firestore document containing configuration\n * data)\n *\n * We recommend reading the `serviceAccountJson` from environment variables (so it\n * is not checked in to source control) using the `$env(ENV_VAR)` syntax.\n *\n * @title Upstream Firebase Admin Auth\n * @public\n * @param request - The ZuploRequest\n * @param context - The ZuploContext\n * @param options - The policy options set in policies.json\n * @param policyName - The name of the policy as set in policies.json\n * @returns A Request or a Response\n */\nexport const UpstreamFirebaseAdminAuthInboundPolicy: InboundPolicyHandler<\n  UpstreamFirebaseAdminAuthInboundPolicyOptions\n> = async (request, context, options, policyName) => {\n  optionValidator(options, policyName).required(\"serviceAccountJson\", \"string\");\n\n  if (!serviceAccount) {\n    serviceAccount = await GcpServiceAccount.init(options.serviceAccountJson);\n  }\n\n  const payload = {\n    scope: [\n      \"https://www.googleapis.com/auth/cloud-platform\",\n      \"https://www.googleapis.com/auth/firebase.database\",\n      \"https://www.googleapis.com/auth/firebase.messaging\",\n      \"https://www.googleapis.com/auth/identitytoolkit\",\n      \"https://www.googleapis.com/auth/userinfo.email\",\n    ].join(\" \"),\n  };\n\n  const cacheName = await getPolicyCacheName(policyName, options);\n  const cache = new MemoryZoneReadThroughCache<string>(cacheName, context);\n  let token = await cache.get(policyName);\n  if (!token) {\n    const jwt = await getTokenFromGcpServiceAccount({\n      serviceAccount,\n      audience: GOOGLE_TOKEN_AUDIENCE,\n      payload,\n    });\n\n    const response = await exchangeGgpJwtForIdToken(\n      GOOGLE_TOKEN_AUDIENCE,\n      jwt,\n      { retries: options.tokenRetries ?? 3, retryDelayMs: 10 }\n    );\n    if (!response.access_token) {\n      throw new RuntimeError(\"Invalid OAuth response from Firebase\");\n    }\n    token = response.access_token;\n    cache.put(\n      policyName,\n      token,\n      (response.expires_in ?? 3600) - (options.expirationOffsetSeconds ?? 300)\n    );\n  }\n\n  request.headers.set(\"Authorization\", `Bearer ${token}`);\n  return request;\n};\n", "import { getPolicyCacheName } from \"../../caches/keys\";\nimport { MemoryZoneReadThroughCache } from \"../../caches/memory-zone-readthrough-cache\";\nimport { ConfigurationError, RuntimeError } from \"../../errors\";\nimport { InboundPolicyHandler } from \"../../policies\";\nimport { sha256 } from \"../../utils/crypto\";\nimport {\n  GcpServiceAccount,\n  exchangeFirebaseJwtForIdToken,\n  getTokenFromGcpServiceAccount,\n} from \"../../utils/gcp\";\nimport { getValueFromRequestUser } from \"../../utils/options-parsing\";\nimport { optionValidator } from \"../../utils/validator\";\nimport { UpstreamFirebaseUserAuthInboundPolicyOptions } from \"./options\";\n\nexport { UpstreamFirebaseUserAuthInboundPolicyOptions };\n\n// Audience to use for Firebase Auth Custom tokens\nconst FIREBASE_AUDIENCE =\n  \"https://identitytoolkit.googleapis.com/google.identity.identitytoolkit.v1.IdentityToolkit\";\n\n// List of reserved claims which cannot be provided when creating a custom token\nconst RESERVED_CLAIMS = [\n  \"acr\",\n  \"amr\",\n  \"at_hash\",\n  \"aud\",\n  \"auth_time\",\n  \"azp\",\n  \"cnf\",\n  \"c_hash\",\n  \"exp\",\n  \"iat\",\n  \"iss\",\n  \"jti\",\n  \"nbf\",\n  \"nonce\",\n];\n\nlet serviceAccount: GcpServiceAccount | undefined;\n\n/**\n * Creates a Firebase custom user token and attaches it to the outgoing request. Useful when calling Firebase services as user.\n *\n * @remarks\n * This policy adds a Firebase Admin token to the outgoing `Authentication` header\n * allowing requests to Firebase using Service Account admin permissions. This can\n * be useful for calling Firebase services such as Firestore through a Zuplo\n * endpoint that is secured with other means of Authentication such as API keys.\n * Additionally, this policy can be useful for service content to all API users\n * (for example serving a specific Firestore document containing configuration\n * data)\n *\n * We recommend reading the `serviceAccountJson` from environment variables (so it\n * is not checked in to source control) using the `$env(ENV_VAR)` syntax.\n *\n * @title Upstream Firebase User Auth\n * @public\n * @param request - The ZuploRequest\n * @param context - The ZuploContext\n * @param options - The policy options set in policies.json\n * @param policyName - The name of the policy as set in policies.json\n * @returns A Request or a Response\n */\nexport const UpstreamFirebaseUserAuthInboundPolicy: InboundPolicyHandler<\n  UpstreamFirebaseUserAuthInboundPolicyOptions\n> = async (request, context, options, policyName) => {\n  optionValidator(options, policyName)\n    .required(\"serviceAccountJson\", \"string\")\n    .required(\"webApiKey\", \"string\")\n    .optional(\"developerClaims\", \"object\")\n    .optional(\"userId\", \"string\")\n    .optional(\"userIdPropertyPath\", \"string\");\n\n  if (!options.userId && !options.userIdPropertyPath) {\n    throw new ConfigurationError(\n      `Either 'userId' or 'userIdPropertyPath' options must be set on policy '${policyName}'.`\n    );\n  }\n\n  const claims: Record<string, boolean | string | number | null> = {};\n  if (typeof options.developerClaims !== \"undefined\") {\n    for (const key in options.developerClaims) {\n      /* istanbul ignore else */\n      if (Object.prototype.hasOwnProperty.call(options.developerClaims, key)) {\n        if (RESERVED_CLAIMS.indexOf(key) !== -1) {\n          throw new ConfigurationError(\n            `Developer claim \"${key}\" is reserved and cannot be specified.`\n          );\n        }\n        claims[key] = options.developerClaims[key];\n      }\n    }\n  }\n\n  if (!serviceAccount) {\n    serviceAccount = await GcpServiceAccount.init(options.serviceAccountJson);\n  }\n\n  let userId = options.userId;\n  if (!userId && !options.userIdPropertyPath) {\n    if (!request.user) {\n      throw new RuntimeError(\n        `Unable to set userId for upstream auth policy as request.user is 'undefined'. Do you have an authentication policy before this policy?.`\n      );\n    }\n    // If neither userId or userIdPropertyPath is set, default to the sub\n    userId = request.user?.sub;\n  } else if (options.userIdPropertyPath) {\n    if (!request.user) {\n      throw new RuntimeError(\n        `Unable to apply userIdPropertyPath '${options.userIdPropertyPath}' as request.user is 'undefined'. Do you have an authentication policy before this policy?`\n      );\n    }\n    userId = getValueFromRequestUser(\n      request.user,\n      options.userIdPropertyPath,\n      \"userIdPropertyPath\"\n    );\n  }\n\n  if (!userId) {\n    throw new RuntimeError(\n      `Unable to determine user from for the policy ${policyName}`\n    );\n  }\n\n  const cacheName = await getPolicyCacheName(policyName, options);\n  const cache = new MemoryZoneReadThroughCache<string>(cacheName, context);\n\n  const payload = {\n    uid: userId,\n    claims,\n  };\n  const key = await sha256(JSON.stringify(payload));\n  let token = await cache.get(key);\n  if (!token) {\n    const jwt = await getTokenFromGcpServiceAccount({\n      serviceAccount,\n      audience: FIREBASE_AUDIENCE,\n      payload,\n    });\n    const oauthUrl = `https://identitytoolkit.googleapis.com/v1/accounts:signInWithCustomToken?key=${options.webApiKey}`;\n    const response = await exchangeFirebaseJwtForIdToken(oauthUrl, jwt, {\n      retries: options.tokenRetries ?? 3,\n      retryDelayMs: 10,\n    });\n    if (!response.idToken) {\n      throw new RuntimeError(\"Invalid token response from Firebase\");\n    }\n    token = response.idToken;\n    cache.put(\n      key,\n      token,\n      (response.expiresIn ? parseInt(response.expiresIn) : 3600) -\n        (options.expirationOffsetSeconds ?? 300)\n    );\n  }\n\n  request.headers.set(\"Authorization\", `Bearer ${token}`);\n  return request;\n};\n", "import { InboundPolicyHandler } from \"../../policies\";\nimport {\n  GcpServiceAccount,\n  getTokenFromGcpServiceAccount,\n} from \"../../utils/gcp\";\nimport { optionValidator } from \"../../utils/validator\";\nimport { UpstreamGcpJwtInboundPolicyOptions } from \"./options\";\n\nexport { UpstreamGcpJwtInboundPolicyOptions };\n\nlet serviceAccount: GcpServiceAccount | undefined;\n\n/**\n * Creates a self-signed JWT token (generated using a Google Service Account JSON) and attaches it to the outgoing request. Useful when calling GCP services like Cloud Endpoints / ESPv2\n *\n * @remarks\n * This policy adds a JWT token to the headers, ready for us in an outgoing request\n * when calling a GCP service (e.g. Cloud Endpoints / ESPv2). We recommend reading\n * the `serviceAccountJson` from environment variables (so it is not checked in to\n * source control) using the `$env(ENV_VAR)` syntax.\n *\n * CAUTION: This policy only works with {@link https://developers.google.com/identity/protocols/oauth2/service-account#jwt-auth | certain Google APIs}.\n * In most cases, the {@link https://zuplo.com/docs/policies/upstream-gcp-service-auth-inbound | Upstream GCP Service Auth}\n * should be used.\n *\n * @title Upstream GCP Self-Signed JWT\n * @public\n * @param request - The ZuploRequest\n * @param context - The ZuploContext\n * @param options - The policy options set in policies.json\n * @param policyName - The name of the policy as set in policies.json\n * @returns A Request or a Response\n */\nexport const UpstreamGcpJwtInboundPolicy: InboundPolicyHandler<\n  UpstreamGcpJwtInboundPolicyOptions\n> = async (request, context, options, policyName) => {\n  optionValidator(options, policyName)\n    .required(\"audience\", \"string\")\n    .required(\"serviceAccountJson\", \"string\");\n\n  if (!serviceAccount) {\n    serviceAccount = await GcpServiceAccount.init(options.serviceAccountJson);\n  }\n\n  const jwt = await getTokenFromGcpServiceAccount({\n    serviceAccount,\n    audience: options.audience,\n  });\n\n  request.headers.set(\"Authorization\", `Bearer ${jwt}`);\n  return request;\n};\n", "import { getPolicyCacheName } from \"../../caches/keys\";\nimport { MemoryCache } from \"../../caches/memory-cache\";\nimport { MemoryZoneReadThroughCache } from \"../../caches/memory-zone-readthrough-cache\";\nimport { ConfigurationError, RuntimeError } from \"../../errors\";\nimport { InboundPolicyHandler } from \"../../policies\";\nimport {\n  GcpServiceAccount,\n  exchangeGgpJwtForIdToken,\n  getTokenFromGcpServiceAccount,\n} from \"../../utils/gcp\";\nimport { parseValueToStringArray } from \"../../utils/options-parsing\";\nimport { optionValidator } from \"../../utils/validator\";\nimport { UpstreamGcpServiceAuthInboundPolicyOptions } from \"./options\";\n\nexport { UpstreamGcpServiceAuthInboundPolicyOptions };\n\nconst GOOGLE_OAUTH_URL = \"https://www.googleapis.com/oauth2/v4/token\";\n\nlet serviceAccount: GcpServiceAccount | undefined;\n\n/**\n * Creates an ID Token from Google's OAuth service and attaches it to the outgoing request. Useful when calling GCP services or Google APIs that are secured with GCP IAM.\n *\n * @remarks\n * This policy allows you to delegate authentication and authorization to your\n * gateway without writing any code on your origin service by adding a GCP Issued\n * ID Token to outgoing header allowing the service to be secured with GCP IAM.\n * This is a useful means of securing your origin server so that only your Zuplo\n * gateway can make requests against it.\n *\n *\n * This policy works with\n * {@link https://zuplo.com/docs/articles/gke-with-upstream-auth-policy|GCP Identity Aware Proxy}\n * or services like {@link https://cloud.google.com/iap/docs/managing-access|Cloud Run}\n * that natively support IAM authorization.\n *\n * We recommend reading the `serviceAccountJson` from environment variables (so it\n * is not checked in to source control) using the `$env(ENV_VAR)` syntax.\n *\n * For information on how Google's service based auth works see {@link https://cloud.google.com/functions/docs/securing/authenticating|Authenticating for invocation}\n *\n * @title Upstream GCP Service Auth\n * @public\n * @param request - The ZuploRequest\n * @param context - The ZuploContext\n * @param options - The policy options set in policies.json\n * @param policyName - The name of the policy as set in policies.json\n * @returns A Request or a Response\n */\nexport const UpstreamGcpServiceAuthInboundPolicy: InboundPolicyHandler<\n  UpstreamGcpServiceAuthInboundPolicyOptions\n> = async (request, context, options, policyName) => {\n  optionValidator(options, policyName)\n    .required(\"serviceAccountJson\", \"string\")\n    .optional(\"audience\", \"string\")\n    .optional(\"tokenRetries\", \"number\")\n    .optional(\"expirationOffsetSeconds\", \"number\");\n\n  if (!serviceAccount) {\n    serviceAccount = await GcpServiceAccount.init(options.serviceAccountJson);\n  }\n\n  const payload: Record<string, string> = {};\n\n  if (options.scopes && options.audience) {\n    throw new ConfigurationError(\n      `UpstreamGcpServiceAuthInboundPolicy - Either the 'scopes' or the 'audience' property can be set, not both.`\n    );\n  }\n\n  // Scopes is used for authenticating against google's own APIs\n  if (options.scopes) {\n    try {\n      const scopes = parseValueToStringArray(options.scopes);\n      payload.scope = scopes.join(\" \");\n    } catch (err) {\n      if (err instanceof ConfigurationError) {\n        throw new ConfigurationError(\n          `UpstreamGcpServiceAuthInboundPolicy - The property 'scopes' is invalid. ${err.message}`\n        );\n      }\n      throw err;\n    }\n  }\n\n  // target_audience is used when authenticating with IAM to services\n  // such as Cloud Run, etc.\n  if (options.audience) {\n    payload.target_audience = `${options.audience}`;\n  }\n\n  const cacheName = await getPolicyCacheName(policyName, options);\n  let cache: MemoryZoneReadThroughCache<string> | MemoryCache<string>;\n  if (options.useMemoryCacheOnly) {\n    cache = new MemoryCache<string>(cacheName);\n  } else {\n    cache = new MemoryZoneReadThroughCache<string>(cacheName, context);\n  }\n\n  let token = await cache.get(policyName);\n\n  if (!token) {\n    const jwt = await getTokenFromGcpServiceAccount({\n      serviceAccount,\n      audience: GOOGLE_OAUTH_URL,\n      payload,\n    });\n    const tokenResponse = await exchangeGgpJwtForIdToken(\n      GOOGLE_OAUTH_URL,\n      jwt,\n      {\n        retries: options.tokenRetries ?? 3,\n        retryDelayMs: 10,\n      }\n    );\n\n    if (options.audience) {\n      // If the audience is set, we expect an ID Token\n      if (!tokenResponse.id_token) {\n        throw new RuntimeError(\"Invalid token response from GCP\");\n      }\n      token = tokenResponse.id_token;\n    } else {\n      // If the audience is not set, we expect an access token\n      if (!tokenResponse.access_token) {\n        throw new RuntimeError(\"Invalid token response from GCP\");\n      }\n      token = tokenResponse.access_token;\n    }\n\n    cache.put(\n      policyName,\n      token,\n      // GCP tokens are valid for 1 hour\n      3600 - (options.expirationOffsetSeconds ?? 300)\n    );\n  }\n\n  request.headers.set(\"Authorization\", `Bearer ${token}`);\n  return request;\n};\n", "import type { ValidateFunction } from \"ajv\";\nimport { SystemError } from \"../../errors\";\nimport { InboundPolicyHandler } from \"../../policies\";\nimport { HttpProblems } from \"../../problem-responses/http-problems\";\nimport { ValidateJsonSchemaInboundOptions } from \"./options\";\n\nexport { ValidateJsonSchemaInboundOptions };\n\n/**\n * @beta\n */\nexport interface ValidateJsonSchemaInboundInternalOptions\n  extends Omit<ValidateJsonSchemaInboundOptions, \"validator\"> {\n  /**\n   * @internal\n   */\n  validator: ValidateFunction;\n}\n\n/**\n * Validates the body of an incoming request based on a JSON schema.\n *\n * @remarks\n * The Validate JSON Schema policy is used to validate the body of incoming\n * requests. It works using JSON Schemas defined in the `Schemas` folder of your\n * project.\n *\n * When configured, any requests that do not have a body conforming to your JSON\n * schema will be rejected with a `400: Bad Request` response containing a detailed\n * error message (in JSON) explaining why the body was not accepted.\n *\n * @title JSON Body Validation\n * @public\n * @deprecated Use the new {@link https://zuplo.com/docs/policies/request-validation-inbound|Request Validation Policy}.\n * The new policy validates JSON bodies like this policy, but also supports validation of parameters, query strings, etc.\n * @param request - The ZuploRequest\n * @param context - The ZuploContext\n * @param options - The policy options set in policies.json\n * @param policyName - The name of the policy as set in policies.json\n * @returns A Request or a Response\n */\nexport const ValidateJsonSchemaInbound: InboundPolicyHandler<\n  ValidateJsonSchemaInboundInternalOptions\n> = async (request, context, options) => {\n  // we need to clone the request before reading the body to\n  // avoid user error's downstream.\n  const clone = request.clone();\n  let body: unknown;\n\n  try {\n    body = await clone.json();\n  } catch (err) {\n    return HttpProblems.badRequest(request, context, {\n      detail: \"Invalid JSON body - expected well-formed JSON document\",\n    });\n  }\n\n  const isValid = options.validator(body);\n\n  if (isValid) {\n    return request;\n  }\n\n  const { errors } = options.validator;\n\n  if (!errors) {\n    throw new SystemError(\n      \"Invalid state - validator error object is undefined even though validation failed.\"\n    );\n  }\n\n  const messages = errors.map((err) => {\n    if (err.instancePath === undefined || err.instancePath === \"\") {\n      return \"Body \" + err.message;\n    } else {\n      return err.instancePath.replace(\"/\", \"\") + \" \" + err.message;\n    }\n  });\n\n  return HttpProblems.badRequest(request, context, {\n    detail: \"Incoming body did not pass schema validation\",\n    errors: messages,\n  });\n};\n", "\"use strict\";\nvar __defProp = Object.defineProperty;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __name = (target, value) => __defProp(target, \"name\", { value, configurable: true });\nvar __commonJS = (cb, mod) => function __require() {\n  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n};\n\n// node_modules/fast-xml-parser/src/util.js\nvar require_util = __commonJS({\n  \"node_modules/fast-xml-parser/src/util.js\"(exports2) {\n    \"use strict\";\n    var nameStartChar = \":A-Za-z_\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD\";\n    var nameChar = nameStartChar + \"\\\\-.\\\\d\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040\";\n    var nameRegexp = \"[\" + nameStartChar + \"][\" + nameChar + \"]*\";\n    var regexName = new RegExp(\"^\" + nameRegexp + \"$\");\n    var getAllMatches = /* @__PURE__ */ __name(function(string, regex) {\n      const matches = [];\n      let match = regex.exec(string);\n      while (match) {\n        const allmatches = [];\n        allmatches.startIndex = regex.lastIndex - match[0].length;\n        const len = match.length;\n        for (let index = 0; index < len; index++) {\n          allmatches.push(match[index]);\n        }\n        matches.push(allmatches);\n        match = regex.exec(string);\n      }\n      return matches;\n    }, \"getAllMatches\");\n    var isName = /* @__PURE__ */ __name(function(string) {\n      const match = regexName.exec(string);\n      return !(match === null || typeof match === \"undefined\");\n    }, \"isName\");\n    exports2.isExist = function(v) {\n      return typeof v !== \"undefined\";\n    };\n    exports2.isEmptyObject = function(obj) {\n      return Object.keys(obj).length === 0;\n    };\n    exports2.merge = function(target, a, arrayMode) {\n      if (a) {\n        const keys = Object.keys(a);\n        const len = keys.length;\n        for (let i = 0; i < len; i++) {\n          if (arrayMode === \"strict\") {\n            target[keys[i]] = [a[keys[i]]];\n          } else {\n            target[keys[i]] = a[keys[i]];\n          }\n        }\n      }\n    };\n    exports2.getValue = function(v) {\n      if (exports2.isExist(v)) {\n        return v;\n      } else {\n        return \"\";\n      }\n    };\n    exports2.isName = isName;\n    exports2.getAllMatches = getAllMatches;\n    exports2.nameRegexp = nameRegexp;\n  }\n});\n\n// node_modules/fast-xml-parser/src/validator.js\nvar require_validator = __commonJS({\n  \"node_modules/fast-xml-parser/src/validator.js\"(exports2) {\n    \"use strict\";\n    var util = require_util();\n    var defaultOptions = {\n      allowBooleanAttributes: false,\n      //A tag can have attributes without any value\n      unpairedTags: []\n    };\n    exports2.validate = function(xmlData, options) {\n      options = Object.assign({}, defaultOptions, options);\n      const tags = [];\n      let tagFound = false;\n      let reachedRoot = false;\n      if (xmlData[0] === \"\\uFEFF\") {\n        xmlData = xmlData.substr(1);\n      }\n      for (let i = 0; i < xmlData.length; i++) {\n        if (xmlData[i] === \"<\" && xmlData[i + 1] === \"?\") {\n          i += 2;\n          i = readPI(xmlData, i);\n          if (i.err)\n            return i;\n        } else if (xmlData[i] === \"<\") {\n          let tagStartPos = i;\n          i++;\n          if (xmlData[i] === \"!\") {\n            i = readCommentAndCDATA(xmlData, i);\n            continue;\n          } else {\n            let closingTag = false;\n            if (xmlData[i] === \"/\") {\n              closingTag = true;\n              i++;\n            }\n            let tagName = \"\";\n            for (; i < xmlData.length && xmlData[i] !== \">\" && xmlData[i] !== \" \" && xmlData[i] !== \"\t\" && xmlData[i] !== \"\\n\" && xmlData[i] !== \"\\r\"; i++) {\n              tagName += xmlData[i];\n            }\n            tagName = tagName.trim();\n            if (tagName[tagName.length - 1] === \"/\") {\n              tagName = tagName.substring(0, tagName.length - 1);\n              i--;\n            }\n            if (!validateTagName(tagName)) {\n              let msg;\n              if (tagName.trim().length === 0) {\n                msg = \"Invalid space after '<'.\";\n              } else {\n                msg = \"Tag '\" + tagName + \"' is an invalid name.\";\n              }\n              return getErrorObject(\"InvalidTag\", msg, getLineNumberForPosition(xmlData, i));\n            }\n            const result = readAttributeStr(xmlData, i);\n            if (result === false) {\n              return getErrorObject(\"InvalidAttr\", \"Attributes for '\" + tagName + \"' have open quote.\", getLineNumberForPosition(xmlData, i));\n            }\n            let attrStr = result.value;\n            i = result.index;\n            if (attrStr[attrStr.length - 1] === \"/\") {\n              const attrStrStart = i - attrStr.length;\n              attrStr = attrStr.substring(0, attrStr.length - 1);\n              const isValid = validateAttributeString(attrStr, options);\n              if (isValid === true) {\n                tagFound = true;\n              } else {\n                return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, attrStrStart + isValid.err.line));\n              }\n            } else if (closingTag) {\n              if (!result.tagClosed) {\n                return getErrorObject(\"InvalidTag\", \"Closing tag '\" + tagName + \"' doesn't have proper closing.\", getLineNumberForPosition(xmlData, i));\n              } else if (attrStr.trim().length > 0) {\n                return getErrorObject(\"InvalidTag\", \"Closing tag '\" + tagName + \"' can't have attributes or invalid starting.\", getLineNumberForPosition(xmlData, tagStartPos));\n              } else {\n                const otg = tags.pop();\n                if (tagName !== otg.tagName) {\n                  let openPos = getLineNumberForPosition(xmlData, otg.tagStartPos);\n                  return getErrorObject(\n                    \"InvalidTag\",\n                    \"Expected closing tag '\" + otg.tagName + \"' (opened in line \" + openPos.line + \", col \" + openPos.col + \") instead of closing tag '\" + tagName + \"'.\",\n                    getLineNumberForPosition(xmlData, tagStartPos)\n                  );\n                }\n                if (tags.length == 0) {\n                  reachedRoot = true;\n                }\n              }\n            } else {\n              const isValid = validateAttributeString(attrStr, options);\n              if (isValid !== true) {\n                return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, i - attrStr.length + isValid.err.line));\n              }\n              if (reachedRoot === true) {\n                return getErrorObject(\"InvalidXml\", \"Multiple possible root nodes found.\", getLineNumberForPosition(xmlData, i));\n              } else if (options.unpairedTags.indexOf(tagName) !== -1) {\n              } else {\n                tags.push({ tagName, tagStartPos });\n              }\n              tagFound = true;\n            }\n            for (i++; i < xmlData.length; i++) {\n              if (xmlData[i] === \"<\") {\n                if (xmlData[i + 1] === \"!\") {\n                  i++;\n                  i = readCommentAndCDATA(xmlData, i);\n                  continue;\n                } else if (xmlData[i + 1] === \"?\") {\n                  i = readPI(xmlData, ++i);\n                  if (i.err)\n                    return i;\n                } else {\n                  break;\n                }\n              } else if (xmlData[i] === \"&\") {\n                const afterAmp = validateAmpersand(xmlData, i);\n                if (afterAmp == -1)\n                  return getErrorObject(\"InvalidChar\", \"char '&' is not expected.\", getLineNumberForPosition(xmlData, i));\n                i = afterAmp;\n              } else {\n                if (reachedRoot === true && !isWhiteSpace(xmlData[i])) {\n                  return getErrorObject(\"InvalidXml\", \"Extra text at the end\", getLineNumberForPosition(xmlData, i));\n                }\n              }\n            }\n            if (xmlData[i] === \"<\") {\n              i--;\n            }\n          }\n        } else {\n          if (isWhiteSpace(xmlData[i])) {\n            continue;\n          }\n          return getErrorObject(\"InvalidChar\", \"char '\" + xmlData[i] + \"' is not expected.\", getLineNumberForPosition(xmlData, i));\n        }\n      }\n      if (!tagFound) {\n        return getErrorObject(\"InvalidXml\", \"Start tag expected.\", 1);\n      } else if (tags.length == 1) {\n        return getErrorObject(\"InvalidTag\", \"Unclosed tag '\" + tags[0].tagName + \"'.\", getLineNumberForPosition(xmlData, tags[0].tagStartPos));\n      } else if (tags.length > 0) {\n        return getErrorObject(\"InvalidXml\", \"Invalid '\" + JSON.stringify(tags.map((t) => t.tagName), null, 4).replace(/\\r?\\n/g, \"\") + \"' found.\", { line: 1, col: 1 });\n      }\n      return true;\n    };\n    function isWhiteSpace(char) {\n      return char === \" \" || char === \"\t\" || char === \"\\n\" || char === \"\\r\";\n    }\n    __name(isWhiteSpace, \"isWhiteSpace\");\n    function readPI(xmlData, i) {\n      const start = i;\n      for (; i < xmlData.length; i++) {\n        if (xmlData[i] == \"?\" || xmlData[i] == \" \") {\n          const tagname = xmlData.substr(start, i - start);\n          if (i > 5 && tagname === \"xml\") {\n            return getErrorObject(\"InvalidXml\", \"XML declaration allowed only at the start of the document.\", getLineNumberForPosition(xmlData, i));\n          } else if (xmlData[i] == \"?\" && xmlData[i + 1] == \">\") {\n            i++;\n            break;\n          } else {\n            continue;\n          }\n        }\n      }\n      return i;\n    }\n    __name(readPI, \"readPI\");\n    function readCommentAndCDATA(xmlData, i) {\n      if (xmlData.length > i + 5 && xmlData[i + 1] === \"-\" && xmlData[i + 2] === \"-\") {\n        for (i += 3; i < xmlData.length; i++) {\n          if (xmlData[i] === \"-\" && xmlData[i + 1] === \"-\" && xmlData[i + 2] === \">\") {\n            i += 2;\n            break;\n          }\n        }\n      } else if (xmlData.length > i + 8 && xmlData[i + 1] === \"D\" && xmlData[i + 2] === \"O\" && xmlData[i + 3] === \"C\" && xmlData[i + 4] === \"T\" && xmlData[i + 5] === \"Y\" && xmlData[i + 6] === \"P\" && xmlData[i + 7] === \"E\") {\n        let angleBracketsCount = 1;\n        for (i += 8; i < xmlData.length; i++) {\n          if (xmlData[i] === \"<\") {\n            angleBracketsCount++;\n          } else if (xmlData[i] === \">\") {\n            angleBracketsCount--;\n            if (angleBracketsCount === 0) {\n              break;\n            }\n          }\n        }\n      } else if (xmlData.length > i + 9 && xmlData[i + 1] === \"[\" && xmlData[i + 2] === \"C\" && xmlData[i + 3] === \"D\" && xmlData[i + 4] === \"A\" && xmlData[i + 5] === \"T\" && xmlData[i + 6] === \"A\" && xmlData[i + 7] === \"[\") {\n        for (i += 8; i < xmlData.length; i++) {\n          if (xmlData[i] === \"]\" && xmlData[i + 1] === \"]\" && xmlData[i + 2] === \">\") {\n            i += 2;\n            break;\n          }\n        }\n      }\n      return i;\n    }\n    __name(readCommentAndCDATA, \"readCommentAndCDATA\");\n    var doubleQuote = '\"';\n    var singleQuote = \"'\";\n    function readAttributeStr(xmlData, i) {\n      let attrStr = \"\";\n      let startChar = \"\";\n      let tagClosed = false;\n      for (; i < xmlData.length; i++) {\n        if (xmlData[i] === doubleQuote || xmlData[i] === singleQuote) {\n          if (startChar === \"\") {\n            startChar = xmlData[i];\n          } else if (startChar !== xmlData[i]) {\n          } else {\n            startChar = \"\";\n          }\n        } else if (xmlData[i] === \">\") {\n          if (startChar === \"\") {\n            tagClosed = true;\n            break;\n          }\n        }\n        attrStr += xmlData[i];\n      }\n      if (startChar !== \"\") {\n        return false;\n      }\n      return {\n        value: attrStr,\n        index: i,\n        tagClosed\n      };\n    }\n    __name(readAttributeStr, \"readAttributeStr\");\n    var validAttrStrRegxp = new RegExp(`(\\\\s*)([^\\\\s=]+)(\\\\s*=)?(\\\\s*(['\"])(([\\\\s\\\\S])*?)\\\\5)?`, \"g\");\n    function validateAttributeString(attrStr, options) {\n      const matches = util.getAllMatches(attrStr, validAttrStrRegxp);\n      const attrNames = {};\n      for (let i = 0; i < matches.length; i++) {\n        if (matches[i][1].length === 0) {\n          return getErrorObject(\"InvalidAttr\", \"Attribute '\" + matches[i][2] + \"' has no space in starting.\", getPositionFromMatch(matches[i]));\n        } else if (matches[i][3] !== void 0 && matches[i][4] === void 0) {\n          return getErrorObject(\"InvalidAttr\", \"Attribute '\" + matches[i][2] + \"' is without value.\", getPositionFromMatch(matches[i]));\n        } else if (matches[i][3] === void 0 && !options.allowBooleanAttributes) {\n          return getErrorObject(\"InvalidAttr\", \"boolean attribute '\" + matches[i][2] + \"' is not allowed.\", getPositionFromMatch(matches[i]));\n        }\n        const attrName = matches[i][2];\n        if (!validateAttrName(attrName)) {\n          return getErrorObject(\"InvalidAttr\", \"Attribute '\" + attrName + \"' is an invalid name.\", getPositionFromMatch(matches[i]));\n        }\n        if (!attrNames.hasOwnProperty(attrName)) {\n          attrNames[attrName] = 1;\n        } else {\n          return getErrorObject(\"InvalidAttr\", \"Attribute '\" + attrName + \"' is repeated.\", getPositionFromMatch(matches[i]));\n        }\n      }\n      return true;\n    }\n    __name(validateAttributeString, \"validateAttributeString\");\n    function validateNumberAmpersand(xmlData, i) {\n      let re = /\\d/;\n      if (xmlData[i] === \"x\") {\n        i++;\n        re = /[\\da-fA-F]/;\n      }\n      for (; i < xmlData.length; i++) {\n        if (xmlData[i] === \";\")\n          return i;\n        if (!xmlData[i].match(re))\n          break;\n      }\n      return -1;\n    }\n    __name(validateNumberAmpersand, \"validateNumberAmpersand\");\n    function validateAmpersand(xmlData, i) {\n      i++;\n      if (xmlData[i] === \";\")\n        return -1;\n      if (xmlData[i] === \"#\") {\n        i++;\n        return validateNumberAmpersand(xmlData, i);\n      }\n      let count = 0;\n      for (; i < xmlData.length; i++, count++) {\n        if (xmlData[i].match(/\\w/) && count < 20)\n          continue;\n        if (xmlData[i] === \";\")\n          break;\n        return -1;\n      }\n      return i;\n    }\n    __name(validateAmpersand, \"validateAmpersand\");\n    function getErrorObject(code, message, lineNumber) {\n      return {\n        err: {\n          code,\n          msg: message,\n          line: lineNumber.line || lineNumber,\n          col: lineNumber.col\n        }\n      };\n    }\n    __name(getErrorObject, \"getErrorObject\");\n    function validateAttrName(attrName) {\n      return util.isName(attrName);\n    }\n    __name(validateAttrName, \"validateAttrName\");\n    function validateTagName(tagname) {\n      return util.isName(tagname);\n    }\n    __name(validateTagName, \"validateTagName\");\n    function getLineNumberForPosition(xmlData, index) {\n      const lines = xmlData.substring(0, index).split(/\\r?\\n/);\n      return {\n        line: lines.length,\n        // column number is last line's length + 1, because column numbering starts at 1:\n        col: lines[lines.length - 1].length + 1\n      };\n    }\n    __name(getLineNumberForPosition, \"getLineNumberForPosition\");\n    function getPositionFromMatch(match) {\n      return match.startIndex + match[1].length;\n    }\n    __name(getPositionFromMatch, \"getPositionFromMatch\");\n  }\n});\n\n// node_modules/fast-xml-parser/src/xmlparser/OptionsBuilder.js\nvar require_OptionsBuilder = __commonJS({\n  \"node_modules/fast-xml-parser/src/xmlparser/OptionsBuilder.js\"(exports2) {\n    var defaultOptions = {\n      preserveOrder: false,\n      attributeNamePrefix: \"@_\",\n      attributesGroupName: false,\n      textNodeName: \"#text\",\n      ignoreAttributes: true,\n      removeNSPrefix: false,\n      // remove NS from tag name or attribute name if true\n      allowBooleanAttributes: false,\n      //a tag can have attributes without any value\n      //ignoreRootElement : false,\n      parseTagValue: true,\n      parseAttributeValue: false,\n      trimValues: true,\n      //Trim string values of tag and attributes\n      cdataPropName: false,\n      numberParseOptions: {\n        hex: true,\n        leadingZeros: true,\n        eNotation: true\n      },\n      tagValueProcessor: function(tagName, val2) {\n        return val2;\n      },\n      attributeValueProcessor: function(attrName, val2) {\n        return val2;\n      },\n      stopNodes: [],\n      //nested tags will not be parsed even for errors\n      alwaysCreateTextNode: false,\n      isArray: () => false,\n      commentPropName: false,\n      unpairedTags: [],\n      processEntities: true,\n      htmlEntities: false,\n      ignoreDeclaration: false,\n      ignorePiTags: false,\n      transformTagName: false,\n      transformAttributeName: false,\n      updateTag: function(tagName, jPath, attrs) {\n        return tagName;\n      }\n      // skipEmptyListItem: false\n    };\n    var buildOptions = /* @__PURE__ */ __name(function(options) {\n      return Object.assign({}, defaultOptions, options);\n    }, \"buildOptions\");\n    exports2.buildOptions = buildOptions;\n    exports2.defaultOptions = defaultOptions;\n  }\n});\n\n// node_modules/fast-xml-parser/src/xmlparser/xmlNode.js\nvar require_xmlNode = __commonJS({\n  \"node_modules/fast-xml-parser/src/xmlparser/xmlNode.js\"(exports2, module2) {\n    \"use strict\";\n    var XmlNode = class {\n      static {\n        __name(this, \"XmlNode\");\n      }\n      constructor(tagname) {\n        this.tagname = tagname;\n        this.child = [];\n        this[\":@\"] = {};\n      }\n      add(key, val2) {\n        if (key === \"__proto__\")\n          key = \"#__proto__\";\n        this.child.push({ [key]: val2 });\n      }\n      addChild(node) {\n        if (node.tagname === \"__proto__\")\n          node.tagname = \"#__proto__\";\n        if (node[\":@\"] && Object.keys(node[\":@\"]).length > 0) {\n          this.child.push({ [node.tagname]: node.child, [\":@\"]: node[\":@\"] });\n        } else {\n          this.child.push({ [node.tagname]: node.child });\n        }\n      }\n    };\n    module2.exports = XmlNode;\n  }\n});\n\n// node_modules/fast-xml-parser/src/xmlparser/DocTypeReader.js\nvar require_DocTypeReader = __commonJS({\n  \"node_modules/fast-xml-parser/src/xmlparser/DocTypeReader.js\"(exports2, module2) {\n    var util = require_util();\n    function readDocType(xmlData, i) {\n      const entities = {};\n      if (xmlData[i + 3] === \"O\" && xmlData[i + 4] === \"C\" && xmlData[i + 5] === \"T\" && xmlData[i + 6] === \"Y\" && xmlData[i + 7] === \"P\" && xmlData[i + 8] === \"E\") {\n        i = i + 9;\n        let angleBracketsCount = 1;\n        let hasBody = false, comment = false;\n        let exp = \"\";\n        for (; i < xmlData.length; i++) {\n          if (xmlData[i] === \"<\" && !comment) {\n            if (hasBody && isEntity(xmlData, i)) {\n              i += 7;\n              [entityName, val, i] = readEntityExp(xmlData, i + 1);\n              if (val.indexOf(\"&\") === -1)\n                entities[validateEntityName(entityName)] = {\n                  regx: RegExp(`&${entityName};`, \"g\"),\n                  val\n                };\n            } else if (hasBody && isElement(xmlData, i))\n              i += 8;\n            else if (hasBody && isAttlist(xmlData, i))\n              i += 8;\n            else if (hasBody && isNotation(xmlData, i))\n              i += 9;\n            else if (isComment)\n              comment = true;\n            else\n              throw new Error(\"Invalid DOCTYPE\");\n            angleBracketsCount++;\n            exp = \"\";\n          } else if (xmlData[i] === \">\") {\n            if (comment) {\n              if (xmlData[i - 1] === \"-\" && xmlData[i - 2] === \"-\") {\n                comment = false;\n                angleBracketsCount--;\n              }\n            } else {\n              angleBracketsCount--;\n            }\n            if (angleBracketsCount === 0) {\n              break;\n            }\n          } else if (xmlData[i] === \"[\") {\n            hasBody = true;\n          } else {\n            exp += xmlData[i];\n          }\n        }\n        if (angleBracketsCount !== 0) {\n          throw new Error(`Unclosed DOCTYPE`);\n        }\n      } else {\n        throw new Error(`Invalid Tag instead of DOCTYPE`);\n      }\n      return { entities, i };\n    }\n    __name(readDocType, \"readDocType\");\n    function readEntityExp(xmlData, i) {\n      let entityName2 = \"\";\n      for (; i < xmlData.length && (xmlData[i] !== \"'\" && xmlData[i] !== '\"'); i++) {\n        entityName2 += xmlData[i];\n      }\n      entityName2 = entityName2.trim();\n      if (entityName2.indexOf(\" \") !== -1)\n        throw new Error(\"External entites are not supported\");\n      const startChar = xmlData[i++];\n      let val2 = \"\";\n      for (; i < xmlData.length && xmlData[i] !== startChar; i++) {\n        val2 += xmlData[i];\n      }\n      return [entityName2, val2, i];\n    }\n    __name(readEntityExp, \"readEntityExp\");\n    function isComment(xmlData, i) {\n      if (xmlData[i + 1] === \"!\" && xmlData[i + 2] === \"-\" && xmlData[i + 3] === \"-\")\n        return true;\n      return false;\n    }\n    __name(isComment, \"isComment\");\n    function isEntity(xmlData, i) {\n      if (xmlData[i + 1] === \"!\" && xmlData[i + 2] === \"E\" && xmlData[i + 3] === \"N\" && xmlData[i + 4] === \"T\" && xmlData[i + 5] === \"I\" && xmlData[i + 6] === \"T\" && xmlData[i + 7] === \"Y\")\n        return true;\n      return false;\n    }\n    __name(isEntity, \"isEntity\");\n    function isElement(xmlData, i) {\n      if (xmlData[i + 1] === \"!\" && xmlData[i + 2] === \"E\" && xmlData[i + 3] === \"L\" && xmlData[i + 4] === \"E\" && xmlData[i + 5] === \"M\" && xmlData[i + 6] === \"E\" && xmlData[i + 7] === \"N\" && xmlData[i + 8] === \"T\")\n        return true;\n      return false;\n    }\n    __name(isElement, \"isElement\");\n    function isAttlist(xmlData, i) {\n      if (xmlData[i + 1] === \"!\" && xmlData[i + 2] === \"A\" && xmlData[i + 3] === \"T\" && xmlData[i + 4] === \"T\" && xmlData[i + 5] === \"L\" && xmlData[i + 6] === \"I\" && xmlData[i + 7] === \"S\" && xmlData[i + 8] === \"T\")\n        return true;\n      return false;\n    }\n    __name(isAttlist, \"isAttlist\");\n    function isNotation(xmlData, i) {\n      if (xmlData[i + 1] === \"!\" && xmlData[i + 2] === \"N\" && xmlData[i + 3] === \"O\" && xmlData[i + 4] === \"T\" && xmlData[i + 5] === \"A\" && xmlData[i + 6] === \"T\" && xmlData[i + 7] === \"I\" && xmlData[i + 8] === \"O\" && xmlData[i + 9] === \"N\")\n        return true;\n      return false;\n    }\n    __name(isNotation, \"isNotation\");\n    function validateEntityName(name) {\n      if (util.isName(name))\n        return name;\n      else\n        throw new Error(`Invalid entity name ${name}`);\n    }\n    __name(validateEntityName, \"validateEntityName\");\n    module2.exports = readDocType;\n  }\n});\n\n// ../../node_modules/strnum/strnum.js\nvar require_strnum = __commonJS({\n  \"../../node_modules/strnum/strnum.js\"(exports2, module2) {\n    var hexRegex = /^[-+]?0x[a-fA-F0-9]+$/;\n    var numRegex = /^([\\-\\+])?(0*)(\\.[0-9]+([eE]\\-?[0-9]+)?|[0-9]+(\\.[0-9]+([eE]\\-?[0-9]+)?)?)$/;\n    if (!Number.parseInt && window.parseInt) {\n      Number.parseInt = window.parseInt;\n    }\n    if (!Number.parseFloat && window.parseFloat) {\n      Number.parseFloat = window.parseFloat;\n    }\n    var consider = {\n      hex: true,\n      leadingZeros: true,\n      decimalPoint: \".\",\n      eNotation: true\n      //skipLike: /regex/\n    };\n    function toNumber(str, options = {}) {\n      options = Object.assign({}, consider, options);\n      if (!str || typeof str !== \"string\")\n        return str;\n      let trimmedStr = str.trim();\n      if (options.skipLike !== void 0 && options.skipLike.test(trimmedStr))\n        return str;\n      else if (options.hex && hexRegex.test(trimmedStr)) {\n        return Number.parseInt(trimmedStr, 16);\n      } else {\n        const match = numRegex.exec(trimmedStr);\n        if (match) {\n          const sign = match[1];\n          const leadingZeros = match[2];\n          let numTrimmedByZeros = trimZeros(match[3]);\n          const eNotation = match[4] || match[6];\n          if (!options.leadingZeros && leadingZeros.length > 0 && sign && trimmedStr[2] !== \".\")\n            return str;\n          else if (!options.leadingZeros && leadingZeros.length > 0 && !sign && trimmedStr[1] !== \".\")\n            return str;\n          else {\n            const num = Number(trimmedStr);\n            const numStr = \"\" + num;\n            if (numStr.search(/[eE]/) !== -1) {\n              if (options.eNotation)\n                return num;\n              else\n                return str;\n            } else if (eNotation) {\n              if (options.eNotation)\n                return num;\n              else\n                return str;\n            } else if (trimmedStr.indexOf(\".\") !== -1) {\n              if (numStr === \"0\" && numTrimmedByZeros === \"\")\n                return num;\n              else if (numStr === numTrimmedByZeros)\n                return num;\n              else if (sign && numStr === \"-\" + numTrimmedByZeros)\n                return num;\n              else\n                return str;\n            }\n            if (leadingZeros) {\n              if (numTrimmedByZeros === numStr)\n                return num;\n              else if (sign + numTrimmedByZeros === numStr)\n                return num;\n              else\n                return str;\n            }\n            if (trimmedStr === numStr)\n              return num;\n            else if (trimmedStr === sign + numStr)\n              return num;\n            return str;\n          }\n        } else {\n          return str;\n        }\n      }\n    }\n    __name(toNumber, \"toNumber\");\n    function trimZeros(numStr) {\n      if (numStr && numStr.indexOf(\".\") !== -1) {\n        numStr = numStr.replace(/0+$/, \"\");\n        if (numStr === \".\")\n          numStr = \"0\";\n        else if (numStr[0] === \".\")\n          numStr = \"0\" + numStr;\n        else if (numStr[numStr.length - 1] === \".\")\n          numStr = numStr.substr(0, numStr.length - 1);\n        return numStr;\n      }\n      return numStr;\n    }\n    __name(trimZeros, \"trimZeros\");\n    module2.exports = toNumber;\n  }\n});\n\n// node_modules/fast-xml-parser/src/xmlparser/OrderedObjParser.js\nvar require_OrderedObjParser = __commonJS({\n  \"node_modules/fast-xml-parser/src/xmlparser/OrderedObjParser.js\"(exports2, module2) {\n    \"use strict\";\n    var util = require_util();\n    var xmlNode = require_xmlNode();\n    var readDocType = require_DocTypeReader();\n    var toNumber = require_strnum();\n    var OrderedObjParser = class {\n      static {\n        __name(this, \"OrderedObjParser\");\n      }\n      constructor(options) {\n        this.options = options;\n        this.currentNode = null;\n        this.tagsNodeStack = [];\n        this.docTypeEntities = {};\n        this.lastEntities = {\n          \"apos\": { regex: /&(apos|#39|#x27);/g, val: \"'\" },\n          \"gt\": { regex: /&(gt|#62|#x3E);/g, val: \">\" },\n          \"lt\": { regex: /&(lt|#60|#x3C);/g, val: \"<\" },\n          \"quot\": { regex: /&(quot|#34|#x22);/g, val: '\"' }\n        };\n        this.ampEntity = { regex: /&(amp|#38|#x26);/g, val: \"&\" };\n        this.htmlEntities = {\n          \"space\": { regex: /&(nbsp|#160);/g, val: \" \" },\n          // \"lt\" : { regex: /&(lt|#60);/g, val: \"<\" },\n          // \"gt\" : { regex: /&(gt|#62);/g, val: \">\" },\n          // \"amp\" : { regex: /&(amp|#38);/g, val: \"&\" },\n          // \"quot\" : { regex: /&(quot|#34);/g, val: \"\\\"\" },\n          // \"apos\" : { regex: /&(apos|#39);/g, val: \"'\" },\n          \"cent\": { regex: /&(cent|#162);/g, val: \"\\xA2\" },\n          \"pound\": { regex: /&(pound|#163);/g, val: \"\\xA3\" },\n          \"yen\": { regex: /&(yen|#165);/g, val: \"\\xA5\" },\n          \"euro\": { regex: /&(euro|#8364);/g, val: \"\\u20AC\" },\n          \"copyright\": { regex: /&(copy|#169);/g, val: \"\\xA9\" },\n          \"reg\": { regex: /&(reg|#174);/g, val: \"\\xAE\" },\n          \"inr\": { regex: /&(inr|#8377);/g, val: \"\\u20B9\" }\n        };\n        this.addExternalEntities = addExternalEntities;\n        this.parseXml = parseXml;\n        this.parseTextData = parseTextData;\n        this.resolveNameSpace = resolveNameSpace;\n        this.buildAttributesMap = buildAttributesMap;\n        this.isItStopNode = isItStopNode;\n        this.replaceEntitiesValue = replaceEntitiesValue;\n        this.readStopNodeData = readStopNodeData;\n        this.saveTextToParentTag = saveTextToParentTag;\n        this.addChild = addChild;\n      }\n    };\n    function addExternalEntities(externalEntities) {\n      const entKeys = Object.keys(externalEntities);\n      for (let i = 0; i < entKeys.length; i++) {\n        const ent = entKeys[i];\n        this.lastEntities[ent] = {\n          regex: new RegExp(\"&\" + ent + \";\", \"g\"),\n          val: externalEntities[ent]\n        };\n      }\n    }\n    __name(addExternalEntities, \"addExternalEntities\");\n    function parseTextData(val2, tagName, jPath, dontTrim, hasAttributes, isLeafNode, escapeEntities) {\n      if (val2 !== void 0) {\n        if (this.options.trimValues && !dontTrim) {\n          val2 = val2.trim();\n        }\n        if (val2.length > 0) {\n          if (!escapeEntities)\n            val2 = this.replaceEntitiesValue(val2);\n          const newval = this.options.tagValueProcessor(tagName, val2, jPath, hasAttributes, isLeafNode);\n          if (newval === null || newval === void 0) {\n            return val2;\n          } else if (typeof newval !== typeof val2 || newval !== val2) {\n            return newval;\n          } else if (this.options.trimValues) {\n            return parseValue(val2, this.options.parseTagValue, this.options.numberParseOptions);\n          } else {\n            const trimmedVal = val2.trim();\n            if (trimmedVal === val2) {\n              return parseValue(val2, this.options.parseTagValue, this.options.numberParseOptions);\n            } else {\n              return val2;\n            }\n          }\n        }\n      }\n    }\n    __name(parseTextData, \"parseTextData\");\n    function resolveNameSpace(tagname) {\n      if (this.options.removeNSPrefix) {\n        const tags = tagname.split(\":\");\n        const prefix = tagname.charAt(0) === \"/\" ? \"/\" : \"\";\n        if (tags[0] === \"xmlns\") {\n          return \"\";\n        }\n        if (tags.length === 2) {\n          tagname = prefix + tags[1];\n        }\n      }\n      return tagname;\n    }\n    __name(resolveNameSpace, \"resolveNameSpace\");\n    var attrsRegx = new RegExp(`([^\\\\s=]+)\\\\s*(=\\\\s*(['\"])([\\\\s\\\\S]*?)\\\\3)?`, \"gm\");\n    function buildAttributesMap(attrStr, jPath, tagName) {\n      if (!this.options.ignoreAttributes && typeof attrStr === \"string\") {\n        const matches = util.getAllMatches(attrStr, attrsRegx);\n        const len = matches.length;\n        const attrs = {};\n        for (let i = 0; i < len; i++) {\n          const attrName = this.resolveNameSpace(matches[i][1]);\n          let oldVal = matches[i][4];\n          let aName = this.options.attributeNamePrefix + attrName;\n          if (attrName.length) {\n            if (this.options.transformAttributeName) {\n              aName = this.options.transformAttributeName(aName);\n            }\n            if (aName === \"__proto__\")\n              aName = \"#__proto__\";\n            if (oldVal !== void 0) {\n              if (this.options.trimValues) {\n                oldVal = oldVal.trim();\n              }\n              oldVal = this.replaceEntitiesValue(oldVal);\n              const newVal = this.options.attributeValueProcessor(attrName, oldVal, jPath);\n              if (newVal === null || newVal === void 0) {\n                attrs[aName] = oldVal;\n              } else if (typeof newVal !== typeof oldVal || newVal !== oldVal) {\n                attrs[aName] = newVal;\n              } else {\n                attrs[aName] = parseValue(\n                  oldVal,\n                  this.options.parseAttributeValue,\n                  this.options.numberParseOptions\n                );\n              }\n            } else if (this.options.allowBooleanAttributes) {\n              attrs[aName] = true;\n            }\n          }\n        }\n        if (!Object.keys(attrs).length) {\n          return;\n        }\n        if (this.options.attributesGroupName) {\n          const attrCollection = {};\n          attrCollection[this.options.attributesGroupName] = attrs;\n          return attrCollection;\n        }\n        return attrs;\n      }\n    }\n    __name(buildAttributesMap, \"buildAttributesMap\");\n    var parseXml = /* @__PURE__ */ __name(function(xmlData) {\n      xmlData = xmlData.replace(/\\r\\n?/g, \"\\n\");\n      const xmlObj = new xmlNode(\"!xml\");\n      let currentNode = xmlObj;\n      let textData = \"\";\n      let jPath = \"\";\n      for (let i = 0; i < xmlData.length; i++) {\n        const ch = xmlData[i];\n        if (ch === \"<\") {\n          if (xmlData[i + 1] === \"/\") {\n            const closeIndex = findClosingIndex(xmlData, \">\", i, \"Closing Tag is not closed.\");\n            let tagName = xmlData.substring(i + 2, closeIndex).trim();\n            if (this.options.removeNSPrefix) {\n              const colonIndex = tagName.indexOf(\":\");\n              if (colonIndex !== -1) {\n                tagName = tagName.substr(colonIndex + 1);\n              }\n            }\n            if (this.options.transformTagName) {\n              tagName = this.options.transformTagName(tagName);\n            }\n            if (currentNode) {\n              textData = this.saveTextToParentTag(textData, currentNode, jPath);\n            }\n            const lastTagName = jPath.substring(jPath.lastIndexOf(\".\") + 1);\n            if (tagName && this.options.unpairedTags.indexOf(tagName) !== -1) {\n              throw new Error(`Unpaired tag can not be used as closing tag: </${tagName}>`);\n            }\n            let propIndex = 0;\n            if (lastTagName && this.options.unpairedTags.indexOf(lastTagName) !== -1) {\n              propIndex = jPath.lastIndexOf(\".\", jPath.lastIndexOf(\".\") - 1);\n              this.tagsNodeStack.pop();\n            } else {\n              propIndex = jPath.lastIndexOf(\".\");\n            }\n            jPath = jPath.substring(0, propIndex);\n            currentNode = this.tagsNodeStack.pop();\n            textData = \"\";\n            i = closeIndex;\n          } else if (xmlData[i + 1] === \"?\") {\n            let tagData = readTagExp(xmlData, i, false, \"?>\");\n            if (!tagData)\n              throw new Error(\"Pi Tag is not closed.\");\n            textData = this.saveTextToParentTag(textData, currentNode, jPath);\n            if (this.options.ignoreDeclaration && tagData.tagName === \"?xml\" || this.options.ignorePiTags) {\n            } else {\n              const childNode = new xmlNode(tagData.tagName);\n              childNode.add(this.options.textNodeName, \"\");\n              if (tagData.tagName !== tagData.tagExp && tagData.attrExpPresent) {\n                childNode[\":@\"] = this.buildAttributesMap(tagData.tagExp, jPath, tagData.tagName);\n              }\n              this.addChild(currentNode, childNode, jPath);\n            }\n            i = tagData.closeIndex + 1;\n          } else if (xmlData.substr(i + 1, 3) === \"!--\") {\n            const endIndex = findClosingIndex(xmlData, \"-->\", i + 4, \"Comment is not closed.\");\n            if (this.options.commentPropName) {\n              const comment = xmlData.substring(i + 4, endIndex - 2);\n              textData = this.saveTextToParentTag(textData, currentNode, jPath);\n              currentNode.add(this.options.commentPropName, [{ [this.options.textNodeName]: comment }]);\n            }\n            i = endIndex;\n          } else if (xmlData.substr(i + 1, 2) === \"!D\") {\n            const result = readDocType(xmlData, i);\n            this.docTypeEntities = result.entities;\n            i = result.i;\n          } else if (xmlData.substr(i + 1, 2) === \"![\") {\n            const closeIndex = findClosingIndex(xmlData, \"]]>\", i, \"CDATA is not closed.\") - 2;\n            const tagExp = xmlData.substring(i + 9, closeIndex);\n            textData = this.saveTextToParentTag(textData, currentNode, jPath);\n            let val2 = this.parseTextData(tagExp, currentNode.tagname, jPath, true, false, true, true);\n            if (val2 == void 0)\n              val2 = \"\";\n            if (this.options.cdataPropName) {\n              currentNode.add(this.options.cdataPropName, [{ [this.options.textNodeName]: tagExp }]);\n            } else {\n              currentNode.add(this.options.textNodeName, val2);\n            }\n            i = closeIndex + 2;\n          } else {\n            let result = readTagExp(xmlData, i, this.options.removeNSPrefix);\n            let tagName = result.tagName;\n            const rawTagName = result.rawTagName;\n            let tagExp = result.tagExp;\n            let attrExpPresent = result.attrExpPresent;\n            let closeIndex = result.closeIndex;\n            if (this.options.transformTagName) {\n              tagName = this.options.transformTagName(tagName);\n            }\n            if (currentNode && textData) {\n              if (currentNode.tagname !== \"!xml\") {\n                textData = this.saveTextToParentTag(textData, currentNode, jPath, false);\n              }\n            }\n            const lastTag = currentNode;\n            if (lastTag && this.options.unpairedTags.indexOf(lastTag.tagname) !== -1) {\n              currentNode = this.tagsNodeStack.pop();\n              jPath = jPath.substring(0, jPath.lastIndexOf(\".\"));\n            }\n            if (tagName !== xmlObj.tagname) {\n              jPath += jPath ? \".\" + tagName : tagName;\n            }\n            if (this.isItStopNode(this.options.stopNodes, jPath, tagName)) {\n              let tagContent = \"\";\n              if (tagExp.length > 0 && tagExp.lastIndexOf(\"/\") === tagExp.length - 1) {\n                i = result.closeIndex;\n              } else if (this.options.unpairedTags.indexOf(tagName) !== -1) {\n                i = result.closeIndex;\n              } else {\n                const result2 = this.readStopNodeData(xmlData, rawTagName, closeIndex + 1);\n                if (!result2)\n                  throw new Error(`Unexpected end of ${rawTagName}`);\n                i = result2.i;\n                tagContent = result2.tagContent;\n              }\n              const childNode = new xmlNode(tagName);\n              if (tagName !== tagExp && attrExpPresent) {\n                childNode[\":@\"] = this.buildAttributesMap(tagExp, jPath, tagName);\n              }\n              if (tagContent) {\n                tagContent = this.parseTextData(tagContent, tagName, jPath, true, attrExpPresent, true, true);\n              }\n              jPath = jPath.substr(0, jPath.lastIndexOf(\".\"));\n              childNode.add(this.options.textNodeName, tagContent);\n              this.addChild(currentNode, childNode, jPath);\n            } else {\n              if (tagExp.length > 0 && tagExp.lastIndexOf(\"/\") === tagExp.length - 1) {\n                if (tagName[tagName.length - 1] === \"/\") {\n                  tagName = tagName.substr(0, tagName.length - 1);\n                  jPath = jPath.substr(0, jPath.length - 1);\n                  tagExp = tagName;\n                } else {\n                  tagExp = tagExp.substr(0, tagExp.length - 1);\n                }\n                if (this.options.transformTagName) {\n                  tagName = this.options.transformTagName(tagName);\n                }\n                const childNode = new xmlNode(tagName);\n                if (tagName !== tagExp && attrExpPresent) {\n                  childNode[\":@\"] = this.buildAttributesMap(tagExp, jPath, tagName);\n                }\n                this.addChild(currentNode, childNode, jPath);\n                jPath = jPath.substr(0, jPath.lastIndexOf(\".\"));\n              } else {\n                const childNode = new xmlNode(tagName);\n                this.tagsNodeStack.push(currentNode);\n                if (tagName !== tagExp && attrExpPresent) {\n                  childNode[\":@\"] = this.buildAttributesMap(tagExp, jPath, tagName);\n                }\n                this.addChild(currentNode, childNode, jPath);\n                currentNode = childNode;\n              }\n              textData = \"\";\n              i = closeIndex;\n            }\n          }\n        } else {\n          textData += xmlData[i];\n        }\n      }\n      return xmlObj.child;\n    }, \"parseXml\");\n    function addChild(currentNode, childNode, jPath) {\n      const result = this.options.updateTag(childNode.tagname, jPath, childNode[\":@\"]);\n      if (result === false) {\n      } else if (typeof result === \"string\") {\n        childNode.tagname = result;\n        currentNode.addChild(childNode);\n      } else {\n        currentNode.addChild(childNode);\n      }\n    }\n    __name(addChild, \"addChild\");\n    var replaceEntitiesValue = /* @__PURE__ */ __name(function(val2) {\n      if (this.options.processEntities) {\n        for (let entityName2 in this.docTypeEntities) {\n          const entity = this.docTypeEntities[entityName2];\n          val2 = val2.replace(entity.regx, entity.val);\n        }\n        for (let entityName2 in this.lastEntities) {\n          const entity = this.lastEntities[entityName2];\n          val2 = val2.replace(entity.regex, entity.val);\n        }\n        if (this.options.htmlEntities) {\n          for (let entityName2 in this.htmlEntities) {\n            const entity = this.htmlEntities[entityName2];\n            val2 = val2.replace(entity.regex, entity.val);\n          }\n        }\n        val2 = val2.replace(this.ampEntity.regex, this.ampEntity.val);\n      }\n      return val2;\n    }, \"replaceEntitiesValue\");\n    function saveTextToParentTag(textData, currentNode, jPath, isLeafNode) {\n      if (textData) {\n        if (isLeafNode === void 0)\n          isLeafNode = Object.keys(currentNode.child).length === 0;\n        textData = this.parseTextData(\n          textData,\n          currentNode.tagname,\n          jPath,\n          false,\n          currentNode[\":@\"] ? Object.keys(currentNode[\":@\"]).length !== 0 : false,\n          isLeafNode\n        );\n        if (textData !== void 0 && textData !== \"\")\n          currentNode.add(this.options.textNodeName, textData);\n        textData = \"\";\n      }\n      return textData;\n    }\n    __name(saveTextToParentTag, \"saveTextToParentTag\");\n    function isItStopNode(stopNodes, jPath, currentTagName) {\n      const allNodesExp = \"*.\" + currentTagName;\n      for (const stopNodePath in stopNodes) {\n        const stopNodeExp = stopNodes[stopNodePath];\n        if (allNodesExp === stopNodeExp || jPath === stopNodeExp)\n          return true;\n      }\n      return false;\n    }\n    __name(isItStopNode, \"isItStopNode\");\n    function tagExpWithClosingIndex(xmlData, i, closingChar = \">\") {\n      let attrBoundary;\n      let tagExp = \"\";\n      for (let index = i; index < xmlData.length; index++) {\n        let ch = xmlData[index];\n        if (attrBoundary) {\n          if (ch === attrBoundary)\n            attrBoundary = \"\";\n        } else if (ch === '\"' || ch === \"'\") {\n          attrBoundary = ch;\n        } else if (ch === closingChar[0]) {\n          if (closingChar[1]) {\n            if (xmlData[index + 1] === closingChar[1]) {\n              return {\n                data: tagExp,\n                index\n              };\n            }\n          } else {\n            return {\n              data: tagExp,\n              index\n            };\n          }\n        } else if (ch === \"\t\") {\n          ch = \" \";\n        }\n        tagExp += ch;\n      }\n    }\n    __name(tagExpWithClosingIndex, \"tagExpWithClosingIndex\");\n    function findClosingIndex(xmlData, str, i, errMsg) {\n      const closingIndex = xmlData.indexOf(str, i);\n      if (closingIndex === -1) {\n        throw new Error(errMsg);\n      } else {\n        return closingIndex + str.length - 1;\n      }\n    }\n    __name(findClosingIndex, \"findClosingIndex\");\n    function readTagExp(xmlData, i, removeNSPrefix, closingChar = \">\") {\n      const result = tagExpWithClosingIndex(xmlData, i + 1, closingChar);\n      if (!result)\n        return;\n      let tagExp = result.data;\n      const closeIndex = result.index;\n      const separatorIndex = tagExp.search(/\\s/);\n      let tagName = tagExp;\n      let attrExpPresent = true;\n      if (separatorIndex !== -1) {\n        tagName = tagExp.substring(0, separatorIndex);\n        tagExp = tagExp.substring(separatorIndex + 1).trimStart();\n      }\n      const rawTagName = tagName;\n      if (removeNSPrefix) {\n        const colonIndex = tagName.indexOf(\":\");\n        if (colonIndex !== -1) {\n          tagName = tagName.substr(colonIndex + 1);\n          attrExpPresent = tagName !== result.data.substr(colonIndex + 1);\n        }\n      }\n      return {\n        tagName,\n        tagExp,\n        closeIndex,\n        attrExpPresent,\n        rawTagName\n      };\n    }\n    __name(readTagExp, \"readTagExp\");\n    function readStopNodeData(xmlData, tagName, i) {\n      const startIndex = i;\n      let openTagCount = 1;\n      for (; i < xmlData.length; i++) {\n        if (xmlData[i] === \"<\") {\n          if (xmlData[i + 1] === \"/\") {\n            const closeIndex = findClosingIndex(xmlData, \">\", i, `${tagName} is not closed`);\n            let closeTagName = xmlData.substring(i + 2, closeIndex).trim();\n            if (closeTagName === tagName) {\n              openTagCount--;\n              if (openTagCount === 0) {\n                return {\n                  tagContent: xmlData.substring(startIndex, i),\n                  i: closeIndex\n                };\n              }\n            }\n            i = closeIndex;\n          } else if (xmlData[i + 1] === \"?\") {\n            const closeIndex = findClosingIndex(xmlData, \"?>\", i + 1, \"StopNode is not closed.\");\n            i = closeIndex;\n          } else if (xmlData.substr(i + 1, 3) === \"!--\") {\n            const closeIndex = findClosingIndex(xmlData, \"-->\", i + 3, \"StopNode is not closed.\");\n            i = closeIndex;\n          } else if (xmlData.substr(i + 1, 2) === \"![\") {\n            const closeIndex = findClosingIndex(xmlData, \"]]>\", i, \"StopNode is not closed.\") - 2;\n            i = closeIndex;\n          } else {\n            const tagData = readTagExp(xmlData, i, \">\");\n            if (tagData) {\n              const openTagName = tagData && tagData.tagName;\n              if (openTagName === tagName && tagData.tagExp[tagData.tagExp.length - 1] !== \"/\") {\n                openTagCount++;\n              }\n              i = tagData.closeIndex;\n            }\n          }\n        }\n      }\n    }\n    __name(readStopNodeData, \"readStopNodeData\");\n    function parseValue(val2, shouldParse, options) {\n      if (shouldParse && typeof val2 === \"string\") {\n        const newval = val2.trim();\n        if (newval === \"true\")\n          return true;\n        else if (newval === \"false\")\n          return false;\n        else\n          return toNumber(val2, options);\n      } else {\n        if (util.isExist(val2)) {\n          return val2;\n        } else {\n          return \"\";\n        }\n      }\n    }\n    __name(parseValue, \"parseValue\");\n    module2.exports = OrderedObjParser;\n  }\n});\n\n// node_modules/fast-xml-parser/src/xmlparser/node2json.js\nvar require_node2json = __commonJS({\n  \"node_modules/fast-xml-parser/src/xmlparser/node2json.js\"(exports2) {\n    \"use strict\";\n    function prettify(node, options) {\n      return compress(node, options);\n    }\n    __name(prettify, \"prettify\");\n    function compress(arr, options, jPath) {\n      let text;\n      const compressedObj = {};\n      for (let i = 0; i < arr.length; i++) {\n        const tagObj = arr[i];\n        const property = propName(tagObj);\n        let newJpath = \"\";\n        if (jPath === void 0)\n          newJpath = property;\n        else\n          newJpath = jPath + \".\" + property;\n        if (property === options.textNodeName) {\n          if (text === void 0)\n            text = tagObj[property];\n          else\n            text += \"\" + tagObj[property];\n        } else if (property === void 0) {\n          continue;\n        } else if (tagObj[property]) {\n          let val2 = compress(tagObj[property], options, newJpath);\n          const isLeaf = isLeafTag(val2, options);\n          if (tagObj[\":@\"]) {\n            assignAttributes(val2, tagObj[\":@\"], newJpath, options);\n          } else if (Object.keys(val2).length === 1 && val2[options.textNodeName] !== void 0 && !options.alwaysCreateTextNode) {\n            val2 = val2[options.textNodeName];\n          } else if (Object.keys(val2).length === 0) {\n            if (options.alwaysCreateTextNode)\n              val2[options.textNodeName] = \"\";\n            else\n              val2 = \"\";\n          }\n          if (compressedObj[property] !== void 0 && compressedObj.hasOwnProperty(property)) {\n            if (!Array.isArray(compressedObj[property])) {\n              compressedObj[property] = [compressedObj[property]];\n            }\n            compressedObj[property].push(val2);\n          } else {\n            if (options.isArray(property, newJpath, isLeaf)) {\n              compressedObj[property] = [val2];\n            } else {\n              compressedObj[property] = val2;\n            }\n          }\n        }\n      }\n      if (typeof text === \"string\") {\n        if (text.length > 0)\n          compressedObj[options.textNodeName] = text;\n      } else if (text !== void 0)\n        compressedObj[options.textNodeName] = text;\n      return compressedObj;\n    }\n    __name(compress, \"compress\");\n    function propName(obj) {\n      const keys = Object.keys(obj);\n      for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        if (key !== \":@\")\n          return key;\n      }\n    }\n    __name(propName, \"propName\");\n    function assignAttributes(obj, attrMap, jpath, options) {\n      if (attrMap) {\n        const keys = Object.keys(attrMap);\n        const len = keys.length;\n        for (let i = 0; i < len; i++) {\n          const atrrName = keys[i];\n          if (options.isArray(atrrName, jpath + \".\" + atrrName, true, true)) {\n            obj[atrrName] = [attrMap[atrrName]];\n          } else {\n            obj[atrrName] = attrMap[atrrName];\n          }\n        }\n      }\n    }\n    __name(assignAttributes, \"assignAttributes\");\n    function isLeafTag(obj, options) {\n      const { textNodeName } = options;\n      const propCount = Object.keys(obj).length;\n      if (propCount === 0) {\n        return true;\n      }\n      if (propCount === 1 && (obj[textNodeName] || typeof obj[textNodeName] === \"boolean\" || obj[textNodeName] === 0)) {\n        return true;\n      }\n      return false;\n    }\n    __name(isLeafTag, \"isLeafTag\");\n    exports2.prettify = prettify;\n  }\n});\n\n// node_modules/fast-xml-parser/src/xmlparser/XMLParser.js\nvar require_XMLParser = __commonJS({\n  \"node_modules/fast-xml-parser/src/xmlparser/XMLParser.js\"(exports2, module2) {\n    var { buildOptions } = require_OptionsBuilder();\n    var OrderedObjParser = require_OrderedObjParser();\n    var { prettify } = require_node2json();\n    var validator2 = require_validator();\n    var XMLParser2 = class {\n      static {\n        __name(this, \"XMLParser\");\n      }\n      constructor(options) {\n        this.externalEntities = {};\n        this.options = buildOptions(options);\n      }\n      /**\n       * Parse XML dats to JS object \n       * @param {string|Buffer} xmlData \n       * @param {boolean|Object} validationOption \n       */\n      parse(xmlData, validationOption) {\n        if (typeof xmlData === \"string\") {\n        } else if (xmlData.toString) {\n          xmlData = xmlData.toString();\n        } else {\n          throw new Error(\"XML data is accepted in String or Bytes[] form.\");\n        }\n        if (validationOption) {\n          if (validationOption === true)\n            validationOption = {};\n          const result = validator2.validate(xmlData, validationOption);\n          if (result !== true) {\n            throw Error(`${result.err.msg}:${result.err.line}:${result.err.col}`);\n          }\n        }\n        const orderedObjParser = new OrderedObjParser(this.options);\n        orderedObjParser.addExternalEntities(this.externalEntities);\n        const orderedResult = orderedObjParser.parseXml(xmlData);\n        if (this.options.preserveOrder || orderedResult === void 0)\n          return orderedResult;\n        else\n          return prettify(orderedResult, this.options);\n      }\n      /**\n       * Add Entity which is not by default supported by this library\n       * @param {string} key \n       * @param {string} value \n       */\n      addEntity(key, value) {\n        if (value.indexOf(\"&\") !== -1) {\n          throw new Error(\"Entity value can't have '&'\");\n        } else if (key.indexOf(\"&\") !== -1 || key.indexOf(\";\") !== -1) {\n          throw new Error(\"An entity must be set without '&' and ';'. Eg. use '#xD' for '&#xD;'\");\n        } else if (value === \"&\") {\n          throw new Error(\"An entity with value '&' is not permitted\");\n        } else {\n          this.externalEntities[key] = value;\n        }\n      }\n    };\n    module2.exports = XMLParser2;\n  }\n});\n\n// node_modules/fast-xml-parser/src/xmlbuilder/orderedJs2Xml.js\nvar require_orderedJs2Xml = __commonJS({\n  \"node_modules/fast-xml-parser/src/xmlbuilder/orderedJs2Xml.js\"(exports2, module2) {\n    var EOL = \"\\n\";\n    function toXml(jArray, options) {\n      let indentation = \"\";\n      if (options.format && options.indentBy.length > 0) {\n        indentation = EOL;\n      }\n      return arrToStr(jArray, options, \"\", indentation);\n    }\n    __name(toXml, \"toXml\");\n    function arrToStr(arr, options, jPath, indentation) {\n      let xmlStr = \"\";\n      let isPreviousElementTag = false;\n      for (let i = 0; i < arr.length; i++) {\n        const tagObj = arr[i];\n        const tagName = propName(tagObj);\n        if (tagName === void 0)\n          continue;\n        let newJPath = \"\";\n        if (jPath.length === 0)\n          newJPath = tagName;\n        else\n          newJPath = `${jPath}.${tagName}`;\n        if (tagName === options.textNodeName) {\n          let tagText = tagObj[tagName];\n          if (!isStopNode(newJPath, options)) {\n            tagText = options.tagValueProcessor(tagName, tagText);\n            tagText = replaceEntitiesValue(tagText, options);\n          }\n          if (isPreviousElementTag) {\n            xmlStr += indentation;\n          }\n          xmlStr += tagText;\n          isPreviousElementTag = false;\n          continue;\n        } else if (tagName === options.cdataPropName) {\n          if (isPreviousElementTag) {\n            xmlStr += indentation;\n          }\n          xmlStr += `<![CDATA[${tagObj[tagName][0][options.textNodeName]}]]>`;\n          isPreviousElementTag = false;\n          continue;\n        } else if (tagName === options.commentPropName) {\n          xmlStr += indentation + `<!--${tagObj[tagName][0][options.textNodeName]}-->`;\n          isPreviousElementTag = true;\n          continue;\n        } else if (tagName[0] === \"?\") {\n          const attStr2 = attr_to_str(tagObj[\":@\"], options);\n          const tempInd = tagName === \"?xml\" ? \"\" : indentation;\n          let piTextNodeName = tagObj[tagName][0][options.textNodeName];\n          piTextNodeName = piTextNodeName.length !== 0 ? \" \" + piTextNodeName : \"\";\n          xmlStr += tempInd + `<${tagName}${piTextNodeName}${attStr2}?>`;\n          isPreviousElementTag = true;\n          continue;\n        }\n        let newIdentation = indentation;\n        if (newIdentation !== \"\") {\n          newIdentation += options.indentBy;\n        }\n        const attStr = attr_to_str(tagObj[\":@\"], options);\n        const tagStart = indentation + `<${tagName}${attStr}`;\n        const tagValue = arrToStr(tagObj[tagName], options, newJPath, newIdentation);\n        if (options.unpairedTags.indexOf(tagName) !== -1) {\n          if (options.suppressUnpairedNode)\n            xmlStr += tagStart + \">\";\n          else\n            xmlStr += tagStart + \"/>\";\n        } else if ((!tagValue || tagValue.length === 0) && options.suppressEmptyNode) {\n          xmlStr += tagStart + \"/>\";\n        } else if (tagValue && tagValue.endsWith(\">\")) {\n          xmlStr += tagStart + `>${tagValue}${indentation}</${tagName}>`;\n        } else {\n          xmlStr += tagStart + \">\";\n          if (tagValue && indentation !== \"\" && (tagValue.includes(\"/>\") || tagValue.includes(\"</\"))) {\n            xmlStr += indentation + options.indentBy + tagValue + indentation;\n          } else {\n            xmlStr += tagValue;\n          }\n          xmlStr += `</${tagName}>`;\n        }\n        isPreviousElementTag = true;\n      }\n      return xmlStr;\n    }\n    __name(arrToStr, \"arrToStr\");\n    function propName(obj) {\n      const keys = Object.keys(obj);\n      for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        if (!obj.hasOwnProperty(key))\n          continue;\n        if (key !== \":@\")\n          return key;\n      }\n    }\n    __name(propName, \"propName\");\n    function attr_to_str(attrMap, options) {\n      let attrStr = \"\";\n      if (attrMap && !options.ignoreAttributes) {\n        for (let attr in attrMap) {\n          if (!attrMap.hasOwnProperty(attr))\n            continue;\n          let attrVal = options.attributeValueProcessor(attr, attrMap[attr]);\n          attrVal = replaceEntitiesValue(attrVal, options);\n          if (attrVal === true && options.suppressBooleanAttributes) {\n            attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}`;\n          } else {\n            attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}=\"${attrVal}\"`;\n          }\n        }\n      }\n      return attrStr;\n    }\n    __name(attr_to_str, \"attr_to_str\");\n    function isStopNode(jPath, options) {\n      jPath = jPath.substr(0, jPath.length - options.textNodeName.length - 1);\n      let tagName = jPath.substr(jPath.lastIndexOf(\".\") + 1);\n      for (let index in options.stopNodes) {\n        if (options.stopNodes[index] === jPath || options.stopNodes[index] === \"*.\" + tagName)\n          return true;\n      }\n      return false;\n    }\n    __name(isStopNode, \"isStopNode\");\n    function replaceEntitiesValue(textValue, options) {\n      if (textValue && textValue.length > 0 && options.processEntities) {\n        for (let i = 0; i < options.entities.length; i++) {\n          const entity = options.entities[i];\n          textValue = textValue.replace(entity.regex, entity.val);\n        }\n      }\n      return textValue;\n    }\n    __name(replaceEntitiesValue, \"replaceEntitiesValue\");\n    module2.exports = toXml;\n  }\n});\n\n// node_modules/fast-xml-parser/src/xmlbuilder/json2xml.js\nvar require_json2xml = __commonJS({\n  \"node_modules/fast-xml-parser/src/xmlbuilder/json2xml.js\"(exports2, module2) {\n    \"use strict\";\n    var buildFromOrderedJs = require_orderedJs2Xml();\n    var defaultOptions = {\n      attributeNamePrefix: \"@_\",\n      attributesGroupName: false,\n      textNodeName: \"#text\",\n      ignoreAttributes: true,\n      cdataPropName: false,\n      format: false,\n      indentBy: \"  \",\n      suppressEmptyNode: false,\n      suppressUnpairedNode: true,\n      suppressBooleanAttributes: true,\n      tagValueProcessor: function(key, a) {\n        return a;\n      },\n      attributeValueProcessor: function(attrName, a) {\n        return a;\n      },\n      preserveOrder: false,\n      commentPropName: false,\n      unpairedTags: [],\n      entities: [\n        { regex: new RegExp(\"&\", \"g\"), val: \"&amp;\" },\n        //it must be on top\n        { regex: new RegExp(\">\", \"g\"), val: \"&gt;\" },\n        { regex: new RegExp(\"<\", \"g\"), val: \"&lt;\" },\n        { regex: new RegExp(\"'\", \"g\"), val: \"&apos;\" },\n        { regex: new RegExp('\"', \"g\"), val: \"&quot;\" }\n      ],\n      processEntities: true,\n      stopNodes: [],\n      // transformTagName: false,\n      // transformAttributeName: false,\n      oneListGroup: false\n    };\n    function Builder(options) {\n      this.options = Object.assign({}, defaultOptions, options);\n      if (this.options.ignoreAttributes || this.options.attributesGroupName) {\n        this.isAttribute = function() {\n          return false;\n        };\n      } else {\n        this.attrPrefixLen = this.options.attributeNamePrefix.length;\n        this.isAttribute = isAttribute;\n      }\n      this.processTextOrObjNode = processTextOrObjNode;\n      if (this.options.format) {\n        this.indentate = indentate;\n        this.tagEndChar = \">\\n\";\n        this.newLine = \"\\n\";\n      } else {\n        this.indentate = function() {\n          return \"\";\n        };\n        this.tagEndChar = \">\";\n        this.newLine = \"\";\n      }\n    }\n    __name(Builder, \"Builder\");\n    Builder.prototype.build = function(jObj) {\n      if (this.options.preserveOrder) {\n        return buildFromOrderedJs(jObj, this.options);\n      } else {\n        if (Array.isArray(jObj) && this.options.arrayNodeName && this.options.arrayNodeName.length > 1) {\n          jObj = {\n            [this.options.arrayNodeName]: jObj\n          };\n        }\n        return this.j2x(jObj, 0).val;\n      }\n    };\n    Builder.prototype.j2x = function(jObj, level) {\n      let attrStr = \"\";\n      let val2 = \"\";\n      for (let key in jObj) {\n        if (!Object.prototype.hasOwnProperty.call(jObj, key))\n          continue;\n        if (typeof jObj[key] === \"undefined\") {\n          if (this.isAttribute(key)) {\n            val2 += \"\";\n          }\n        } else if (jObj[key] === null) {\n          if (this.isAttribute(key)) {\n            val2 += \"\";\n          } else if (key[0] === \"?\") {\n            val2 += this.indentate(level) + \"<\" + key + \"?\" + this.tagEndChar;\n          } else {\n            val2 += this.indentate(level) + \"<\" + key + \"/\" + this.tagEndChar;\n          }\n        } else if (jObj[key] instanceof Date) {\n          val2 += this.buildTextValNode(jObj[key], key, \"\", level);\n        } else if (typeof jObj[key] !== \"object\") {\n          const attr = this.isAttribute(key);\n          if (attr) {\n            attrStr += this.buildAttrPairStr(attr, \"\" + jObj[key]);\n          } else {\n            if (key === this.options.textNodeName) {\n              let newval = this.options.tagValueProcessor(key, \"\" + jObj[key]);\n              val2 += this.replaceEntitiesValue(newval);\n            } else {\n              val2 += this.buildTextValNode(jObj[key], key, \"\", level);\n            }\n          }\n        } else if (Array.isArray(jObj[key])) {\n          const arrLen = jObj[key].length;\n          let listTagVal = \"\";\n          for (let j = 0; j < arrLen; j++) {\n            const item = jObj[key][j];\n            if (typeof item === \"undefined\") {\n            } else if (item === null) {\n              if (key[0] === \"?\")\n                val2 += this.indentate(level) + \"<\" + key + \"?\" + this.tagEndChar;\n              else\n                val2 += this.indentate(level) + \"<\" + key + \"/\" + this.tagEndChar;\n            } else if (typeof item === \"object\") {\n              if (this.options.oneListGroup) {\n                listTagVal += this.j2x(item, level + 1).val;\n              } else {\n                listTagVal += this.processTextOrObjNode(item, key, level);\n              }\n            } else {\n              listTagVal += this.buildTextValNode(item, key, \"\", level);\n            }\n          }\n          if (this.options.oneListGroup) {\n            listTagVal = this.buildObjectNode(listTagVal, key, \"\", level);\n          }\n          val2 += listTagVal;\n        } else {\n          if (this.options.attributesGroupName && key === this.options.attributesGroupName) {\n            const Ks = Object.keys(jObj[key]);\n            const L = Ks.length;\n            for (let j = 0; j < L; j++) {\n              attrStr += this.buildAttrPairStr(Ks[j], \"\" + jObj[key][Ks[j]]);\n            }\n          } else {\n            val2 += this.processTextOrObjNode(jObj[key], key, level);\n          }\n        }\n      }\n      return { attrStr, val: val2 };\n    };\n    Builder.prototype.buildAttrPairStr = function(attrName, val2) {\n      val2 = this.options.attributeValueProcessor(attrName, \"\" + val2);\n      val2 = this.replaceEntitiesValue(val2);\n      if (this.options.suppressBooleanAttributes && val2 === \"true\") {\n        return \" \" + attrName;\n      } else\n        return \" \" + attrName + '=\"' + val2 + '\"';\n    };\n    function processTextOrObjNode(object, key, level) {\n      const result = this.j2x(object, level + 1);\n      if (object[this.options.textNodeName] !== void 0 && Object.keys(object).length === 1) {\n        return this.buildTextValNode(object[this.options.textNodeName], key, result.attrStr, level);\n      } else {\n        return this.buildObjectNode(result.val, key, result.attrStr, level);\n      }\n    }\n    __name(processTextOrObjNode, \"processTextOrObjNode\");\n    Builder.prototype.buildObjectNode = function(val2, key, attrStr, level) {\n      if (val2 === \"\") {\n        if (key[0] === \"?\")\n          return this.indentate(level) + \"<\" + key + attrStr + \"?\" + this.tagEndChar;\n        else {\n          return this.indentate(level) + \"<\" + key + attrStr + this.closeTag(key) + this.tagEndChar;\n        }\n      } else {\n        let tagEndExp = \"</\" + key + this.tagEndChar;\n        let piClosingChar = \"\";\n        if (key[0] === \"?\") {\n          piClosingChar = \"?\";\n          tagEndExp = \"\";\n        }\n        if ((attrStr || attrStr === \"\") && val2.indexOf(\"<\") === -1) {\n          return this.indentate(level) + \"<\" + key + attrStr + piClosingChar + \">\" + val2 + tagEndExp;\n        } else if (this.options.commentPropName !== false && key === this.options.commentPropName && piClosingChar.length === 0) {\n          return this.indentate(level) + `<!--${val2}-->` + this.newLine;\n        } else {\n          return this.indentate(level) + \"<\" + key + attrStr + piClosingChar + this.tagEndChar + val2 + this.indentate(level) + tagEndExp;\n        }\n      }\n    };\n    Builder.prototype.closeTag = function(key) {\n      let closeTag = \"\";\n      if (this.options.unpairedTags.indexOf(key) !== -1) {\n        if (!this.options.suppressUnpairedNode)\n          closeTag = \"/\";\n      } else if (this.options.suppressEmptyNode) {\n        closeTag = \"/\";\n      } else {\n        closeTag = `></${key}`;\n      }\n      return closeTag;\n    };\n    Builder.prototype.buildTextValNode = function(val2, key, attrStr, level) {\n      if (this.options.cdataPropName !== false && key === this.options.cdataPropName) {\n        return this.indentate(level) + `<![CDATA[${val2}]]>` + this.newLine;\n      } else if (this.options.commentPropName !== false && key === this.options.commentPropName) {\n        return this.indentate(level) + `<!--${val2}-->` + this.newLine;\n      } else if (key[0] === \"?\") {\n        return this.indentate(level) + \"<\" + key + attrStr + \"?\" + this.tagEndChar;\n      } else {\n        let textValue = this.options.tagValueProcessor(key, val2);\n        textValue = this.replaceEntitiesValue(textValue);\n        if (textValue === \"\") {\n          return this.indentate(level) + \"<\" + key + attrStr + this.closeTag(key) + this.tagEndChar;\n        } else {\n          return this.indentate(level) + \"<\" + key + attrStr + \">\" + textValue + \"</\" + key + this.tagEndChar;\n        }\n      }\n    };\n    Builder.prototype.replaceEntitiesValue = function(textValue) {\n      if (textValue && textValue.length > 0 && this.options.processEntities) {\n        for (let i = 0; i < this.options.entities.length; i++) {\n          const entity = this.options.entities[i];\n          textValue = textValue.replace(entity.regex, entity.val);\n        }\n      }\n      return textValue;\n    };\n    function indentate(level) {\n      return this.options.indentBy.repeat(level);\n    }\n    __name(indentate, \"indentate\");\n    function isAttribute(name) {\n      if (name.startsWith(this.options.attributeNamePrefix) && name !== this.options.textNodeName) {\n        return name.substr(this.attrPrefixLen);\n      } else {\n        return false;\n      }\n    }\n    __name(isAttribute, \"isAttribute\");\n    module2.exports = Builder;\n  }\n});\n\n// node_modules/fast-xml-parser/src/fxp.js\nvar validator = require_validator();\nvar XMLParser = require_XMLParser();\nvar XMLBuilder = require_json2xml();\nmodule.exports = {\n  XMLParser,\n  XMLValidator: validator,\n  XMLBuilder\n};\n/*! For license information please see index.js.LEGAL.txt */\n", "import { ZuploContext } from \"../../context\";\nimport { RuntimeError } from \"../../errors\";\nimport { OutboundPolicy } from \"../../policies\";\nimport { ZuploRequest } from \"../../request\";\nimport { XMLParser } from \"../../third-party/fast-xml-parser\";\nimport { statusCodesStringToNumberArray } from \"../../utils/options-parsing\";\nimport { optionValidator } from \"../../utils/validator\";\nimport { XmlToJsonPolicyOptions } from \"./options\";\n\nexport { XmlToJsonPolicyOptions };\n\n/**\n * Parses XML and converts it to JSON. This policy is useful for converting\n * legacy XML or SOAP APIs into modern REST APIs. It can be useful to add a\n * custom outbound policy that runs after this policy to further transform the\n * raw converted content into something more user friendly.\n *\n * @title XML to JSON Outbound\n * @public\n * @param request - The ZuploRequest\n * @param context - The ZuploContext\n * @param options - The policy options set in policies.json\n * @param policyName - The name of the policy as set in policies.json\n * @returns A Request or a Response\n */\nexport class XmlToJsonOutboundPolicy extends OutboundPolicy<XmlToJsonPolicyOptions> {\n  private parser: XMLParser;\n  private parseOnStatusCodes: number[] | undefined;\n\n  constructor(options: XmlToJsonPolicyOptions, policyName: string) {\n    super(options, policyName);\n\n    optionValidator(this.options, this.policyName)\n      .optional(\"removeNSPrefix\", \"boolean\")\n      .optional(\"ignoreProcessingInstructions\", \"boolean\")\n      .optional(\"ignoreDeclarations\", \"boolean\")\n      .optional(\"ignoreAttributes\", \"boolean\")\n      .optional(\"stopNodes\", \"array\")\n      .optional(\"attributeNamePrefix\", \"string\")\n      .optional(\"textNodeName\", \"string\")\n      .optional(\"trimValues\", \"boolean\");\n\n    this.parseOnStatusCodes = options.parseOnStatusCodes\n      ? statusCodesStringToNumberArray(options.parseOnStatusCodes)\n      : undefined;\n\n    this.parser = new XMLParser({\n      removeNSPrefix: options?.removeNSPrefix ?? true,\n      ignorePiTags: options?.ignoreProcessingInstructions ?? true,\n      ignoreDeclaration: options?.ignoreDeclarations ?? true,\n      ignoreAttributes: options?.ignoreAttributes ?? true,\n      stopNodes: options?.stopNodes ?? [],\n      attributeNamePrefix: options?.attributeNamePrefix ?? \"@_\",\n      textNodeName: options?.textNodeName ?? \"#text\",\n      trimValues: options?.trimValues ?? true,\n    });\n  }\n\n  async handler(\n    response: Response,\n    request: ZuploRequest,\n    context: ZuploContext\n  ) {\n    // If the parseOnStatusCodes option is set, check that the current response\n    // is included, if not just continue without converting.\n    if (\n      this.parseOnStatusCodes &&\n      !this.parseOnStatusCodes.includes(response.status)\n    ) {\n      return response;\n    }\n\n    let obj: unknown;\n    try {\n      const xml = await response.text();\n\n      obj = this.parser.parse(xml);\n    } catch (err) {\n      const message = `XmlToJsonOutboundPolicy - Error parsing XML contents in policy '${this.policyName}'.`;\n      context.log.error(message, err);\n      throw new RuntimeError(message);\n    }\n\n    const headers = new Headers(response.headers);\n    headers.set(\"content-type\", \"application/json\");\n\n    const newResponse = new Response(JSON.stringify(obj), {\n      status: response.status,\n      statusText: response.statusText,\n      headers,\n    });\n\n    return newResponse;\n  }\n}\n", "import { SystemError } from \"./errors\";\nimport { ServiceProvider } from \"./interfaces\";\n\n/**\n * @internal\n */\nexport class ServiceProviderImpl implements ServiceProvider {\n  private services: Map<string, unknown> = new Map();\n\n  public addService<T>(name: string, service: T) {\n    if (this.services.get(name)) {\n      throw new SystemError(\n        `A service with the name ${name} already exists -- you cannot have duplicate services`\n      );\n    }\n\n    this.services.set(name, service);\n  }\n\n  public getService<T>(name: string): T {\n    return this.services.get(name) as T;\n  }\n}\n", "import { BatchDispatch, DispatchFunction } from \"./batch-dispatch\";\nimport { getGlobalZuploEventContext } from \"./global-zuplo-event-context\";\n\nexport { BatchDispatch };\nexport interface BatchDispatcherOptions {\n  msDelay: number;\n  name?: string;\n}\n\nexport class BackgroundDispatcher<TPayload> {\n  #innerBatchDispatcher: BatchDispatch<TPayload>;\n\n  constructor(\n    dispatcher: DispatchFunction<TPayload>,\n    options: BatchDispatcherOptions\n  ) {\n    if (!options || options.msDelay === undefined) {\n      throw new Error(\"BackgroundDispatcher: options.msDelay is required\");\n    }\n\n    this.#innerBatchDispatcher = new BatchDispatch<TPayload>(\n      options.name ?? \"\",\n      options.msDelay,\n      dispatcher\n    );\n  }\n\n  enqueue = (payload: TPayload): void => {\n    this.#innerBatchDispatcher.enqueue(payload);\n    const fetchEvent = getGlobalZuploEventContext();\n    fetchEvent.waitUntil(this.#innerBatchDispatcher.waitUntilFlushed());\n  };\n}\n", "import { getGlobalZuploEventContext } from \"./global-zuplo-event-context\";\n\nexport interface BackgroundLoaderFunction<T> {\n  (key: string): Promise<T>;\n}\n\nexport class BackgroundLoader<T = unknown> {\n  #cache = new Map<string, { data: T; expiry: Date }>();\n  #loader: BackgroundLoaderFunction<T>;\n  #ttl: number;\n  #refreshPromises = new Map<string, WrappedPromise<T>>();\n\n  constructor(loader: BackgroundLoaderFunction<T>, ttlSeconds: number) {\n    this.#loader = loader;\n    this.#ttl = ttlSeconds * 1000;\n  }\n\n  #updateExpiry(key: string): void {\n    const cacheEntry = this.#cache.get(key);\n    if (cacheEntry) {\n      cacheEntry.expiry = new Date(Date.now() + this.#ttl);\n    }\n  }\n\n  #isExpired(cacheEntry: { data: T; expiry: Date }): boolean {\n    return cacheEntry.expiry <= new Date();\n  }\n\n  async get(key: string): Promise<T> {\n    const cacheEntry = this.#cache.get(key);\n\n    if (cacheEntry && !this.#isExpired(cacheEntry)) {\n      void this.#refreshInBackground(key);\n      return cacheEntry.data;\n    }\n\n    return this.#loadAndCache(key);\n  }\n\n  async #refreshInBackground(key: string): Promise<T> {\n    const currentPromise = this.#refreshPromises.get(key);\n    if (currentPromise !== undefined) {\n      return currentPromise.wrap();\n    }\n\n    const refreshPromise = this.#loadAndCache(key);\n    this.#refreshPromises.set(key, new WrappedPromise(refreshPromise));\n    await new WrappedPromise(refreshPromise).wrap();\n    this.#refreshPromises.delete(key);\n    return refreshPromise;\n  }\n\n  async #loadAndCache(key: string): Promise<T> {\n    let promise = this.#refreshPromises.get(key);\n    if (promise === undefined) {\n      const innerPromise = this.#loader(key);\n      promise = new WrappedPromise(innerPromise);\n      this.#updateExpiry(key);\n      const result = await promise.wrap();\n      this.#cache.set(key, {\n        data: result,\n        expiry: new Date(Date.now() + this.#ttl),\n      });\n    }\n    return promise.wrap();\n  }\n}\n\ninterface ResolveReject<T> {\n  resolve: (value: T | PromiseLike<T>) => void;\n  reject: (reason?: unknown) => void;\n}\n\nclass WrappedPromise<T> {\n  #innerPromise: Promise<T>;\n  #subPromises: ResolveReject<T>[] = [];\n  #resolvedValue: T | undefined;\n  #resolvedReason: unknown;\n\n  constructor(promise: Promise<T>) {\n    // need to do this to stop CF giving up on us\n    const event = getGlobalZuploEventContext();\n    event.waitUntil(promise);\n    this.#innerPromise = promise;\n    this.#innerPromise\n      .then((value) => {\n        this.#subPromises.forEach((resRej) => resRej.resolve(value));\n        this.#resolvedValue = value;\n      })\n      .catch((reason) => {\n        this.#subPromises.forEach((resRej) => resRej.reject(reason));\n        this.#resolvedReason = reason;\n      });\n  }\n\n  async wrap() {\n    if (this.#resolvedReason) {\n      throw this.#resolvedReason;\n    }\n\n    if (this.#resolvedValue) {\n      return this.#resolvedValue;\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const wrapper = this;\n\n    const p = new Promise<T>((resolve, reject) => {\n      wrapper.#subPromises.push({ resolve, reject });\n    });\n\n    return p;\n  }\n}\n", "// Very important that these are is the first thing.\nimport \"./internals\";\nimport \"./security\";\n\nexport { MemoryZoneReadThroughCache } from \"./caches/memory-zone-readthrough-cache\";\nexport { ZoneCache } from \"./caches/zone-cache\";\nexport { SYSTEM_LOGGER } from \"./constants\";\nexport {\n  ResponseSendingEvent,\n  ResponseSentEvent,\n  ZuploContext,\n} from \"./context\";\nexport { ContextData } from \"./context-data\";\nexport { SemanticAttributes } from \"./diagnostics/attributes\";\nexport {\n  RequestHandlerFunction,\n  RequestHandlerProxy,\n} from \"./diagnostics/telemetry\";\nexport { environment } from \"./environment\";\nexport { ConfigurationError, RuntimeError } from \"./errors\";\nexport { RuntimeExtensions, RuntimeExtensionsFunction } from \"./extensions\";\nexport { Handler } from \"./handler\";\nexport {\n  AwsLambdaHandlerExtensions,\n  awsLambdaHandler,\n} from \"./handlers/aws-lambda\";\nexport { openApiSpecHandler } from \"./handlers/open-api\";\nexport { redirectHandler } from \"./handlers/redirect\";\nexport { urlForwardHandler } from \"./handlers/url-forward\";\nexport { urlRewriteHandler } from \"./handlers/url-rewrite\";\nexport { webSocketHandler } from \"./handlers/websocket-handler\";\nexport { webSocketPipelineHandler } from \"./handlers/websocket-pipeline-handler\";\nexport { HttpStatusCode } from \"./http-status\";\nexport {\n  CustomRateLimitDetails,\n  RequestContext,\n  ServiceProvider,\n  ZuploEventContext,\n} from \"./interfaces\";\nexport { LogLevel, Logger } from \"./logging/interfaces\";\nexport * from \"./logging/v1/transports/plugins\";\nexport { StoredMeteringSubscriptionWithQuotas as MonetizationSubscription } from \"./metering-interfaces\";\nexport * from \"./metrics/v1/transports/plugins\";\nexport {\n  AuditLogDataStaxInit,\n  AuditLogDataStaxProvider,\n} from \"./plugins/audit-log-output-providers/audit-log-datastax-provider\";\nexport { AuditLogInit, AuditLogPlugin } from \"./plugins/audit-log-plugin\";\nexport {\n  TelemetryInitializationOptions,\n  TelemetryPlugin,\n} from \"./plugins/plugins\";\nexport * from \"./plugins/stripe-monetization-plugin\";\nexport {\n  InboundPolicy,\n  InboundPolicyHandler,\n  OutboundPolicy,\n  OutboundPolicyHandler,\n} from \"./policies\";\nexport {\n  AmberfloMeteringInboundPolicy,\n  AmberfloMeteringInboundPolicyOptions,\n  AmberfloMeteringPolicy,\n} from \"./policies/amberflo-metering-inbound/policy\";\nexport {\n  ApiAuthKeyInboundPolicy,\n  ApiAuthKeyInboundPolicyOptions,\n} from \"./policies/api-key-auth-inbound/policy\";\nexport {\n  ApiKeyInboundPolicy,\n  ApiKeyInboundPolicyOptions,\n} from \"./policies/api-key-inbound/policy\";\nexport {\n  Auth0JwtInboundPolicy,\n  Auth0JwtInboundPolicyOptions,\n} from \"./policies/auth0-jwt-auth-inbound/policy\";\nexport {\n  BasicAuthInboundPolicy,\n  BasicAuthInboundPolicyOptions,\n} from \"./policies/basic-auth-inbound/policy\";\nexport {\n  CachingInboundPolicy,\n  CachingInboundPolicyOptions,\n} from \"./policies/caching-inbound/policy\";\nexport {\n  ChangeMethodInboundPolicy,\n  ChangeMethodInboundPolicyOptions,\n} from \"./policies/change-method-inbound/policy\";\nexport {\n  ClearHeadersInboundPolicy,\n  ClearHeadersInboundPolicyOptions,\n} from \"./policies/clear-headers-inbound/policy\";\nexport {\n  ClearHeadersOutboundPolicy,\n  ClearHeadersOutboundPolicyOptions,\n} from \"./policies/clear-headers-outbound/policy\";\nexport {\n  ClerkJwtInboundPolicy,\n  ClerkJwtInboundPolicyOptions,\n} from \"./policies/clerk-jwt-auth-inbound/policy\";\nexport {\n  CognitoJwtInboundPolicy,\n  CognitoJwtInboundPolicyOptions,\n} from \"./policies/cognito-jwt-auth-inbound/policy\";\nexport {\n  CompositeInboundPolicy,\n  CompositeInboundPolicyOptions,\n} from \"./policies/composite-inbound/policy\";\nexport {\n  CurityPhantomTokenInboundPolicy,\n  CurityPhantomTokenInboundPolicyOptions,\n} from \"./policies/curity-phantom-token-inbound/policy\";\nexport {\n  FirebaseJwtInboundPolicy,\n  FirebaseJwtInboundPolicyOptions,\n} from \"./policies/firebase-jwt-inbound/policy\";\nexport {\n  FormDataToJsonInboundPolicy,\n  FormDataToJsonInboundPolicyOptions,\n} from \"./policies/formdata-to-json-inbound/policy\";\nexport {\n  GeoFilterInboundPolicy,\n  GeoFilterInboundPolicyOptions,\n} from \"./policies/geo-filter-inbound/policy\";\nexport {\n  JWTScopeValidationInboundPolicy,\n  JWTScopeValidationInboundPolicyOptions,\n} from \"./policies/jwt-scopes-inbound/policy\";\nexport {\n  MockApiInboundOptions,\n  MockApiInboundPolicy,\n} from \"./policies/mock-api-inbound/policy\";\nexport {\n  MoesifInboundPolicy,\n  MoesifInboundPolicyOptions,\n  setMoesifContext,\n} from \"./policies/moesif-inbound/policy\";\nexport {\n  MonetizationInboundPolicy,\n  MonetizationInboundPolicyOptions,\n} from \"./policies/monetization-inbound/policy\";\nexport {\n  OktaJwtInboundPolicy,\n  OktaJwtInboundPolicyOptions,\n} from \"./policies/okta-jwt-auth-inbound/policy\";\nexport {\n  OpenIdJwtInboundPolicy,\n  OpenIdJwtInboundPolicyOptions,\n} from \"./policies/open-id-jwt-auth-inbound/policy\";\nexport {\n  PropelAuthJwtInboundPolicy,\n  PropelAuthJwtInboundPolicyOptions,\n} from \"./policies/propel-auth-jwt-inbound/policy\";\nexport {\n  // support for the legacy name 'Basic..'\n  RateLimitInboundPolicy as BasicRateLimitInboundPolicy,\n  RateLimitInboundPolicyOptions as BasicRateLimitInboundPolicyOptions,\n  RateLimitInboundPolicy as RateLimitInboundPolicy,\n  RateLimitInboundPolicyOptions as RateLimitInboundPolicyOptions,\n} from \"./policies/rate-limit-inbound/policy\";\nexport { ReadmeMetricsInboundPolicy } from \"./policies/readme-metrics-inbound/policy\";\nexport {\n  RemoveHeadersInboundPolicy,\n  RemoveHeadersInboundPolicyOptions,\n} from \"./policies/remove-headers-inbound/policy\";\nexport {\n  RemoveHeadersOutboundPolicy,\n  RemoveHeadersOutboundPolicyOptions,\n} from \"./policies/remove-headers-outbound/policy\";\nexport {\n  RemoveQueryParamsInboundPolicy,\n  RemoveQueryParamsInboundPolicyOptions,\n} from \"./policies/remove-query-params-inbound/policy\";\nexport {\n  ReplaceStringOutboundPolicy,\n  ReplaceStringOutboundPolicyOptions,\n} from \"./policies/replace-string-outbound/policy\";\nexport {\n  RequestSizeLimitInboundPolicy,\n  RequestSizeLimitInboundPolicyOptions,\n} from \"./policies/request-size-limit-inbound/policy\";\nexport {\n  RequestValidationInboundPolicy,\n  RequestValidationInboundPolicyOptions,\n  SchemaBasedRequestValidation,\n} from \"./policies/request-validation-inbound/policy\";\nexport {\n  RequireOriginInboundPolicy,\n  RequireOriginInboundPolicyOptions,\n} from \"./policies/require-origin-inbound/policy\";\nexport {\n  SetBodyInboundPolicy,\n  SetBodyInboundPolicyOptions,\n} from \"./policies/set-body-inbound/policy\";\nexport {\n  SetHeadersInboundPolicy,\n  SetHeadersInboundPolicyOptions,\n} from \"./policies/set-headers-inbound/policy\";\nexport {\n  SetHeadersOutboundPolicy,\n  SetHeadersOutboundPolicyOptions,\n} from \"./policies/set-headers-outbound/policy\";\nexport {\n  SetQueryParamsInboundPolicy,\n  SetQueryParamsInboundPolicyOptions,\n} from \"./policies/set-query-params-inbound/policy\";\nexport {\n  SetStatusOutboundPolicy,\n  SetStatusOutboundPolicyOptions,\n} from \"./policies/set-status-outbound/policy\";\nexport {\n  SleepInboundPolicy,\n  SleepInboundPolicyOptions,\n} from \"./policies/sleep-inbound/policy\";\nexport {\n  StripeWebhookVerificationInboundPolicy,\n  StripeWebhookVerificationInboundPolicyOptions,\n} from \"./policies/stripe-webhook-verification-inbound/policy\";\nexport {\n  SupabaseJwtInboundPolicy,\n  SupabaseJwtInboundPolicyOptions,\n} from \"./policies/supabase-jwt-auth-inbound/policy\";\nexport {\n  UpstreamAzureAdServiceAuthInboundPolicy,\n  UpstreamAzureAdServiceAuthInboundPolicyOptions,\n} from \"./policies/upstream-azure-ad-service-auth-inbound/policy\";\nexport {\n  UpstreamFirebaseAdminAuthInboundPolicy,\n  UpstreamFirebaseAdminAuthInboundPolicyOptions,\n} from \"./policies/upstream-firebase-admin-auth-inbound/policy\";\nexport {\n  UpstreamFirebaseUserAuthInboundPolicy,\n  UpstreamFirebaseUserAuthInboundPolicyOptions,\n} from \"./policies/upstream-firebase-user-auth-inbound/policy\";\nexport {\n  UpstreamGcpJwtInboundPolicy,\n  UpstreamGcpJwtInboundPolicyOptions,\n} from \"./policies/upstream-gcp-jwt-inbound/policy\";\nexport {\n  UpstreamGcpServiceAuthInboundPolicy,\n  UpstreamGcpServiceAuthInboundPolicyOptions,\n} from \"./policies/upstream-gcp-service-auth-inbound/policy\";\nexport {\n  ValidateJsonSchemaInbound,\n  ValidateJsonSchemaInboundOptions,\n} from \"./policies/validate-json-schema-inbound/policy\";\nexport {\n  XmlToJsonOutboundPolicy,\n  XmlToJsonPolicyOptions,\n} from \"./policies/xml-to-json-outbound/policy\";\nexport { HttpProblems } from \"./problem-responses/http-problems\";\nexport { ProblemResponseDetails } from \"./problem-responses/problem\";\nexport {\n  ProblemResponseFormat,\n  ProblemResponseFormatter,\n} from \"./problem-responses/problem-response-formatter\";\nexport { RequestUser, ZuploRequest } from \"./request\";\nexport {\n  CorsPolicy,\n  CorsPolicyConfiguration,\n  HandlerDefinition,\n  HttpMethod,\n  ParameterBaseObject,\n  ParameterDefinition,\n  PolicyConfiguration,\n  ResponsesDefinition,\n  RouteConfiguration,\n  RouteData,\n  SystemRouteName,\n  VersionData,\n} from \"./router/interfaces\";\nexport {\n  ErrorHandler,\n  LookupResult,\n  RouteHandler,\n  Router,\n} from \"./router/router\";\nexport { ContentTypes, serialize } from \"./serializer\";\nexport { ServiceProviderImpl } from \"./service-provider\";\nexport { default as httpStatuses } from \"./statuses\";\nexport {\n  BackgroundDispatcher,\n  BatchDispatch,\n} from \"./utils/background-dispatcher\";\nexport { BackgroundLoader } from \"./utils/background-loader\";\nexport {\n  getIdForParameterSchema,\n  getIdForRefSchema,\n  getIdForRequestBodySchema,\n  getRawOperationDataIdentifierName,\n  sanitizedIdentifierName,\n} from \"./utils/open-api-utils\";\n", "// https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/digest\n/**\n * @beta\n */\nexport const supportedDigests = [\"sha-1\", \"sha-256\", \"sha-384\", \"sha-512\"];\n\n/**\n * @beta\n */\nexport abstract class BaseCryptoBeta {\n  abstract digest(algorithm: string, data: string): Promise<string>;\n}\n", "import { BaseCryptoBeta, supportedDigests } from \"../../crypto-beta\";\nimport { RuntimeError } from \"../../errors\";\n\n/**\n * @beta\n */\nexport class WorkerCryptoBeta extends BaseCryptoBeta {\n  async digest(algorithm: string, data: string): Promise<string> {\n    if (!supportedDigests.includes(algorithm.toLowerCase())) {\n      throw new RuntimeError(\n        `Algorithm ${algorithm} is not supported. Try using ${supportedDigests.join(\n          \", \"\n        )}`\n      );\n    }\n    const msgUint8 = new TextEncoder().encode(data);\n    const hashBuffer = await crypto.subtle.digest(algorithm, msgUint8);\n    const hashArray = Array.from(new Uint8Array(hashBuffer));\n    const hashHex = hashArray\n      .map((b) => b.toString(16).padStart(2, \"0\"))\n      .join(\"\");\n    return hashHex;\n  }\n}\n", "import { ZuploContext } from \"./context\";\n\n/**\n * @beta\n */\nexport interface KeyValueStorePutOptions {\n  expirationSecondsTtl?: number;\n}\n\n/**\n * @beta\n */\nexport interface KevValueStoreGetOptions {\n  cacheSecondsTtl?: number;\n}\n\n/**\n * @beta\n */\nexport abstract class BaseKeyValueStore {\n  constructor(protected context: ZuploContext) {}\n\n  abstract put(\n    key: string,\n    value: string,\n    options?: KeyValueStorePutOptions\n  ): Promise<void>;\n  abstract get(\n    key: string,\n    options?: KevValueStoreGetOptions\n  ): Promise<string | null>;\n  abstract delete(key: string): Promise<void>;\n}\n", "import type { KVNamespace } from \"@cloudflare/workers-types/2021-11-03\";\nimport { ZuploContext } from \"../../context\";\nimport { ConfigurationError, FeatureNotEnabledError } from \"../../errors\";\nimport {\n  BaseKeyValueStore,\n  KevValueStoreGetOptions,\n  KeyValueStorePutOptions,\n} from \"../../key-value-store\";\nimport { Environment } from \"../../utils/environment\";\n\n/**\n * @beta\n */\nexport class WorkerKeyValueStore extends BaseKeyValueStore {\n  #kv: KVNamespace;\n\n  constructor(context: ZuploContext) {\n    super(context);\n    // Hack to get binding in cloudflare\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const kv = (Environment.instance.runtime as any).ZUPLO_KV as\n      | KVNamespace\n      | undefined;\n    if (!kv) {\n      throw new FeatureNotEnabledError(\n        \"The Key Value Store feature is not enabled for this project.\"\n      );\n    }\n    this.#kv = kv;\n  }\n\n  put(\n    key: string,\n    value: string,\n    options?: KeyValueStorePutOptions\n  ): Promise<void> {\n    if (typeof key !== \"string\") {\n      throw new ConfigurationError(\"value must be of type string\");\n    }\n    return this.#kv.put(\n      key,\n      value,\n      options ? { expirationTtl: options.expirationSecondsTtl } : undefined\n    );\n  }\n\n  get(key: string, options?: KevValueStoreGetOptions): Promise<string | null> {\n    return this.#kv.get(key, {\n      type: \"text\",\n      cacheTtl: options?.cacheSecondsTtl,\n    });\n  }\n\n  delete(key: string): Promise<void> {\n    return this.#kv.delete(key);\n  }\n}\n", "// eslint-disable-next-line no-restricted-imports\nexport * from \".\";\nexport { WorkerCryptoBeta as CryptoBeta } from \"./platforms/worker/crypto-beta\";\nexport { WorkerKeyValueStore as KeyValueStore } from \"./platforms/worker/key-value-store\";\n", "", "module.exports = {\"sitePathname\":\"/docs\",\"enabled\":true}", "import { Handler, ServiceProviderImpl } from \"@zuplo/runtime\";\nimport routeLoader from \"../config/routes.json\";\nimport * as schemaValidations from \"./ajv-schema.json\";\nimport { runtimeInit } from \"../modules/zuplo.runtime.ts\";\nimport developerPortal from \"../config/dev-portal.json\";\nimport buildEnvironment from \"./build.json\";\n\n// Instantiate services\nconst serviceProvider = new ServiceProviderImpl();\n\n// This is needed because we are using worker script (instead of module)\n// And we need to make this available outside of this file.\nglobalThis[\"__ZUPLO_SERVICE_PROVIDER\"] = serviceProvider;\n\nconst runtimeSettings = { developerPortal };\n\nconst handler = new Handler(\n  routeLoader,\n  buildEnvironment,\n  runtimeSettings,\n  serviceProvider,\n  schemaValidations,\n  runtimeInit\n);\n\naddEventListener(\"fetch\", (event) => {\n  event.respondWith(handler.requestHandler(event.request, globalThis, event));\n});\n", "\n  import { environment } from \"@zuplo/runtime\";\n  import rawRouteData from \"./raw.json\";\n  const routes = () => ({\n    routes: [\n      {raw:() => {return rawRouteData._routes__openapi_get;},version:\"none\",methods:[\"GET\",],pathPattern:\"/openapi{/}?\",path:\"/openapi\",corsPolicy:\"anything-goes\",handler:{export:\"openApiSpecHandler\",module:require(\"@zuplo/runtime\",),options:{openApiFilePath:\"./config/routes.oas.json\",},},policies:{inbound:[],},},\n      {raw:() => {return rawRouteData._routes__ap1_v1_entity_findByStatus_get;},version:\"none\",methods:[\"GET\",],pathPattern:\"/ap1/v1/entity/findByStatus{/}?\",path:\"/ap1/v1/entity/findByStatus\",corsPolicy:\"none\",handler:{export:\"urlForwardHandler\",module:require(\"@zuplo/runtime\",),options:{baseUrl:\"http://sagent-sample-url\",__rewriteFunction:(request, context) => {\n    const { params, url, query, method, headers } = request;\n    const { host, hostname, origin, pathname, port, search } = new URL(url);\n    const e = encodeURIComponent;\n    const env = environment;\n    return `http://sagent-sample-url`\n  },},},policies:{inbound:[\"rate-limit-inbound\",],},},\n      {raw:() => {return rawRouteData._routes__ap1_v1_entity_update_put;},version:\"none\",methods:[\"PUT\",],pathPattern:\"/ap1/v1/entity/update{/}?\",path:\"/ap1/v1/entity/update\",corsPolicy:\"none\",handler:{export:\"urlForwardHandler\",module:require(\"@zuplo/runtime\",),options:{baseUrl:\"http://sagent-sample-url\",__rewriteFunction:(request, context) => {\n    const { params, url, query, method, headers } = request;\n    const { host, hostname, origin, pathname, port, search } = new URL(url);\n    const e = encodeURIComponent;\n    const env = environment;\n    return `http://sagent-sample-url`\n  },},},policies:{inbound:[\"rate-limit-inbound\",],},},\n      {raw:() => {return rawRouteData._routes__ap1_v1_entity_delete__entityId__delete;},version:\"none\",methods:[\"DELETE\",],pathPattern:\"/ap1/v1/entity/delete/:entityId{/}?\",path:\"/ap1/v1/entity/delete/{entityId}\",corsPolicy:\"none\",handler:{export:\"urlForwardHandler\",module:require(\"@zuplo/runtime\",),options:{baseUrl:\"http://sagent-sample-url\",__rewriteFunction:(request, context) => {\n    const { params, url, query, method, headers } = request;\n    const { host, hostname, origin, pathname, port, search } = new URL(url);\n    const e = encodeURIComponent;\n    const env = environment;\n    return `http://sagent-sample-url`\n  },},},policies:{inbound:[],},},\n      {raw:() => {return rawRouteData._routes__api_v1_entity_create_post;},version:\"none\",methods:[\"POST\",],pathPattern:\"/api/v1/entity/create{/}?\",path:\"/api/v1/entity/create\",corsPolicy:\"none\",handler:{export:\"urlForwardHandler\",module:require(\"@zuplo/runtime\",),options:{baseUrl:\"http://sagent-sample-url\",__rewriteFunction:(request, context) => {\n    const { params, url, query, method, headers } = request;\n    const { host, hostname, origin, pathname, port, search } = new URL(url);\n    const e = encodeURIComponent;\n    const env = environment;\n    return `http://sagent-sample-url`\n  },},},policies:{inbound:[],},},\n    ],\n    policies:[{handler:{export:\"RateLimitInboundPolicy\",module:require(\"@zuplo/runtime\",),options:{rateLimitBy:\"ip\",requestsAllowed:2,timeWindowMinutes:1,},},name:\"rate-limit-inbound\",policyType:\"rate-limit-inbound\",},{handler:{export:\"ApiKeyInboundPolicy\",module:require(\"@zuplo/runtime\",),options:{allowUnauthenticatedRequests:false,cacheTtlSeconds:60,},},name:\"api-key-inbound\",policyType:\"api-key-inbound\",},],\n    corsPolicies: [],\n    versions: [\n      { name: \"none\", pathPrefix: \"\" },\n    ],\n  });\n  export default routes;\n  ", "const routes_refsData_0 = {\n\"type\": \"object\",\n\"required\":[\n\"name\",\n\"photoUrls\",\n],\n\"properties\":{\n\"id\":{\n\"type\": \"integer\",\n\"format\": \"int64\",\n\"readOnly\":true,\n},\ncategory: routes_refsData_1,\n\"name\":{\n\"type\": \"string\",\n\"example\": \"doggie\",\n},\n\"photoUrls\":{\n\"type\": \"array\",\n\"xml\":{\n\"name\": \"photoUrl\",\n\"wrapped\":true,\n},\n\"items\":{\n\"type\": \"string\",\n},\n},\n\"tags\":{\n\"type\": \"array\",\n\"xml\":{\n\"name\": \"tag\",\n\"wrapped\":true,\n},\nitems: routes_refsData_2,\n},\n\"status\":{\n\"type\": \"string\",\n\"description\": \"entities status in the store\",\n\"enum\":[\n\"available\",\n\"pending\",\n\"sold\",\n],\n},\n},\n\"xml\":{\n\"name\": \"Entity\",\n},\n};\nconst routes_refsData_1 = {\n\"type\": \"object\",\n\"properties\":{\n\"id\":{\n\"type\": \"integer\",\n\"format\": \"int64\",\n},\n\"name\":{\n\"type\": \"string\",\n},\n},\n\"xml\":{\n\"name\": \"Category\",\n},\n};\nconst routes_refsData_2 = {\n\"type\": \"object\",\n\"properties\":{\n\"id\":{\n\"type\": \"integer\",\n\"format\": \"int64\",\n},\n\"name\":{\n\"type\": \"string\",\n},\n},\n\"xml\":{\n\"name\": \"Tag\",\n},\n};\nconst routes_refsData_3 = {\n\"content\":{\n\"application/json\":{\nschema: routes_refsData_0,\n},\n\"application/xml\":{\nschema: routes_refsData_0,\n},\n},\n\"description\": \"Entity object that needs to be added to the store\",\n\"required\":true,\n};const rawRouteData = {\n_routes__openapi_x_zuplo_path: {\n\"pathMode\": \"open-api\",\n},_routes__openapi_get: {\n\"summary\": \"OpenAPI Spec\",\n\"x-zuplo-route\":{\n\"corsPolicy\": \"anything-goes\",\n\"handler\":{\n\"export\": \"openApiSpecHandler\",\n\"module\": \"$import(@zuplo/runtime)\",\n\"options\":{\n\"openApiFilePath\": \"./config/routes.oas.json\",\n},\n},\n\"policies\":{\n\"inbound\":[\n],\n},\n},\n\"operationId\": \"f8d5c981-b173-4d3d-8a74-ce1f3f1ea2a3\",\n},_routes__ap1_v1_entity_findByStatus_x_zuplo_path: {\n\"pathMode\": \"open-api\",\n},_routes__ap1_v1_entity_findByStatus_get: {\n\"tags\":[\n\"entities\",\n],\n\"summary\": \"Find all entities by status\",\n\"operationId\": \"findPetsByStatus\",\n\"parameters\":[\n{\n\"name\": \"status\",\n\"in\": \"query\",\n\"description\": \"Status values that need to be considered for filter\",\n\"required\":true,\n\"explode\":true,\n\"schema\":{\n\"type\": \"array\",\n\"items\":{\n\"type\": \"string\",\n\"enum\":[\n\"available\",\n\"pending\",\n\"sold\",\n],\n\"default\": \"available\",\n},\n},\n},\n],\n\"responses\":{\n\"200\":{\n\"description\": \"successful operation\",\n\"content\":{\n\"application/xml\":{\n\"schema\":{\n\"type\": \"array\",\nitems: routes_refsData_0,\n},\n},\n\"application/json\":{\n\"schema\":{\n\"type\": \"array\",\nitems: routes_refsData_0,\n},\n},\n},\n},\n\"400\":{\n\"description\": \"Invalid status value\",\n},\n},\n\"security\":[\n{\n\"petstore_auth\":[\n\"write:entities\",\n\"read:entities\",\n],\n},\n],\n\"x-zuplo-route\":{\n\"corsPolicy\": \"none\",\n\"handler\":{\n\"export\": \"urlForwardHandler\",\n\"module\": \"$import(@zuplo/runtime)\",\n\"options\":{\n\"baseUrl\": \"http://sagent-sample-url\",\n},\n},\n\"policies\":{\n\"inbound\":[\n\"rate-limit-inbound\",\n],\n},\n},\n},_routes__ap1_v1_entity_update_x_zuplo_path: {\n\"pathMode\": \"open-api\",\n},_routes__ap1_v1_entity_update_put: {\n\"tags\":[\n\"entities\",\n],\n\"summary\": \"Update an existing entity\",\n\"operationId\": \"updatePet\",\n\"parameters\":[\n],\n\"responses\":{\n\"400\":{\n\"description\": \"Invalid ID supplied\",\n},\n\"404\":{\n\"description\": \"Entity not found\",\n},\n\"405\":{\n\"description\": \"Validation exception\",\n},\n},\n\"security\":[\n{\n\"petstore_auth\":[\n\"write:entities\",\n\"read:entities\",\n],\n},\n],\nrequestBody: routes_refsData_3,\n\"x-zuplo-route\":{\n\"corsPolicy\": \"none\",\n\"handler\":{\n\"export\": \"urlForwardHandler\",\n\"module\": \"$import(@zuplo/runtime)\",\n\"options\":{\n\"baseUrl\": \"http://sagent-sample-url\",\n},\n},\n\"policies\":{\n\"inbound\":[\n\"rate-limit-inbound\",\n],\n},\n},\n},_routes__ap1_v1_entity_delete__entityId__x_zuplo_path: {\n\"pathMode\": \"open-api\",\n},_routes__ap1_v1_entity_delete__entityId__delete: {\n\"tags\":[\n\"entities\",\n],\n\"summary\": \"Deletes an Entity\",\n\"operationId\": \"deletePet\",\n\"parameters\":[\n{\n\"name\": \"api_key\",\n\"in\": \"header\",\n\"required\":false,\n\"schema\":{\n\"type\": \"string\",\n},\n},\n{\n\"name\": \"petId\",\n\"in\": \"path\",\n\"description\": \"Entity id to delete\",\n\"required\":true,\n\"schema\":{\n\"type\": \"integer\",\n\"format\": \"int64\",\n},\n},\n],\n\"responses\":{\n\"400\":{\n\"description\": \"Invalid ID supplied\",\n},\n\"404\":{\n\"description\": \"Entity not found\",\n},\n},\n\"security\":[\n{\n\"petstore_auth\":[\n\"write:entities\",\n\"read:entities\",\n],\n},\n],\n\"x-zuplo-route\":{\n\"corsPolicy\": \"none\",\n\"handler\":{\n\"export\": \"urlForwardHandler\",\n\"module\": \"$import(@zuplo/runtime)\",\n\"options\":{\n\"baseUrl\": \"http://sagent-sample-url\",\n},\n},\n\"policies\":{\n\"inbound\":[\n],\n},\n},\n},_routes__api_v1_entity_create_x_zuplo_path: {\n\"pathMode\": \"open-api\",\n},_routes__api_v1_entity_create_post: {\n\"tags\":[\n\"entities\",\n],\n\"summary\": \"Create a new Entity\",\n\"operationId\": \"addPet\",\n\"parameters\":[\n],\n\"responses\":{\n\"405\":{\n\"description\": \"Invalid input\",\n},\n},\n\"security\":[\n{\n\"petstore_auth\":[\n\"write:entities\",\n\"read:entities\",\n],\n},\n],\nrequestBody: routes_refsData_3,\n\"x-internal\":false,\n\"x-zuplo-route\":{\n\"corsPolicy\": \"none\",\n\"handler\":{\n\"export\": \"urlForwardHandler\",\n\"module\": \"$import(@zuplo/runtime)\",\n\"options\":{\n\"baseUrl\": \"http://sagent-sample-url\",\n},\n},\n\"policies\":{\n\"inbound\":[\n],\n},\n},\n}\n};\nexport default rawRouteData;", "export const runtimeInit = undefined;", "{\n  \"BUILD_ID\": \"0688b7b7-53d0-4c7d-a3a2-d8356134773b\",\n  \"TIMESTAMP\": \"2024-03-20T13:07:18.496Z\",\n  \"IS_PRODUCTION\": true,\n  \"BUILD_ENV\": \"production\",\n  \"ZUPLO_VERSION\": \"5.1977.0\",\n  \"COMPATIBILITY_DATE\": \"2024-01-15\",\n  \"ACCOUNT_NAME\": \"sapphire_fluffy_amphibian\",\n  \"PROJECT_NAME\": \"sagentzuplo\",\n  \"ENVIRONMENT_TYPE\": \"WORKING_COPY\",\n  \"COMPATIBILITY_FLAGS\": {\n    \"runOutboundPoliciesOnHandlerOnAllStatuses\": true,\n    \"doNotRunHooksOnSystemRoutes\": true,\n    \"removeAllVendorHeadersExceptListed\": true\n  }\n}"],
  "mappings": "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",
  "names": ["code", "message", "hash", "isBoolean", "isUndefined", "isString", "isNumber", "re", "isObject", "hash", "val", "manager", "debug", "message", "init_environment", "init_environment", "environment", "init_environment", "handler", "init_environment", "isCompatible", "instance", "DiagComponentLogger", "DiagLogLevel", "DiagAPI", "__spreadArray", "__read", "self", "BaseContext", "self", "NoopContextManager", "__spreadArray", "__read", "API_NAME", "init_context", "ContextAPI", "__spreadArray", "__read", "TraceFlags", "NonRecordingSpan", "init_context", "init_context", "NoopTracer", "ProxyTracer", "NoopTracerProvider", "ProxyTracerProvider", "SpanStatusCode", "API_NAME", "TraceAPI", "runtimeInit", "runtimeInit", "init_environment", "localResult", "init_context", "init_environment", "handler", "response", "message", "dispatchFunction", "init_environment", "init_context", "init_environment", "timestamp", "SystemRouteName", "init_environment", "HttpStatusCode", "trace", "init_environment", "init_types", "val", "init_types", "val", "init_types", "init_context", "response", "headers", "init_types", "instance", "policyProcessor", "init_context", "init_environment", "policyResult", "val", "decode", "init_environment", "value", "init_types", "serialize", "Error", "input", "options", "pad", "init_types", "message", "init_types", "decode", "init_errors", "message", "init_errors", "init_errors", "init_errors", "hash", "types", "init_errors", "init_errors", "isObject", "init_errors", "init_errors", "init_errors", "getNamedCurve", "init_errors", "parse", "init_errors", "decode", "isObject", "decode", "init_errors", "init_errors", "init_errors", "init_errors", "init_decrypt", "init_errors", "init_decrypt", "init_errors", "init_decrypt", "init_errors", "init_errors", "init_encrypt", "init_errors", "init_encrypt", "init_errors", "hash", "init_errors", "isObject", "decode", "extensions", "init_verify", "init_errors", "init_verify", "init_errors", "init_verify", "init_errors", "init_errors", "isObject", "init_verify", "init_errors", "init_decrypt", "init_errors", "init_encrypt", "init_sign", "init_errors", "extensions", "init_sign", "init_sign", "init_errors", "isObject", "init_sign", "init_errors", "init_encrypt", "init_errors", "init_errors", "isObject", "init_errors", "jwk", "init_errors", "init_errors", "init_errors", "init_base64url", "init_base64url", "init_base64url", "init_errors", "init_errors", "init_browser", "init_decrypt", "init_encrypt", "init_verify", "init_sign", "init_errors", "init_base64url", "serviceAccount", "init_browser", "init_environment", "message", "message", "init_environment", "message", "init_environment", "dispatchFunction", "batcher", "init_environment", "import_debug", "log", "init_environment", "serviceProvider", "message", "re", "handler", "log", "import_debug", "init_context", "init_environment", "runtimeSettings", "serviceProvider", "ext", "init_context", "extensions", "handler", "map", "init_environment", "init_environment", "runtimeSettings", "serviceProvider", "schemaValidations", "runtimeInit", "request", "event", "parse", "value", "_a", "result", "encode", "val", "encoder", "import_debug", "log", "hour", "day", "year", "log", "parse", "import_debug", "message", "clone", "init_environment", "init_environment", "init_environment", "evt", "init_environment", "init_environment", "message", "init_environment", "environment", "message", "init_environment", "message", "init_environment", "init_environment", "message", "init_plugins", "timestamp", "message", "contextMap", "timestamp", "message", "init_plugins", "runtimeInit", "timestamp", "shouldLog", "encoder", "optional", "init_types", "message", "init_types", "message", "message", "init_environment", "message", "updateSubscription", "init_environment", "init_types", "timestamp", "init_environment", "init_environment", "init_environment", "val", "init_environment", "init_types", "policyProcessor", "batcher", "init_policy", "hash", "init_policy", "init_environment", "init_policy", "createRemoteJWKSet", "RemoteJWKSet", "JWKSNoMatchingKey", "JWKSTimeout", "init_browser", "init_environment", "init_policy", "init_browser", "createRemoteJWKSet", "encoder", "init_policy", "init_policy", "init_policy", "init_policy", "init_policy", "val", "init_policy", "val", "init_policy", "init_policy", "init_policy", "init_policy", "init_policy", "init_policy", "init_policy", "init_policy", "tokenScopes", "init_policy", "message", "contextMap", "body", "init_policy", "init_environment", "init_policy", "init_environment", "context", "subscription", "allowRequestsWithoutSubscription", "dynamicMeters", "mergedMeters", "init_policy", "init_policy", "init_browser", "init_errors", "init_types", "message", "init_errors", "policyName", "message", "init_environment", "init_types", "import_debug", "log", "init_environment", "rateLimitHeaderMode", "expires", "import_debug", "log", "init_policy", "init_environment", "message", "batcher", "batcherMap", "init_policy", "init_environment", "init_policy", "init_policy", "init_policy", "init_policy", "init_policy", "clone", "init_common", "clone", "response", "init_common", "init_common", "init_common", "init_common", "init_policy", "init_policy", "init_policy", "init_policy", "init_policy", "init_policy", "init_policy", "init_policy", "init_policy", "init_policy", "init_policy", "serviceAccount", "init_policy", "key", "serviceAccount", "init_policy", "serviceAccount", "init_policy", "init_policy", "clone", "__defProp", "__getOwnPropNames", "__name", "__commonJS", "re", "message", "sign", "XMLParser2", "XMLParser", "init_policy", "message", "init_dist", "init_context", "init_environment", "init_plugins", "init_policy", "init_crypto_beta", "init_key_value_store", "init_environment", "init_dist", "init_crypto_beta", "init_key_value_store", "import_dev_portal", "developerPortal"]
}
